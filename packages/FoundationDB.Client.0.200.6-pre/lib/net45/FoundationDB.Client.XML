<?xml version="1.0"?>
<doc>
    <assembly>
        <name>FoundationDB.Client</name>
    </assembly>
    <members>
        <member name="T:FoundationDB.Async.AsyncTransform`2">
            <summary>Pump that takes items from a source, transform them, and outputs them</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="R"></typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncTarget`1">
            <summary>Defines a target that receive items and can throttle the producer</summary>
            <typeparam name="T">Type of values being accepted by the target</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnNextAsync(`0,System.Threading.CancellationToken)">
            <summary>Push a new item onto the target, if it can accept one</summary>
            <param name="value">New value that is being published</param>
            <param name="cancellationToken">Cancellation token that is used to abort the call if the target is blocked</param>
            <returns>Task that completes once the target has accepted the new value (or fails if the cancellation token fires)</returns>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnCompleted">
            <summary>Notifies the target that the producer is done and that no more values will be published</summary>
        </member>
        <member name="M:FoundationDB.Async.IAsyncTarget`1.OnError(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>Notifies the target that tere was an exception, and that no more values will be published</summary>
            <param name="error">The error that occurred</param>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransform`2.Target">
            <summary>Target of the transform</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransform`2.Scheduler">
            <summary>Optional scheduler used to run the tasks</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_lock">
            <summary>Lock used to secure the global state</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_capacity">
            <summary>Maximum capacity of the queue (number of values not yet consumed)</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_done">
            <summary>If true, the last item has been sent by the source</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_receivedLast">
            <summary>If true, the last item has been received by the target</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_producerLock">
            <summary>Mutex signaling that the producer is blocked on a full queue</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncProducerConsumerQueue`1.m_consumerLock">
            <summary>Mutex signaling that the consumer is blocked on an empty queue</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.MarkProducerAsBlocked_NeedsLocking(System.Threading.CancellationToken)">
            <summary>Delcare the producer as beeing blocked on a full queue</summary>
            <param name="ct"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.WakeUpBlockedProducer_NeedsLocking">
            <summary>Wake up the producer if it is blocked</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.MarkConsumerAsBlocked_NeedsLocking(System.Threading.CancellationToken)">
            <summary>Declare the consumer as beeing blocked on an empty queue</summary>
            <param name="ct"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.AsyncProducerConsumerQueue`1.WakeUpBlockedConsumer_NeedsLocking">
            <summary>Wake up the consumer if it is blocked</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncBuffer`2">
            <summary>Buffer that holds a fixed number of items and can rate-limit the producer</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="R"></typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncSource`1">
            <summary>Defines a source that can produce items</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncSource`1.ReceiveAsync(System.Threading.CancellationToken)">
            <summary>Consume a new value from the source</summary>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that will return a new value, nothing (if it has completed) or on exception</returns>
        </member>
        <member name="F:FoundationDB.Async.AsyncBuffer`2.m_transform">
            <summary>Transformation applied on the values</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncBuffer`2.m_queue">
            <summary>Queue that holds items produced but not yet consumed</summary>
            <remarks>The queue can sometime go over the limit because the Complete/Error message are added without locking</remarks>
        </member>
        <member name="T:FoundationDB.Async.AsyncTaskBuffer`1">
            <summary>Buffer that holds a fixed number of Tasks, output them in arrival or completion order, and can rate-limit the producer</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_mode">
            <summary>How should we output results ? In arrival order or in completion order ? </summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_queue">
            <summary>Queue that holds items produced but not yet consumed</summary>
            <remarks>The queue can sometime go over the limit because the Complete/Error message are added without locking</remarks>
        </member>
        <member name="F:FoundationDB.Async.AsyncTaskBuffer`1.m_completionLock">
            <summary>Only used in mode CompletionOrder</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncTaskBuffer`1.ObserveTaskCompletion(System.Threading.Tasks.Task{`0})">
            <summary>Observe the completion of a task to wake up the consumer</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncOrderingMode">
            <summary>Order in which items in a buffer are being output</summary>
        </member>
        <member name="F:FoundationDB.Async.AsyncOrderingMode.ArrivalOrder">
            <summary>Outputs the results, respecting the arrival order.</summary>
            <remarks>If B arrives after, but completes before A, then output order will be "A, B"</remarks>
        </member>
        <member name="F:FoundationDB.Async.AsyncOrderingMode.CompletionOrder">
            <summary>Outputs the results in completion order.</summary>
            <remarks>If B arrives after, but completes before A, then output order will be "B, A"</remarks>
        </member>
        <member name="T:FoundationDB.Async.IAsyncPump`1">
            <summary>Defines a pump that can move items between a source and a target</summary>
        </member>
        <member name="M:FoundationDB.Async.IAsyncPump`1.PumpAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>Consume all the items of the source by passing them to the Target</summary>
            <param name="stopOnFirstError">If true, aborts on the first error. If false, continue processing items until the source has finished.</param>
            <param name="cancellationToken">Cancellation token that can be used to abort the pump at any time. Any unprocessed items will be lost.</param>
            <returns>Task that will complete successfully if all the items from the source have been processed by the target, or fails if an error occurred or the pump was cancelled.</returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.Source">
            <summary>Source of the pump (that produces new items)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.Target">
            <summary>Target of the tump (that will consume the items)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncPump`1.IsCompleted">
            <summary>True if all the items of the source have been consumed by the target</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncPump`1">
            <summary>Pumps item from a source, and into a target</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncPump`1.PumpAsync(System.Boolean,System.Threading.CancellationToken)">
            <summary>Run the pump until the inner iterator is done, an error occurs, or the cancellation token is fired</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncPump`1.IsCompleted">
            <summary>Returns true if the pump has completed (with success or failure)</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper">
            <summary>Helper classe used to compare object of "compatible" types</summary>
        </member>
        <member name="F:FoundationDB.Client.Converters.ComparisonHelper.EqualityComparers">
            <summary>Cache of all the comparison lambda for a pair of types</summary>
            <remarks>Contains lambda that can compare two objects (of different types) for "similarity"</remarks>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToString(System.Object)">
            <summary>Tries to convert an object into an equivalent string representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <returns>String equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToDecimal(System.Object,System.Type)">
            <summary>Tries to convert an object into an equivalent double representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <param name="type">Type of the object to adapt</param>
            <returns>Double equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.TryAdaptToInteger(System.Object,System.Type)">
            <summary>Tries to convert an object into an equivalent Int64 representation (for equality comparison)</summary>
            <param name="value">Object to adapt</param>
            <param name="type">Type of the object to adapt</param>
            <returns>Int64 equivalent of the object</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.AreSimilar(System.Object,System.Object)">
            <summary>Tries to compare any two object for "equality", where string "123" is considered equal to integer 123</summary>
            <param name="x">Left object to compare</param>
            <param name="y">Right object to compare</param>
            <returns>True if both objects are "similar" (ie: the represent the same logical value)</returns>
            <example>
            AreSimilar("123", 123) => true
            AreSimilar('A', "A") => true
            AreSimilar(false, 0) => true
            AreSimilar(true, 1) => true
            </example>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.AreEquivalentTypes(System.Type,System.Type)">
            <summary>Returns true if both types are considered "the same"</summary>
            <returns>Returns true if t1 is equal to t2</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsStringType(System.Type)">
            <summary>Return true if the type is considered to be a "string" (string, char)</summary>
            <returns>True for <see cref="T:System.String">string</see> and <see cref="T:System.Char">char</see>.</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsNumericType(System.Type)">
            <summary>Returns true if the specified type is considered to be a "number"</summary>
            <returns>True for integers (8, 16, 32 or 64 bits, signed or unsigned) and their Nullable versions. Bytes and Chars are not considered to be numbers because they a custom serialized</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.ComparisonHelper.IsDecimalType(System.Type)">
            <summary>Returns true if the specified type is considered to be a "decimal"</summary>
            <returns>True for <see cref="T:System.Double">double</see> and <see cref="T:System.Single">float</see>.</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper.TypePair">
            <summary>Pair of types that can be used as a key in a dictionary</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.ComparisonHelper.TypePairComparer">
            <summary>Helper class to use TypePair as keys in a dictionnary</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.SimilarValueComparer">
            <summary>Object comparer that returns true if both values are "similar"</summary>
            <remarks>This comparer SHOULD NOT be used in a Dictioanry, because it violates on of the conditions: Two objects could be considered equal, but have different hashcode!</remarks>
        </member>
        <member name="T:FoundationDB.Client.Core.IFdbClusterHandler">
            <summary>Basic API for FoundationDB clusters</summary>
        </member>
        <member name="T:FoundationDB.Client.Core.IFdbDatabaseHandler">
            <summary>Basic API for FoundationDB databases</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbSubspace">
            <summary>Adds a prefix on every keys, to group them inside a common subspace</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbKey">
            <summary>Allows a layer or custom class to be used as keys in a FoundationDB database</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbKey.ToFoundationDbKey">
            <summary>Returns a binary representation of this instance, to be used as a complete key in the database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbSubspace.Empty">
            <summary>Empty subspace, that does not add any prefix to the keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbSubspace.m_rawPrefix">
            <summary>Binary prefix of this subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Client.FdbSubspace)">
            <summary>Wraps an existing subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Create a new subspace from a binary prefix</summary>
            <param name="rawPrefix">Prefix of the new subspace</param>
            <param name="copy">If true, take a copy of the prefix</param>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Client.Slice)">
            <summary>Create a new subspace from a binary prefix</summary>
            <param name="rawPrefix">Prefix of the new subspace</param>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.#ctor(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a new subspace from a Tuple prefix</summary>
            <param name="tuple">Tuple packed to produce the prefix</param>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.GetKeyPrefix">
            <summary>Returns the key to use when creating direct keys that are inside this subspace</summary>
            <returns>Prefix that must be added to all keys created by this subspace</returns>
            <remarks>Subspaces that disallow the creation of keys should override this method and throw an exception</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Contains(FoundationDB.Client.Slice)">
            <summary>Tests whether the specified <paramref name="key"/> starts with this Subspace's prefix, indicating that the Subspace logically contains <paramref name="key"/>.</summary>
            <param name="key">The key to be tested</param>
            <remarks>The key Slice.Nil is not contained by any Subspace, so subspace.Contains(Slice.Nil) will always return false</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice)">
            <summary>Append a key to the subspace key</summary>
            <remarks>This is the equivalent of calling 'subspace.Key + key'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Extract(FoundationDB.Client.Slice)">
            <summary>Remove the subspace prefix from a binary key, and only return the tail, or Slice.Nil if the key does not fit inside the namespace</summary>
            <param name="key">Complete key that contains the current subspace prefix, and a binary suffix</param>
            <returns>Binary suffix of the key (or Slice.Empty is the key is exactly equal to the subspace prefix). If the key is outside of the subspace, returns Slice.Nil</returns>
            <remarks>This is the inverse operation of <see cref="M:FoundationDB.Client.FdbSubspace.Concat(FoundationDB.Client.Slice)"/></remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.Extract(FoundationDB.Client.Slice[])">
            <summary>Remove the subspace prefix from a batch of binary keys, and only return the tail, or Slice.Nil if a key does not fit inside the namespace</summary>
            <param name="keys">Array of complete keys that contains the current subspace prefix, and a binary suffix</param>
            <returns>Array of only the binary suffix of the keys, Slice.Empty for a key that is exactly equal to the subspace prefix, or Slice.Nil for a key that is outside of the subspace</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.ExtractAndCheck(FoundationDB.Client.Slice)">
            <summary>Remove the subspace prefix from a binary key, or throw if the key does not belong to this subspace</summary>
            <param name="key">Complete key that contains the current subspace prefix, and a binary suffix.</param>
            <returns>Binary suffix of the key (or Slice.Empty is the key is exactly equal to the subspace prefix). If the key is equal to Slice.Nil, then it will be returned unmodified. If the key is outside of the subspace, the method throws.</returns>
            <exception cref="T:System.ArgumentException">If key is outside the current subspace.</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.ToRange">
            <summary>Gets a key range respresenting all keys strictly within the Subspace.</summary>
            <rereturns>Key range that, when passed to ClearRange() or GetRange(), would clear or return all the keys contained by this subspace, excluding the subspace prefix itself.</rereturns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.ToRange(FoundationDB.Client.Slice)">
            <summary>Gets a key range respresenting all keys strictly within a sub-section of this Subspace.</summary>
            <param name="suffix">Suffix added to the subspace prefix</param>
            <rereturns>Key range that, when passed to ClearRange() or GetRange(), would clear or return all the keys contained by this subspace, excluding the subspace prefix itself.</rereturns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspace.BoundCheck(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Check that a key fits inside this subspace, and return '' or '\xFF' if it is outside the bounds</summary>
            <param name="key">Key that needs to be checked</param>
            <param name="allowSystemKeys">If true, allow keys that starts with \xFF even if this subspace is not the Empty subspace or System subspace itself.</param>
            <returns>The <paramref name="key"/> unchanged if it is contained in the namespace, Slice.Empty if it was before the subspace, or FdbKey.MaxValue if it was after.</returns>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.InternalKey">
            <summary>Returns the key of this directory subspace</summary>
            <remarks>This should only be used by methods that can use the key internally, even if it is not supposed to be exposed (as is the case for directory partitions)</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Item(FoundationDB.Client.Slice)">
            <summary>Create a new subspace of the current subspace</summary>
            <param name="suffix">Binary suffix that will be appended to the current prefix</param>
            <returns>New subspace whose prefix is the concatenation of the parent prefix, and <paramref name="suffix"/></returns>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Item(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a new subspace of the current subspace</summary>
            <param name="tuple">Binary suffix that will be appended to the current prefix</param>
            <returns>New subspace whose prefix is the concatenation of the parent prefix, and <paramref name="tuple"/></returns>
        </member>
        <member name="P:FoundationDB.Client.FdbSubspace.Key">
            <summary>Returns the raw prefix of this subspace</summary>
            <remarks>Will throw if the prefix is not publicly visible, as is the case for Directory Partitions</remarks>
        </member>
        <member name="M:FoundationDB.Client.IKeyEncoder`1.EncodeKey(`0)">
            <summary>Encode a single value</summary>
        </member>
        <member name="M:FoundationDB.Client.IKeyEncoder`1.DecodeKey(FoundationDB.Client.Slice)">
            <summary>Decode a single value</summary>
            <param name="encoded"></param>
            <returns></returns>
        </member>
        <member name="P:FoundationDB.Client.FdbEncoderSubspace`2.Encoder">
            <summary>Gets the key encoder</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbEncoderSubspace`2.Partial">
            <summary>Returns a partial encoder for (T1,)</summary>
        </member>
        <member name="M:FoundationDB.Client.IValueEncoder`1.EncodeValue(`0)">
            <summary>Encode a single value</summary>
        </member>
        <member name="M:FoundationDB.Client.IValueEncoder`1.DecodeValue(FoundationDB.Client.Slice)">
            <summary>Decode a single value</summary>
            <param name="encoded"></param>
            <returns></returns>
        </member>
        <member name="T:FoundationDB.Client.FdbEndPoint">
            <summary>Represents a FoundationDB network endpoint as an IP address, port number and TLS mode.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbEndPoint.Tls">
            <summary>Gets or sets the TLS mode of the endpoint.</summary>
            <remarks>True if the endpoint uses TLS</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Directories.FdbDirectorySubspace">
            <summary>A Directory Subspace represents the contents of a directory, but it also remembers the path with which it was opened and offers convenience methods to operate on the directory at that path.</summary>
            <remarks>An instance of DirectorySubspace can be used for all the usual subspace operations. It can also be used to operate on the directory with which it was opened.</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Directories.IFdbDirectory">
            <summary>
            Represents a directory in the <code>DirectoryLayer</code>. A <code>Directory</code> stores the path at which it is located and the layer that was used to create it.
            The IFdbDirectory interface contains methods to operate on itself and its subdirectories.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given path.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            If layer is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.OpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to open</param>
            <param name="layer">Expected layer id for the subdirectory (optional)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryOpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to open</param>
            <param name="layer">Expected layer id for the subdirectory (optional)</param>
            <returns>Returns the directory if it exists, or null if it was not found</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.CreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="subPath"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryCreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="subPath"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="subPath">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.MoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Moves the specified subdirectory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Relative path under this directory of the subdirectory to be moved</param>
            <param name="newPath">Relative path under this directory where the subdirectory will be moved to</param>
            <returns>Returns the directory at its new location if successful.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryMoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to move the specified subdirectory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Relative path under this directory of the subdirectory to be moved</param>
            <param name="newPath">Relative path under this directory where the subdirectory will be moved to</param>
            <returns>Returns the directory at its new location if successful. If the directory doesn't exist, then null is returned.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.MoveToAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Moves the current directory to <paramref name="newAbsolutePath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newAbsolutePath">Full path (from the root) where this directory will be moved</param>
            <returns>Returns the directory at its new location if successful.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryMoveToAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to move the current directory to <paramref name="newAbsolutePath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newAbsolutePath">Full path (from the root) where this directory will be moved</param>
            <returns>Returns the directory at its new location if successful. If the directory doesn't exist, then null is returned.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.RemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Removes a directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove. Will remove the current directory if <paramref name="path"/> is null</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryRemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to remove the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove. Will remove the current directory if <paramref name="path"/> is null</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Checks if this directory exists</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to test</param>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of all the subdirectories of the current directory.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.IFdbDirectory.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of all the subdirectories of the current directory, it it exists.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="P:FoundationDB.Layers.Directories.IFdbDirectory.Name">
            <summary>Name of this <code>Directory</code>.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.IFdbDirectory.FullName">
            <summary>Formatted path of this <code>Directory</code></summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.IFdbDirectory.Path">
            <summary>Gets the path represented by this <code>Directory</code>.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.IFdbDirectory.Layer">
            <summary>Gets the layer id slice that was stored when this <code>Directory</code> was created.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.IFdbDirectory.DirectoryLayer">
            <summary>Get the <code>DirectoryLayer</code> that was used to create this <code>Directory</code>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.GetLayerForPath(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Return the DirectoryLayer instance that should be called for the given path</summary>
            <param name="relativeLocation">Location relative to this directory subspace</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ToRelativePath(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Convert a path relative to this directory, into a path relative to the root of the current partition</summary>
            <param name="location">Path relative from this directory</param>
            <returns>Path relative to the path of the current partition</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ToRelativePath(System.Collections.Generic.IEnumerable{System.String})">
            <summary>Convert a path relative to this directory, into a path relative to the root of the current partition</summary>
            <param name="path">Path relative from this directory</param>
            <returns>Path relative to the path of the current partition</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CheckLayer(FoundationDB.Client.Slice)">
            <summary>Ensure that this directory was registered with the correct layer id</summary>
            <param name="layer">Expected layer id (if not empty)</param>
            <exception cref="T:System.InvalidOperationException">If the directory was registerd with a different layer id</exception>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ChangeLayerAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice)">
            <summary>Change the layer id of this directory</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newLayer">New layer id of this directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            If the subdirectory does not exist, it is created (creating intermediate subdirectories if necessary).
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to create or open</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is checked against the layer of an existing subdirectory or set as the layer of a new subdirectory.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.OpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory does not exist, or if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to open</param>
            <param name="layer">If specified, the opened directory must have the same layer id.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryOpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens a subdirectory with the given <paramref name="path"/>.
            An exception is thrown if the subdirectory if a layer is specified and a different layer was specified when the subdirectory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to open</param>
            <param name="layer">If specified, the opened directory must have the same layer id.</param>
            <returns>Returns the directory if it exists, or null if it was not found</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.CreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryCreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Creates a subdirectory with the given <paramref name="path"/> (creating intermediate subdirectories if necessary).
            An exception is thrown if the given subdirectory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Relative path of the subdirectory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the subdirectory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.MoveToAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Moves the current directory to <paramref name="newAbsolutePath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newAbsolutePath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.FoundationDB#Layers#Directories#IFdbDirectory#MoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Moves the specified subdirectory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Relative path under this directory of the subdirectory to be moved</param>
            <param name="newPath">Relative path under this directory where the subdirectory will be moved to</param>
            <returns>Returns the directory at its new location if successful.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryMoveToAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="newPath">Full path (from the root) where this directory will be moved</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.FoundationDB#Layers#Directories#IFdbDirectory#TryMoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to move the specified subdirectory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Relative path under this directory of the subdirectory to be moved</param>
            <param name="newPath">Relative path under this directory where the subdirectory will be moved to</param>
            <returns>Returns the directory at its new location if successful. If the directory cannot be moved, then null is returned.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.RemoveAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.RemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Removes a sub-directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the sub-directory to remove (relative to this directory)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryRemoveAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Attempts to remove the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryRemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to remove a sub-directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the sub-directory to remove (relative to this directory)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Checks if this directory exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Checks if a sub-directory exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of all the subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of all the subdirectories of a sub-directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of all the subdirectories of a sub-directory, it it exists.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of all the subdirectories of the current directory, it it exists.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectorySubspace.ToString">
            <summary>Returns a user-friendly description of this directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Location">
            <summary>Absolute location of the directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.RelativeLocation">
            <summary>Location of the directory relative to its parent Directory Layer</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Path">
            <summary>Absolute path of this directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Name">
            <summary>Name of the directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.FullName">
            <summary>Formatted path of this directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.DirectoryLayer">
            <summary>Instance of the DirectoryLayer that was used to create or open this directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectorySubspace.Layer">
            <summary>Layer id of this directory</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbNativeCluster">
            <summary>Wraps a native FDBCluster* handle</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbCluster">
            <summary>Cluster connection context.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbCluster.SetOption(FoundationDB.Client.FdbClusterOption)">
            <summary>Set an option on this cluster that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbCluster.SetOption(FoundationDB.Client.FdbClusterOption,System.String)">
            <summary>Set an option on this cluster that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbCluster.SetOption(FoundationDB.Client.FdbClusterOption,System.Int64)">
            <summary>Set an option on this cluster that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbCluster.OpenDatabaseAsync(System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster, configured to only access a specific subspace of keys</summary>
            <param name="databaseName">Name of the database. Must be 'DB' (as of Beta 2)</param>
            <param name="subspace">Subspace of keys that will be accessed.</param>
            <param name="readOnly">If true, the database will only allow read operations.</param>
            <param name="cancellationToken">Cancellation Token (optionnal) for the connect operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
        </member>
        <member name="P:FoundationDB.Client.IFdbCluster.Path">
            <summary>Path to the cluster file used by this connection, or null if the default cluster file is being used</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.RawValue">
            <summary>The raw value of the file</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Id">
            <summary>Cluster Identifier</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Description">
            <summary>Logical description of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbClusterFile.Coordinators">
            <summary>List of coordination servers</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbNativeDatabase">
            <summary>Wraps a native FDBDatabase* handle</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNativeDatabase.m_handle">
            <summary>Handle that wraps the native FDB_DATABASE*</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabaseExtensions">
            <summary>Provides a set of extensions methods shared by all FoundationDB database implementations.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.BeginReadOnlyTransaction(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Start a new read-only transaction on this database</summary>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <returns>New transaction instance that can read from the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginReadOnlyTransaction(CancellationToken.None))
            {
            	var result = await tr.Get(Slice.FromString("Hello"));
            	var items = await tr.GetRange(FdbKeyRange.StartsWith(Slice.FromString("ABC"))).ToListAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.BeginTransaction(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Start a new transaction on this database</summary>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetLocationCacheSize(FoundationDB.Client.IFdbDatabase,System.Int32)">
            <summary>Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. Defaults to 100000.</summary>
            <param name="size">Max location cache entries</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetMaxWatches(FoundationDB.Client.IFdbDatabase,System.Int32)">
            <summary>Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000.</summary>
            <param name="count">Max outstanding watches</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetMachineId(FoundationDB.Client.IFdbDatabase,System.String)">
            <summary>Specify the machine ID that was passed to fdbserver processes running on the same machine as this client, for better location-aware load balancing.</summary>
            <param name="hexId">Hexadecimal ID</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetDataCenterId(FoundationDB.Client.IFdbDatabase,System.String)">
            <summary>Specify the datacenter ID that was passed to fdbserver processes running in the same datacenter as this client, for better location-aware load balancing.</summary>
            <param name="hexId">Hexadecimal ID</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.IsKeyValid(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Test if a key is allowed to be used with this database instance</summary>
            <param name="key">Key to test</param>
            <returns>Returns true if the key is not null or empty, does not exceed the maximum key size, and is contained in the global key space of this database instance. Otherwise, returns false.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.EnsureKeyIsValid(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,System.Boolean)">
            <summary>Checks that a key is inside the global namespace of this database, and contained in the optional legal key space specified by the user</summary>
            <param name="key">Key to verify</param>
            <param name="endExclusive">If true, the key is allowed to be one past the maximum key allowed by the global namespace</param>
            <exception cref="T:FoundationDB.Client.FdbException">If the key is outside of the allowed keyspace, throws an FdbException with code FdbError.KeyOutsideLegalRange</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.EnsureKeysAreValid(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice[],System.Boolean)">
            <summary>Checks that one or more keys are inside the global namespace of this database, and contained in the optional legal key space specified by the user</summary>
            <param name="keys">Array of keys to verify</param>
            <param name="endExclusive">If true, the keys are allowed to be one past the maximum key allowed by the global namespace</param>
            <exception cref="T:FoundationDB.Client.FdbException">If at least on key is outside of the allowed keyspace, throws an FdbException with code FdbError.KeyOutsideLegalRange</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Extract(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Remove the global namespace prefix of this database form the key, and return the rest of the bytes, or Slice.Nil is the key is outside the namespace</summary>
            <param name="keyAbsolute">Binary key that starts with the namespace prefix, followed by some bytes</param>
            <returns>Binary key that contain only the bytes after the namespace prefix</returns>
            <example>
            // db with namespace prefix equal to"&lt;02&gt;Foo&lt;00&gt;"
            db.Extract('&lt;02&gt;Foo&lt;00&gt;&lt;02&gt;Bar&lt;00&gt;') => '&gt;&lt;02&gt;Bar&lt;00&gt;'
            db.Extract('&lt;02&gt;Foo&lt;00&gt;') => Slice.Empty
            db.Extract('&lt;02&gt;TopSecret&lt;00&gt;&lt;02&gt;Password&lt;00&gt;') => Slice.Nil
            db.Extract(Slice.Nil) => Slice.Nil
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.Unpack(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.UnpackLast``1(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.UnpackSingle``1(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice)">
            <summary>Unpack a key using the current namespace of the database</summary>
            <param name="key">Key that should fit inside the current namespace of the database</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.GetAndWatch(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Reads the value associated with <paramref name="key"/>, and returns a Watch that will complete after a subsequent change to key in the database.</summary>
            <param name="db">Database instance.</param>
            <param name="key">Key to be looked up in the database</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property contains the current value of the key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabaseExtensions.SetAndWatch(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <param name="db">Database instance.</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="T:FoundationDB.Client.Core.IFdbTransactionHandler">
            <summary>Basic API for FoundationDB transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.SetOption(FoundationDB.Client.FdbTransactionOption,FoundationDB.Client.Slice)">
            <summary>Set an option on this transaction</summary>
            <param name="option">Option to set</param>
            <param name="data">Parameter value (or Slice.Nil for parameterless options)</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetReadVersionAsync(System.Threading.CancellationToken)">
            <summary>Returns this transaction snapshot read version.</summary>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetCommittedVersion">
            <summary>Retrieves the database version number at which a given transaction was committed.</summary>
            <remarks>CommitAsync() must have been called on this transaction and the resulting task must have completed successfully before this function is callged, or the behavior is undefined.
            Read-only transactions do not modify the database when committed and will have a committed version of -1.
            Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.SetReadVersion(System.Int64)">
            <summary>Sets the snapshot read version used by a transaction. This is not needed in simple cases.</summary>
            <param name="version">Read version to use in this transaction</param>
            <remarks>
            If the given version is too old, subsequent reads will fail with error_code_past_version; if it is too new, subsequent reads may be delayed indefinitely and/or fail with error_code_future_version.
            If any of Get*() methods have been called on this transaction already, the result is undefined.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetAsync(FoundationDB.Client.Slice,System.Boolean,System.Threading.CancellationToken)">
            <summary>Reads a get from the database</summary>
            <param name="key">Key to read</param>
            <param name="snapshot">Set to true for snapshot reads</param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetValuesAsync(FoundationDB.Client.Slice[],System.Boolean,System.Threading.CancellationToken)">
            <summary>Reads several values from the database snapshot represented by the current transaction</summary>
            <param name="keys">Keys to be looked up in the database</param>
            <param name="snapshot">Set to true for snapshot reads</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Task that will return an array of values, or an exception. Each item in the array will contain the value of the key at the same index in <paramref name="keys"/>, or Slice.Nil if that key does not exist.</returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetKeyAsync(FoundationDB.Client.FdbKeySelector,System.Boolean,System.Threading.CancellationToken)">
            <summary>Resolves a key selector against the keys in the database snapshot represented by the current transaction.</summary>
            <param name="selector">Key selector to resolve</param>
            <param name="snapshot">Set to true for snapshot reads</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Task that will return the key matching the selector, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetKeysAsync(FoundationDB.Client.FdbKeySelector[],System.Boolean,System.Threading.CancellationToken)">
            <summary>Resolves several key selectors against the keys in the database snapshot represented by the current transaction.</summary>
            <param name="selectors">Key selectors to resolve</param>
            <param name="snapshot">Set to true for snapshot reads</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode) which have a key lexicographically greater than or equal to the key resolved by the begin key selector and lexicographically less than the key resolved by the end key selector.</summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <param name="snapshot">Set to true for snapshot reads</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.GetAddressesForKeyAsync(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <paramref name="key"/> and its associated value</summary>
            <param name="key">Name of the key whose location is to be queried.</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Task that will return an array of strings, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Set(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Modify the database snapshot represented by transaction to change the given key to have the given value. If the given key was not previously present in the database it is inserted.
            The modification affects the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Atomic(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType)">
            <summary>Modify the database snapshot represented by this transaction to perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.</summary>
            <param name="key">Name of the key whose value is to be mutated.</param>
            <param name="param">Parameter with which the atomic operation will mutate the value associated with key_name.</param>
            <param name="mutation">Type of mutation that should be performed on the key</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Clear(FoundationDB.Client.Slice)">
            <summary>Modify the database snapshot represented by this transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.</summary>
            <param name="key">Name of the key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.ClearRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Modify the database snapshot represented by this transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="beginKeyInclusive">Name of the key specifying the beginning of the range to clear.</param>
            <param name="endKeyExclusive">Name of the key specifying the end of the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.AddConflictRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbConflictRangeType)">
            <summary>Adds a conflict range to a transaction without performing the associated read or write.</summary>
            <param name="beginKeyInclusive">Key specifying the beginning of the conflict range. The key is included</param>
            <param name="endKeyExclusive">Key specifying the end of the conflict range. The key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Watch(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Watch a key for any change in the database.</summary>
            <param name="key">Key to watch</param>
            <param name="cancellationToken">CancellationToken used to abort the watch if the caller doesn't want to wait anymore. Note that you can manually cancel the watch by calling Cancel() on the returned FdbWatch instance</param>
            <returns>FdbWatch that can be awaited and will complete when the key has changed in the database, or cancellation occurs. You can call Cancel() at any time if you are not interested in watching the key anymore. You MUST always call Dispose() if the watch completes or is cancelled, to ensure that resources are released properly.</returns>
            <remarks>You can directly await an FdbWatch, or obtain a Task&lt;Slice&gt; by reading the <see cref="P:FoundationDB.Client.FdbWatch.Task"/> property.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.CommitAsync(System.Threading.CancellationToken)">
            <summary>Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.OnErrorAsync(FoundationDB.Client.FdbError,System.Threading.CancellationToken)">
            <summary>Implements the recommended retry and backoff behavior for a transaction.
            This function knows which of the error codes generated by other query functions represent temporary error conditions and which represent application errors that should be handled by the application. 
            It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.
            </summary>
            <param name="code">FdbError code thrown by the previous command</param>
            <param name="cancellationToken">Token used to cancel the operation from the outside</param>
            <returns>Returns a task that completes if the operation can be safely retried, or that rethrows the original exception if the operation is not retryable.</returns>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Reset">
            <summary>Reset transaction to its initial state.</summary>
            <remarks>This is similar to disposing the transaction and recreating a new one.  The only state that persists through a transaction reset is that which is related to the backoff logic used by OnErrorAsync()</remarks>
        </member>
        <member name="M:FoundationDB.Client.Core.IFdbTransactionHandler.Cancel">
            <summary>Cancels the transaction. All pending or future uses of the transaction will return a TransactionCancelled error code. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="P:FoundationDB.Client.Core.IFdbTransactionHandler.Size">
            <summary>Returns the estimated payload size of the transaction (including keys and values)</summary>
        </member>
        <member name="P:FoundationDB.Client.Core.IFdbTransactionHandler.IsClosed">
            <summary>Checks if this transaction handler is closed</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbNativeTransaction">
            <summary>Wraps a native FDB_TRANSACTION handle</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNativeTransaction.m_handle">
            <summary>FDB_TRANSACTION* handle</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNativeTransaction.m_payloadBytes">
            <summary>Estimated current size of the transaction</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNativeTransaction.GetKeyValueArrayResult(FoundationDB.Client.Native.FutureHandle,System.Boolean@)">
            <summary>Extract a chunk of result from a completed Future</summary>
            <param name="h">Handle to the completed Future</param>
            <param name="more">Receives true if there are more result, or false if all results have been transmited</param>
            <returns>Array of key/value pairs, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNativeTransaction.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32,System.Boolean,System.Threading.CancellationToken)">
            <summary>Asynchronously fetch a new page of results</summary>
            <returns>True if Chunk contains a new page of results. False if all results have been read.</returns>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNativeTransaction.CommitAsync(System.Threading.CancellationToken)">
            <summary>
            Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="P:FoundationDB.Client.Native.FdbNativeTransaction.Handle">
            <summary>Native FDB_TRANSACTION* handle</summary>
        </member>
        <member name="P:FoundationDB.Client.Native.FdbNativeTransaction.Size">
            <summary>Estimated size of the transaction payload (in bytes)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionMode.ReadOnly">
            <summary>The transaction will only allow read operations</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionMode.InsideRetryLoop">
            <summary>If set, the transaction is running within the context of a retry loop</summary>
        </member>
        <member name="M:FoundationDB.Filters.FdbFilterExtensions.AsReadOnly(FoundationDB.Client.IFdbTransaction)">
            <summary>Return a read-only view of this transaction, that will only allow read operations.</summary>
            <param name="trans">Transaction to secure</param>
            <returns>The same transaction instance if it is already read-only, or a thin read-only wrapper around the transaction if it is writeable.</returns>
        </member>
        <member name="T:FoundationDB.Filters.FdbTransactionFilter">
            <summary>Base class for simple transaction filters</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbTransaction">
            <summary>Transaction that allows read and write operations</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbReadOnlyTransaction">
            <summary>Transaction that allows read operations</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.EnsureCanRead">
            <summary>Ensure thats the transaction is in a valid state for issuing read operations.</summary>
            <exception cref="T:System.ObjectDisposedException">If <see cref="M:System.IDisposable.Dispose">Dispose()</see> has already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If the transaction as already been committed, or if the database connection has been closed</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token has been cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetAsync(FoundationDB.Client.Slice)">
            <summary>Reads a value from the database snapshot represented by by the current transaction.</summary>
            <param name="key">Key to be looked up in the database</param>
            <returns>Task that will return the value of the key if it is found, Slice.Nil if the key does not exist, or an exception</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="key"/> is null</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token is already triggered</exception>
            <exception cref="T:System.ObjectDisposedException">If the transaction has already been completed</exception>
            <exception cref="T:System.InvalidOperationException">If the operation method is called from the Network Thread</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetValuesAsync(FoundationDB.Client.Slice[])">
            <summary>Reads several values from the database snapshot represented by the current transaction</summary>
            <param name="keys">Keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. Each item in the array will contain the value of the key at the same index in <paramref name="keys"/>, or Slice.Nil if that key does not exist.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetKeyAsync(FoundationDB.Client.FdbKeySelector)">
            <summary>Resolves a key selector against the keys in the database snapshot represented by the current transaction.</summary>
            <param name="selector">Key selector to resolve</param>
            <returns>Task that will return the key matching the selector, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetKeysAsync(FoundationDB.Client.FdbKeySelector[])">
            <summary>Resolves several key selectors against the keys in the database snapshot represented by the current transaction.</summary>
            <param name="selectors">Key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetRange(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions)">
            <summary>
            Create a new range query that will read all key-value pairs in the database snapshot represented by the transaction
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <returns>Range query that, once executed, will return all the key-value pairs matching the providing selector pair</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetAddressesForKeyAsync(FoundationDB.Client.Slice)">
            <summary>Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <paramref name="key"/> and its associated value</summary>
            <param name="key">Name of the key whose location is to be queried.</param>
            <returns>Task that will return an array of strings, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetReadVersionAsync">
            <summary>Returns this transaction snapshot read version.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetReadVersion(System.Int64)">
            <summary>
            Sets the snapshot read version used by a transaction. This is not needed in simple cases.
            </summary>
            <param name="version">Read version to use in this transaction</param>
            <remarks>
            If the given version is too old, subsequent reads will fail with error_code_past_version; if it is too new, subsequent reads may be delayed indefinitely and/or fail with error_code_future_version.
            If any of Get*() methods have been called on this transaction already, the result is undefined.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.Cancel">
            <summary>Cancels the transaction. All pending or future uses of the transaction will return a TransactionCancelled error code. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.Reset">
            <summary>
            Reset transaction to its initial state.
            </summary>
            <remarks>This is similar to disposing the transaction and recreating a new one.  The only state that persists through a transaction reset is that which is related to the backoff logic used by OnErrorAsync()</remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.OnErrorAsync(FoundationDB.Client.FdbError)">
            <summary>
            Implements the recommended retry and backoff behavior for a transaction.
            
            This function knows which of the error codes generated by other query functions represent temporary error conditions and which represent application errors that should be handled by the application. 
            It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.
            </summary>
            <param name="code">FdbError code thrown by the previous command</param>
            <returns>Returns a task that completes if the operation can be safely retried, or that rethrows the original exception if the operation is not retryable.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption)">
            <summary>Set an option on this transaction that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.String)">
            <summary>Set an option on this transaction that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.Int64)">
            <summary>Set an option on this transaction that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Id">
            <summary>Local id of the transaction</summary>
            <remarks>This id is only guaranteed unique inside the current AppDomain or process and is reset on every restart. It should only be used for diagnostics and/or logging.</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Context">
            <summary>Context of this transaction.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.IsSnapshot">
            <summary>If true, the transaction is operating in Snapshot mode</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Snapshot">
            <summary>Return a Snapshotted version of this transaction, or the transaction itself it is already operating in Snapshot mode.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Cancellation">
            <summary>Cancellation Token linked to the life time of the transaction</summary>
            <remarks>Will be triggered if the transaction is aborted or disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.Timeout">
            <summary>Timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbReadOnlyTransaction.RetryLimit">
            <summary>Maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.EnsureCanWrite">
            <summary>
            Ensure thats the transaction is in a valid state for issuing write operations.
            </summary>
            <exception cref="T:System.ObjectDisposedException">If <see cref="M:System.IDisposable.Dispose">Dispose()</see> has already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If the transaction as already been committed, or if the database connection has been closed</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token has been cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Set(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to change the given key to have the given value. If the given key was not previously present in the database it is inserted.
            The modification affects the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Atomic(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType)">
            <summary>
            Modify the database snapshot represented by this transaction to perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
            <param name="key">Name of the key whose value is to be mutated.</param>
            <param name="param">Parameter with which the atomic operation will mutate the value associated with key_name.</param>
            <param name="mutation">Type of mutation that should be performed on the key</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Clear(FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by this transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Name of the key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.ClearRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by this transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="beginKeyInclusive">Name of the key specifying the beginning of the range to clear.</param>
            <param name="endKeyExclusive">Name of the key specifying the end of the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.AddConflictRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="beginKeyInclusive">Key specifying the beginning of the conflict range. The key is included</param>
            <param name="endKeyExclusive">Key specifying the end of the conflict range. The key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.CommitAsync">
            <summary>
            Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.GetCommittedVersion">
            <summary>
            Retrieves the database version number at which a given transaction was committed.
            </summary>
            <returns></returns>
            <remarks>
            CommitAsync() must have been called on this transaction and the resulting task must have completed successfully before this function is callged, or the behavior is undefined.
            Read-only transactions do not modify the database when committed and will have a committed version of -1.
            Keep in mind that a transaction which reads keys and then sets them to their current values may be optimized to a read-only transaction.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransaction.Watch(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Watch a key for any change in the database.
            </summary>
            <param name="key">Key to watch</param>
            <param name="cancellationToken">CancellationToken used to abort the watch if the caller doesn't want to wait anymore. Note that you can manually cancel the watch by calling Cancel() on the returned FdbWatch instance</param>
            <returns>FdbWatch that can be awaited and will complete when the key has changed in the database, or cancellation occurs. You can call Cancel() at any time if you are not interested in watching the key anymore. You MUST always call Dispose() if the watch completes or is cancelled, to ensure that resources are released properly.</returns>
            <remarks>You can directly await an FdbWatch, or obtain a Task&lt;Slice&gt; by reading the <see cref="P:FoundationDB.Client.FdbWatch.Task"/> property.</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbTransaction.IsReadOnly">
            <summary>Returns true if this transaction instance only allow read operations</summary>
            <remarks>Attempting to call a write method on a read-only transaction will immediately throw an exception</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbTransaction.Size">
            <summary>
            Estimated payload size of the transaction (in bytes)
            </summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_transaction">
            <summary>Inner database</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_readOnly">
            <summary>If true, forces the underlying transaction to be read only</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_owner">
            <summary>If true, dispose the inner database when we get disposed</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbTransactionFilter.m_disposed">
            <summary>If true, we have been disposed</summary>
        </member>
        <member name="M:FoundationDB.Filters.FdbTransactionFilter.#ctor(FoundationDB.Client.IFdbTransaction,System.Boolean,System.Boolean)">
            <summary>Base constructor for transaction filters</summary>
            <param name="trans">Underlying transaction that will be exposed as read-only</param>
            <param name="forceReadOnly">If true, force the transaction to be read-only. If false, use the read-only mode of the underlying transaction</param>
            <param name="ownsTransaction">If true, the underlying transaction will also be disposed when this instance is disposed</param>
        </member>
        <member name="F:FoundationDB.Filters.FdbReadOnlyTransactionFilter.m_transaction">
            <summary>Inner database</summary>
        </member>
        <member name="T:FoundationDB.Filters.FdbDatabaseFilter">
            <summary>Base class for simple database filters</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbDatabase">
            <summary>Database connection context.</summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbReadOnlyTransactional">
            <summary>Transactional context that can execute read-only transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransactional.ReadAsync(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>
            Runs a transactional lambda function inside a read-only transaction context, with optional retry-logic.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbReadOnlyTransactional.ReadAsync``1(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>
            Runs a transactional lambda function inside a read-only transaction context, with optional retry-logic.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.IFdbTransactional">
            <summary>Transactional context that can execute read and/or write transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block inside a write-only transaction context, with optional retry logic.</summary>
            <param name="handler">Idempotent handler that will be retried until the transaction commits, or a non-recoverable error occurs.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block inside a write-only transaction context, with optional retry logic.</summary>
            <param name="handler">Idempotent async handler that will be retried until the transaction commits, or a non-recoverable error occurs.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block inside a read-write transaction context, with optional retry logic.</summary>
            <param name="asyncHandler">Idempotent asynchronous handler that will be retried until the transaction commits, or a non-recoverable error occurs.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs an idempotent transactional block that returns a value, inside a read-write transaction context, with optional retry logic.</summary>
            <param name="asyncHandler">Idempotent asynchronous lambda function that will be retried until the transaction commits, or a non-recoverable error occurs. The returned value of the last call will be the result of the operation.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Result of the lambda function if the transaction committed sucessfully.</returns>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.WriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbTransactional.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>[EXPERIMENTAL] do not use yet!.</summary>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption)">
            <summary>Set a parameter-less option on this database</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.String)">
            <summary>Set an option on this database that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.Int64)">
            <summary>Set an option on this database that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.BeginTransaction(FoundationDB.Client.FdbTransactionMode,System.Threading.CancellationToken,FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database, with the specified mode</summary>
            <param name="mode">Mode of the transaction (read-only, read-write, ....)</param>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <param name="context">Existing parent context, if the transaction needs to be linked with a retry loop, or a parent transaction. If null, will create a new standalone context valid only for this transaction</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.IFdbDatabase.Contains(FoundationDB.Client.Slice)">
            <summary>Test if a key is inside the range of keys allowed to be read or writtent by the database</summary>
            <param name="key">Key to test</param>
            <returns>True if the key is inside the database keyspace, or inside the system keyspace.</returns>
            <remarks>Please note that this method does not test if the key *actually* exists in the database, only if the key is not ouside the allowed range of keys defined by <see cref="P:FoundationDB.Client.IFdbDatabase.GlobalSpace"/>.</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Name">
            <summary>Name of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Cluster">
            <summary>Cluster of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Cancellation">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
            <remarks>The token will be cancelled if the database instance is disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
            <remarks>Makes a copy of the subspace tuple, so you should not call this property a lot. Use any of the Partition(..) methods to create a subspace of the database</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.Directory">
            <summary>Directory partition of this database instance</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.IsReadOnly">
            <summary>If true, this database instance will only allow starting read-only transactions.</summary>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.DefaultTimeout">
            <summary>Default Timeout value (in milliseconds) for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="P:FoundationDB.Client.IFdbDatabase.DefaultRetryLimit">
            <summary>Default Retry Limit value for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_database">
            <summary>Inner database</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_readOnly">
            <summary>If true, forces the inner database to be read only</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_owner">
            <summary>If true, dispose the inner database when we get disposed</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_disposed">
            <summary>If true, we have been disposed</summary>
        </member>
        <member name="F:FoundationDB.Filters.FdbDatabaseFilter.m_directory">
            <summary>Wrapper for the inner db's Directory property</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Database">
            <summary>Database instance configured to read and write data from this partition</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Name">
            <summary>Name of the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Cluster">
            <summary>Cluster of the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Cancellation">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.Directory">
            <summary>Directory partition of this database instance</summary>
        </member>
        <member name="P:FoundationDB.Filters.FdbDatabaseFilter.IsReadOnly">
            <summary>If true, this database instance will only allow starting read-only transactions.</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbLoggedDatabase">
            <summary>Database filter that logs all the transactions</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedDatabase.OnCommitted">
            <summary>Handler called everytime a transaction is successfully committed</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbLoggingExtensions">
            <summary>Set of extension methods that add logging support on transactions</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String)">
            <summary>Annotate a logged transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String,System.Object)">
            <summary>Annotate a logged transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String,System.Object,System.Object)">
            <summary>Annotate a logged transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String,System.Object,System.Object,System.Object)">
            <summary>Annotate a logged transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbLoggingExtensions.Annotate(FoundationDB.Client.IFdbReadOnlyTransaction,System.String,System.Object[])">
            <summary>Annotate a logged transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Start(FoundationDB.Client.IFdbTransaction)">
            <summary>Marks the start of the transaction</summary>
            <param name="trans"></param>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Stop(FoundationDB.Client.IFdbTransaction)">
            <summary>Marks the end of the transaction</summary>
            <param name="trans"></param>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.AddOperation(FoundationDB.Filters.Logging.FdbTransactionLog.Command,System.Boolean)">
            <summary>Adds a new already completed command to the log</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.BeginOperation(FoundationDB.Filters.Logging.FdbTransactionLog.Command)">
            <summary>Start tracking the execution of a new command</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.EndOperation(FoundationDB.Filters.Logging.FdbTransactionLog.Command,System.Exception)">
            <summary>Mark the end of the execution of a command</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.GetCommandsReport">
            <summary>Generate an ASCII report with all the commands that were executed by the transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.GetTimingsReport(System.Boolean)">
            <summary>Generate a full ASCII report with the detailed timeline of all the commands that were executed by the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Id">
            <summary>Id of the logged transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Operations">
            <summary>Number of operations performed by the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Commands">
            <summary>List of all commands processed by the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StartTimestamp">
            <summary>Timestamp of the start of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StopTimestamp">
            <summary>Timestamp of the end of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StartedUtc">
            <summary>Timestamp (UTC) of the start of transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.StoppedUtc">
            <summary>Tmiestamp (UTC) of the end of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommittedUtc">
            <summary>Timestamp (UTC) of the last successfull commit of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommittedVersion">
            <summary>Committed version of the transaction (if a commit was successfull)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Step">
            <summary>Internal step counter of the transaction</summary>
            <remarks>This counter is used to detect sequential vs parallel commands</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ReadSize">
            <summary>Read size of the last commit attempt</summary>
            <remarks>This value only account for read commands in the last attempt</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.WriteSize">
            <summary>Write size of the last commit attempt</summary>
            <remarks>This value only account for write commands in the last attempt</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.CommitSize">
            <summary>Commit size of the last commit attempt</summary>
            <remarks>This value only account for write commands in the last attempt</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.TotalCommitSize">
            <summary>Total of the commit size of all attempts performed by this transaction</summary>
            <remarks>This value include the size of all previous retry attempts</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Completed">
            <summary>If true, the transaction has completed (either Commit() completed successfully or Dispose was called)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Attempts">
            <summary>Total number of attempts to commit this transaction</summary>
            <remarks>This value is increment on each call to Commit()</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.TotalDuration">
            <summary>Total duration of the transaction</summary>
            <remarks>If the transaction has not yet ended, returns the time elapsed since the start.</remarks>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbTransactionLog.Command">
            <summary>Base class of all types of operations performed on a transaction</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Command.GetArguments">
            <summary>Returns a formatted representation of the arguments, for logging purpose</summary>
        </member>
        <member name="M:FoundationDB.Filters.Logging.FdbTransactionLog.Command.GetResult">
            <summary>Returns a formatted representation of the results, for logging purpose</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Op">
            <summary>Return the type of operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Snapshot">
            <summary>If true, the operation was executed in Snapshot mode</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Step">
            <summary>Return the step number of this command</summary>
            <remarks>All commands with the same step number where started in parallel</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.EndStep">
            <summary>Return the end step number of this command</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.StartOffset">
            <summary>Number of ticks, since the start of the transaction, when the operation was started</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.EndOffset">
            <summary>Number of ticks, since the start of the transaction, when the operation completed (or null if it did not complete)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Error">
            <summary>Exception thrown by this operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ArgumentBytes">
            <summary>Total size (in bytes) of the arguments</summary>
            <remarks>For selectors, only include the size of the keys</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ResultBytes">
            <summary>Total size (in bytes) of the result, or null if this operation does not produce a result</summary>
            <remarks>Includes the keys and values for range reads</remarks>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ThreadId">
            <summary>Id of the thread that started the command</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Duration">
            <summary>Total duration of the command, or TimeSpan.Zero if the command is not yet completed</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.Mode">
            <summary>Return the mode of the operation (Read, Write, Metadata, Watch, ...)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command.ShortName">
            <summary>Returns the short version of the command name (up to two characters)</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbTransactionLog.Command`1">
            <summary>Base class of all types of operations performed on a transaction, that return a result</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.Command`1.Result">
            <summary>Optional result of the operation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetOptionCommand.Option">
            <summary>Option that is set on the transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetOptionCommand.IntValue">
            <summary>Integer value (if not null)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetOptionCommand.StringValue">
            <summary>String value (if not null)</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetCommand.Key">
            <summary>Key modified in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.SetCommand.Value">
            <summary>Value written to the key</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearCommand.Key">
            <summary>Key cleared from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearRangeCommand.Begin">
            <summary>Begin of the range cleared</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.ClearRangeCommand.End">
            <summary>End of the range cleared</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Mutation">
            <summary>Type of mutation performed on the key</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Key">
            <summary>Key modified in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AtomicCommand.Param">
            <summary>Parameter depending of the type of mutation</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.Type">
            <summary>Type of conflict</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.Begin">
            <summary>Begin of the conflict range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.AddConflictRangeCommand.End">
            <summary>End of the conflict range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetCommand.Key">
            <summary>Key read from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetKeyCommand.Selector">
            <summary>Selector to a key in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetValuesCommand.Keys">
            <summary>List of keys read from the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetKeysCommand.Selectors">
            <summary>List of selectors looked up in the database</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Begin">
            <summary>Selector to the start of the range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.End">
            <summary>Selector to the end of the range</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Options">
            <summary>Options of the range read</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbTransactionLog.GetRangeCommand.Iteration">
            <summary>Iteration number</summary>
        </member>
        <member name="T:FoundationDB.Filters.Logging.FdbLoggedTransaction">
            <summary>Transaction filter that logs and measure all operations performed on the underlying transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedTransaction.Log">
            <summary>Log of all operations performed on this transaction</summary>
        </member>
        <member name="P:FoundationDB.Filters.Logging.FdbLoggedTransaction.Committed">
            <summary>Handler that will be called when this transaction commits successfully</summary>
        </member>
        <member name="T:FoundationDB.Filters.PrefixRewriterTransaction">
            <summary>[PROOF OF CONCEPT, DO NOT USE YET!] Transaction filter that automatically appends/remove a fixed prefix to all keys</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFuture">
            <summary>Helper class to create FDBFutures</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.FromHandle``1(FoundationDB.Client.Native.FutureHandle,System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Create a new FdbFuture&lt;<typeparamref name="T"/>&gt; from an FDBFuture* pointer</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handle">FDBFuture* pointer</param>
            <param name="selector">Func that will be called to get the result once the future completes (and did not fail)</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Object that tracks the execution of the FDBFuture handle</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.FromHandleArray``1(FoundationDB.Client.Native.FutureHandle[],System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Create a new FdbFutureArray&lt;<typeparamref name="T"/>&gt; from an array of FDBFuture* pointers</summary>
            <typeparam name="T">Type of the items of the arrayreturn by the task</typeparam>
            <param name="handles">Array of FDBFuture* pointers</param>
            <param name="selector">Func that will be called for each future that complete (and did not fail)</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Object that tracks the execution of all the FDBFuture handles</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.CreateTaskFromHandle``1(FoundationDB.Client.Native.FutureHandle,System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Wrap a FdbFuture&lt;<typeparamref name="T"/>&gt; handle into a Task&lt;<typeparamref name="T"/>&gt;</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handle">FDBFuture* pointer</param>
            <param name="continuation">Lambda that will be called once the future completes sucessfully, to extract the result from the future handle.</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Task that will either return the result of the continuation lambda, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture.CreateTaskFromHandleArray``1(FoundationDB.Client.Native.FutureHandle[],System.Func{FoundationDB.Client.Native.FutureHandle,``0},System.Threading.CancellationToken)">
            <summary>Wrap multiple FdbFuture&lt;<typeparamref name="T"/>&gt; handles into a single Task&lt;<typeparamref name="T"/>[]&gt;</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="handles">Array of FDBFuture* pointers</param>
            <param name="continuation">Lambda that will be called once for each future that completes sucessfully, to extract the result from the future handle.</param>
            <param name="cancellationToken">Optional cancellation token that can be used to cancel the future</param>
            <returns>Task that will either return all the results of the continuation lambdas, or an exception</returns>
            <remarks>If at least one future fails, the whole task will fail.</remarks>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.COMPLETED">
            <summary>The future has completed (either success or failure)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.HAS_POSTED_ASYNC_COMPLETION">
            <summary>A completion/failure/cancellation has been posted on the thread pool</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.CANCELLED">
            <summary>The future has been cancelled from an external source (manually, or via then CancellationTokeb)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.MEMORY_RELEASED">
            <summary>The resources allocated by this future have been released</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.READY">
            <summary>The future has been constructed, and is listening for the callbacks</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture.Flags.DISPOSED">
            <summary>Dispose has been called</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFuture`1">
            <summary>Base class for all FDBFuture wrappers</summary>
            <typeparam name="T">Type of the Task's result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_flags">
            <summary>Flags of the future (bit field of FLAG_xxx values)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_key">
            <summary>Future key in the callback dictionary</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.m_ctr">
            <summary>Optionnal registration on the parent Cancellation Token</summary>
            <remarks>Is only valid if FLAG_HAS_CTR is set</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.CloseHandles">
            <summary>Close all the handles managed by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.CancelHandles">
            <summary>Cancel all the handles managed by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.ReleaseMemory">
            <summary>Release all memory allocated by this future</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetResult(`0,System.Boolean)">
            <summary>Set the result of this future</summary>
            <param name="result">Result of the future</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetFaulted(System.Exception,System.Boolean)">
            <summary>Fault the future's Task</summary>
            <param name="e">Error that will be the result of the task</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetFaulted(System.Collections.Generic.IEnumerable{System.Exception},System.Boolean)">
            <summary>Fault the future's Task</summary>
            <param name="errors">Error that will be the result of the task</param>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.SetCanceled(System.Boolean)">
            <summary>Cancel the future's Task</summary>
            <param name="fromCallback">If true, called from the network thread callback and will defer the operation on the ThreadPool. If false, may run the continuations inline.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostCompletionOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},`0)">
            <summary>Defer setting the result of a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostFailureOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},System.Exception)">
            <summary>Defer failing a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostFailureOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0},System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>Defer failing a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.PostCancellationOnThreadPool(System.Threading.Tasks.TaskCompletionSource{`0})">
            <summary>Defer cancelling a TaskCompletionSource on the ThreadPool</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.s_futures">
            <summary>List of all pending futures that have not yet completed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFuture`1.s_futureCounter">
            <summary>Internal counter to generated a unique parameter value for each futures</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.RegisterCallback(FoundationDB.Client.FdbFuture{`0})">
            <summary>Register a future in the callback context and return the corresponding callback parameter</summary>
            <param name="future">Future instance</param>
            <returns>Parameter that can be passed to FutureSetCallback and that uniquely identify this future.</returns>
            <remarks>The caller MUST call ClearCallbackHandler to ensure that the future instance is removed from the list</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.UnregisterCallback(FoundationDB.Client.FdbFuture{`0})">
            <summary>Remove a future from the callback handler dictionary</summary>
            <param name="future">Future that has just completed, or is being destroyed</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.GetAwaiter">
            <summary>Make the Future awaitable</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.Cancel">
            <summary>Try to abort the task (if it is still running)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFuture`1.Clear">
            <summary>Free memory allocated by this future after it has completed.</summary>
            <remarks>This method provides no benefit to most application code, and should only be called when attempting to write thread-safe custom layers.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbFuture`1.IsReady">
            <summary>Return true if the future has completed (successfully or not)</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFutureArray`1">
            <summary>FDBFuture[] wrapper</summary>
            <typeparam name="T">Type of result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_handles">
            <summary>Value of the 'FDBFuture*'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_pending">
            <summary>Counter of callbacks that still need to fire.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.m_resultSelector">
            <summary>Lambda used to extract the result of this FDBFuture</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureArray`1.CallbackHandler">
            <summary>Cached delegate of the future completion callback handler</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureArray`1.FutureCompletionCallback(System.IntPtr,System.IntPtr)">
            <summary>Handler called when a FDBFuture becomes ready</summary>
            <param name="futureHandle">Handle on the future that became ready</param>
            <param name="parameter">Paramter to the callback (unused)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureArray`1.HandleCompletion(System.Boolean)">
            <summary>Update the Task with the state of a ready Future</summary>
            <param name="fromCallback">If true, the method is called from the network thread and must defer the continuations from the Thread Pool</param>
            <returns>True if we got a result, or false in case of error (or invalid state)</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbWatch">
            <summary>Watch that triggers when the watched key is changed in the database</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.GetAwaiter">
            <summary>Returns an awaiter for the Watch</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.Cancel">
            <summary>Cancel the watch. It will immediately stop monitoring the key. Has no effect if the watch has already fired</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbWatch.Dispose">
            <summary>Dispose the resources allocated by the watch.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Key">
            <summary>Key that is being watched</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Value">
            <summary>Original value of the key, at the time the watch was created (optional)</summary>
            <remarks>This property will return Slice.Nil if the original value was not known at the creation of this Watch instance.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.IsAlive">
            <summary>Returns true if the watch is still active, or false if it fired or was cancelled</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.HasChanged">
            <summary>Returns true if the watch has fired signaling that the key may have changed in the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbWatch.Task">
            <summary>Task that will complete when the watch fires, or is cancelled. It will return the watched key, or an exception.</summary>
        </member>
        <member name="T:FoundationDB.Client.Fdb">
            <summary>FoundationDB binding</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxKeySize">
            <summary>Keys cannot exceed 10,000 bytes</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxValueSize">
            <summary>Values cannot exceed 100,000 bytes</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MaxTransactionWriteSize">
            <summary>Maximum size of total written keys and values by a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.MinimumApiVersion">
            <summary>Minimum API version supported by this binding</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.s_started">
            <summary>Flag indicating if FDB has been initialized or not</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.s_apiVersion">
            <summary>Currently selected API version</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.s_appDomainUnloadHandler">
            <summary>Event handler called when the AppDomain gets unloaded</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.GetMinApiVersion">
            <summary>Returns the minimum API version currently supported by this binding</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.GetMaxApiVersion">
            <summary>Returns the maximum API version currently supported by this binding</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.UseApiVersion(System.Int32)">
            <summary>Sets the desired API version of the binding</summary>
            <remarks>The version can only be set before calling <see cref="M:FoundationDB.Client.Fdb.Start"/> or any method that indirectly calls it.</remarks>
            <exception cref="T:System.InvalidOperationException">When attempting to change the API version after the binding has been started.</exception>
            <exception cref="T:System.ArgumentException">When attempting to set a negative version, or a version that is either less or greater than the minimum and maximum supported versions.</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Success(FoundationDB.Client.FdbError)">
            <summary>Returns true if the error code represents a success</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Failed(FoundationDB.Client.FdbError)">
            <summary>Returns true if the error code represents a failure</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.DieOnError(FoundationDB.Client.FdbError)">
            <summary>Throws an exception if the code represents a failure</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.GetErrorMessage(FoundationDB.Client.FdbError)">
            <summary>Return the error message matching the specified error code</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.MapToException(FoundationDB.Client.FdbError)">
            <summary>Maps an error code into an Exception (to be throwned)</summary>
            <param name="code"></param>
            <returns>Exception object corresponding to the error code, or null if the code is not an error</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.StartEventLoop">
            <summary>Starts the thread running the FDB event loop</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.StopEventLoop">
            <summary>Stops the thread running the FDB event loop</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EventLoop">
            <summary>Entry point for the Network Thread</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EnsureNotOnNetworkThread(System.String)">
            <summary>Throws if the current thread is the Network Thread.</summary>
            <remarks>Should be used to ensure that we do not execute tasks continuations from the network thread, to avoid dead-locks.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.CreateClusterAsync(System.Threading.CancellationToken)">
            <summary>Opens a connection to an existing FoundationDB cluster using the default cluster file</summary>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbCluster, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.CreateClusterAsync(System.String,System.Threading.CancellationToken)">
            <summary>Opens a connection to an existing FDB Cluster</summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbCluster, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.Threading.CancellationToken)">
            <summary>
            Open the "DB" database on the cluster specified by the default cluster file
            </summary>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>
            Open the "DB" database on the cluster specified by the default cluster file, and with the specified global space
            </summary>
            <param name="globalSpace">Global subspace used as a prefix for all keys and layers</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.String,System.String,System.Threading.CancellationToken)">
            <summary>
            Open a database on the specified cluster
            </summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="dbName">Name of the database, or "DB" if not specified.</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <remarks>As of 1.0, the only supported database name is "DB"</remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="dbName"/> is anything other than "DB"</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.OpenAsync(System.String,System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Open a database on the specified cluster
            </summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="dbName">Name of the database. Must be 'DB'</param>
            <param name="globalSpace">Global subspace used as a prefix for all keys and layers</param>
            <param name="readOnly">If true, the database instance will only allow read operations</param>
            <param name="cancellationToken">Token used to abort the operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <remarks>As of 1.0, the only supported database name is 'DB'</remarks>
            <exception cref="T:System.InvalidOperationException">If <paramref name="dbName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
        </member>
        <member name="M:FoundationDB.Client.Fdb.EnsureIsStarted">
            <summary>Ensure that we have loaded the C API library, and that the Network Thread has been started</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Start">
            <summary>Select the correct API version, and start the Network Thread</summary>
            <remarks>If you need a specific API version level, it must be defined by calling <see cref="M:FoundationDB.Client.Fdb.UseApiVersion(System.Int32)"/> before calling this method, otherwise the default API version will be selected.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Stop">
            <summary>Stop the Network Thread</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.ApiVersion">
            <summary>Returns the currently selected API version</summary>
            <remarks>Unless explicitely selected by calling <see cref="M:FoundationDB.Client.Fdb.UseApiVersion(System.Int32)"/> before, the default API version level will be returned</remarks>
        </member>
        <member name="P:FoundationDB.Client.Fdb.IsNetworkRunning">
            <summary>Returns true if the Network thread start is executing, otherwise falsse</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.IsNetworkThread">
            <summary>Returns 'true' if we are currently running on the Event Loop thread</summary>
        </member>
        <member name="T:FoundationDB.Client.Fdb.System">
            <summary>Helper class for reading from the reserved System subspace</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.MaxValue">
            <summary>"\xFF\xFF"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.MinValue">
            <summary>"\xFF\x00"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.BackupDataFormat">
            <summary>"\xFF/backupDataFormat"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.ConfigPrefix">
            <summary>"\xFF/conf/"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.Coordinators">
            <summary>"\xFF/coordinators"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.GlobalsPrefix">
            <summary>"\xFF/globals/"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.InitId">
            <summary>"\xFF/init_id"</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.KeyServers">
            <summary>"\xFF/keyServer/(key_boundary)" => (..., node_id, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.ServerKeys">
            <summary>"\xFF/serverKeys/(node_id)/(key_boundary)" => ('' | '1')</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.ServerList">
            <summary>"\xFF/serverList/(node_id)" => (..., node_id, machine_id, datacenter_id, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.System.WorkersPrefix">
            <summary>"\xFF/workers/(ip:port)/..." => datacenter + machine + mclass</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetCoordinatorsAsync(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Returns an object describing the list of the current coordinators for the cluster</summary>
            <param name="db">Database to use for the operation</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <remarks>Since the list of coordinators may change at anytime, the results may already be obsolete once this method completes!</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetConfigParameterAsync(FoundationDB.Client.IFdbDatabase,System.String,System.Threading.CancellationToken)">
            <summary>Return the value of a configuration parameter (located under '\xFF/conf/')</summary>
            <param name="db">Database to use for the operation</param>
            <param name="name">Name of the configuration key (ex: "storage_engine")</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Value of '\xFF/conf/storage_engine'</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.ConfigKey(System.String)">
            <summary>Return the corresponding key for a config attribute</summary>
            <param name="name">"foo"</param>
            <returns>"\xFF/conf/foo"</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GlobalsKey(System.String)">
            <summary>Return the corresponding key for a global attribute</summary>
            <param name="name">"foo"</param>
            <returns>"\xFF/globals/foo"</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.WorkersKey(System.String,System.String)">
            <summary>Return the corresponding key for a global attribute</summary>
            <param name="id">"ABC123"</param>
            <param name="name">"foo"</param>
            <returns>"\xFF/workers/ABC123/foo"</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetStorageEngineModeAsync(FoundationDB.Client.IFdbDatabase,System.Threading.CancellationToken)">
            <summary>Returns the current storage engine mode of the cluster</summary>
            <param name="db">Database to use for the operation</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Returns either "memory" or "ssd"</returns>
            <remarks>Will return a string starting with "unknown" if the storage engine mode is not recognized</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetBoundaryKeysAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Returns a list of keys k such that <paramref name="beginInclusive"/> &lt;= k &lt; <paramref name="endExclusive"/> and k is located at the start of a contiguous range stored on a single server</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="beginInclusive">First key (inclusive) of the range to inspect</param>
            <param name="endExclusive">End key (exclusive) of the range to inspect</param>
            <returns>List of keys that mark the start of a new chunk</returns>
            <remarks>This method is not transactional. It will return an answer no older than the Transaction object it is passed, but the returned boundaries are an estimate and may not represent the exact boundary locations at any database version.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetBoundaryKeysAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Returns a list of keys k such that <paramref name="beginInclusive"/> &lt;= k &lt; <paramref name="endExclusive"/> and k is located at the start of a contiguous range stored on a single server</summary>
            <param name="db">Database to use for the operation</param>
            <param name="beginInclusive">First key (inclusive) of the range to inspect</param>
            <param name="endExclusive">End key (exclusive) of the range to inspect</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>List of keys that mark the start of a new chunk</returns>
            <remarks>This method is not transactional. It will return an answer no older than the Database object it is passed, but the returned boundaries are an estimate and may not represent the exact boundary locations at any database version.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetChunksAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.FdbKeyRange,System.Threading.CancellationToken)">
            <summary>Split a range of keys into smaller chunks where each chunk represents a contiguous range stored on a single server</summary>
            <param name="db">Database to use for the operation</param>
            <param name="range">Range of keys to split up into smaller chunks</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>List of one or more chunks that constitutes the range, where each chunk represents a contiguous range stored on a single server. If the list contains a single range, that means that the range is small enough to fit inside a single chunk.</returns>
            <remarks>This method is not transactional. It will return an answer no older than the Database object it is passed, but the returned ranges are an estimate and may not represent the exact boundary locations at any database version.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.GetChunksAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Split a range of keys into chunks representing a contiguous range stored on a single server</summary>
            <param name="db">Database to use for the operation</param>
            <param name="beginInclusive">First key (inclusive) of the range to inspect</param>
            <param name="endExclusive">End key (exclusive) of the range to inspect</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>List of one or more chunks that constitutes the range, where each chunk represents a contiguous range stored on a single server. If the list contains a single range, that means that the range is small enough to fit inside a single chunk.</returns>
            <remarks>This method is not transactional. It will return an answer no older than the Database object it is passed, but the returned ranges are an estimate and may not represent the exact boundary locations at any database version.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.EstimateCountAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.FdbKeyRange,System.Threading.CancellationToken)">
            <summary>Estimate the number of keys in the specified range.</summary>
            <param name="db">Database used for the operation</param>
            <param name="range">Range defining the keys to count</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Number of keys k such that range.Begin &lt;= k &gt; range.End</returns>
            <remarks>If the range contains a large of number keys, the operation may need more than one transaction to complete, meaning that the number will not be transactionally accurate.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.System.EstimateCountAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Estimate the number of keys in the specified range.</summary>
            <param name="db">Database used for the operation</param>
            <param name="beginInclusive">Key defining the beginning of the range</param>
            <param name="endExclusive">Key defining the end of the range</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Number of keys k such that <paramref name="beginInclusive"/> &lt;= k &gt; <paramref name="endExclusive"/></returns>
            <remarks>If the range contains a large of number keys, the operation may need more than one transaction to complete, meaning that the number will not be transactionally accurate.</remarks>
        </member>
        <member name="T:FoundationDB.Client.Fdb.Bulk">
            <summary>Helper class for bulk operations</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.WriteAsync(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{FoundationDB.Client.Slice,FoundationDB.Client.Slice}},System.Threading.CancellationToken)">
            <summary>Writes a potentially large sequence of key/value pairs into the database, by using as many transactions as necessary, and automatically scaling the size of each batch.</summary>
            <param name="db">Database used for the operation</param>
            <param name="data">Sequence of key/value pairs</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Total number of values inserted in the database</returns>
            <remarks>In case of a non-retryable error, some of the keys may remain in the database. Other transactions running at the same time may observe only a fraction of the keys until the operation completes.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.WriteAsync(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{FoundationDB.Client.Slice,FoundationDB.Client.Slice}},System.IProgress{System.Int64},System.Threading.CancellationToken)">
            <summary>Writes a potentially large sequence of key/value pairs into the database, by using as many transactions as necessary, and automatically scaling the size of each batch.</summary>
            <param name="db">Database used for the operation</param>
            <param name="data">Sequence of key/value pairs</param>
            <param name="progress">Notify of the progress on this instance (or null). Since progress notification is async, this object could be called even after the bulk operation has completed!</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Total number of values inserted in the database</returns>
            <remarks>In case of a non-retryable error, some of the keys may remain in the database. Other transactions running at the same time may observe only a fraction of the keys until the operation completes.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.InsertAsync``1(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Action{``0,FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Inserts a potentially large sequence of items into the database, by using as many transactions as necessary, and automatically retrying if needed.</summary>
            <typeparam name="T">Type of the items in the <paramref name="source"/> sequence</typeparam>
            <param name="db">Database used for the operation</param>
            <param name="source">Sequence of items to be processed</param>
            <param name="handler">Lambda called at least once for each item in the source. The method may not have any side effect outside of the passed transaction.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Number of items that have been inserted</returns>
            <remarks>In case of a non-retryable error, some of the items may remain in the database. Other transactions running at the same time may observe only a fraction of the items until the operation completes.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.InsertAsync``1(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``0,FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Inserts a potentially large sequence of items into the database, by using as many transactions as necessary, and automatically retrying if needed.</summary>
            <typeparam name="T">Type of the items in the <paramref name="source"/> sequence</typeparam>
            <param name="db">Database used for the operation</param>
            <param name="source">Sequence of items to be processed</param>
            <param name="handler">Lambda called at least once for each item in the source. The method may not have any side effect outside of the passed transaction.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Number of items that have been inserted</returns>
            <remarks>In case of a non-retryable error, some of the items may remain in the database. Other transactions running at the same time may observe only a fraction of the items until the operation completes.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.RunWriteOperationAsync``1(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Delegate,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Runs a long duration bulk write</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.RetryChunk``1(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.List{``0},System.Int32,System.Int32,System.Func{``0,FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{``0,FoundationDB.Client.IFdbTransaction})">
            <summary>Retry commiting a segment of a batch, splitting it in sub-segments as needed</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.ForEachAsync``2(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext,``1,System.Threading.Tasks.Task{``1}},System.Action{``1},System.Threading.CancellationToken)">
            <summary>Execute a potentially long read-only operation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <typeparam name="TLocal">Type of the local immutable state that is flowed accross all batch operations</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="localInit">Lambda function that is called once, and returns the initial state that will be passed to the first batch</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="localFinally">Lambda function that will be called after the last batch, and will be passed the last known state.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.ForEachAsync``2(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext,``1,``1},System.Action{``1},System.Threading.CancellationToken)">
            <summary>Execute a potentially long read-only operation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <typeparam name="TLocal">Type of the local immutable state that is flowed accross all batch operations</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="localInit">Lambda function that is called once, and returns the initial state that will be passed to the first batch</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="localFinally">Lambda function that will be called after the last batch, and will be passed the last known state.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.ForEachAsync``1(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Execute a potentially long read-only operation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.ForEachAsync``1(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Action{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext},System.Threading.CancellationToken)">
            <summary>Execute a potentially long read-only operation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.AggregateAsync``2(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext,``1,System.Threading.Tasks.Task{``1}},System.Threading.CancellationToken)">
            <summary>Execute a potentially long aggregation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <typeparam name="TAggregate">Type of the local immutable aggregate that is flowed accross all batch operations</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="localInit">Lambda function that is called once, and returns the initial state that will be passed to the first batch</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.AggregateAsync``3(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0[],FoundationDB.Client.Fdb.Bulk.BatchOperationContext,``1,System.Threading.Tasks.Task{``1}},System.Func{``1,``2},System.Threading.CancellationToken)">
            <summary>Execute a potentially long aggregation on batches of elements from a source sequence, using as many transactions as necessary, and automatically scaling the size of each batch to maximize the throughput.</summary>
            <typeparam name="TSource">Type of elements in the source sequence</typeparam>
            <typeparam name="TAggregate">Type of the local immutable aggregate that is flowed accross all batch operations</typeparam>
            <typeparam name="TResult">Type of the result of the operation</typeparam>
            <param name="db">Source database</param>
            <param name="source">Source sequence that will be split into batch. The size of each batch will scale up and down automatically depending on the speed of execution</param>
            <param name="init">Lambda function that is called once, and returns the initial state that will be passed to the first batch</param>
            <param name="body">Retryable lambda function that receives a batch of elements from the source sequence, the current context, and the previous state. If the transaction expires while this lambda function is running, it will be automatically retried with a new transaction, and a smaller batch.</param>
            <param name="transform">Lambda function called with the aggregate returned by the last batch, and which will compute the final result of the operation</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task that completes when all the elements of <paramref name="source"/> have been processed, a non-retryable error occurs, or <paramref name="cancellationToken"/> is triggered</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.RunBatchedReadOperationAsync``3(FoundationDB.Client.IFdbDatabase,System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Delegate,System.Delegate,System.Int32,System.Threading.CancellationToken)">
            <summary>Runs a long duration bulk read</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.FillNextBatch``1(System.Collections.Generic.IEnumerator{``0},System.Collections.Generic.List{``0},System.Int32)">
            <summary>Tries to fill a batch with items from the source</summary>
            <typeparam name="T">Type of source items</typeparam>
            <param name="iterator">Source iterator</param>
            <param name="batch">Batch where the read items will be appended.</param>
            <param name="size">Maximum capacity of the batch</param>
            <returns>Number items added to the batch, or 0 if it was already full</returns>
        </member>
        <member name="T:FoundationDB.Client.Fdb.Bulk.BatchOperationContext">
            <summary>Context for a long running batched read operation</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Stop">
            <summary>If called, will stop immediately after processing this batch, even if the source sequence contains more elements</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Transaction">
            <summary>Transaction corresponding to the current generation</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Position">
            <summary>Offset of the current batch from the start of the source sequence</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Generation">
            <summary>Generation number of the transaction (starting from 0 for the initial transaction)</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Step">
            <summary>Current batch size target</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.TotalTimer">
            <summary>Global timer, from the start of the bulk operation</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.GenerationTimer">
            <summary>Timer started at the start of each transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Cooldown">
            <summary>Cooldown timer used for scaling up and down the step size</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.IsTransactional">
            <summary>Returns true if all values processed up to this point used the same transaction, or false if more than one transaction was used.</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Failed">
            <summary>Returns true if at least one unretryable exception happened during the process of one batch</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Bulk.BatchOperationContext.Abort">
            <summary>Gets or sets the abort flag</summary>
        </member>
        <member name="T:FoundationDB.Client.Fdb.Options">
            <summary>Global settings for the FoundationDB binding</summary>
        </member>
        <member name="F:FoundationDB.Client.Fdb.Options.NativeLibPath">
            <summary>Custom path from where to load the native C API library. If null, let the CLR find the dll. If String.Empty let Win32's LoadLibrary find the correct dll, else use the specified path to load the library</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.DisableNativeLibraryPreloading">
            <summary>Disable preloading of the native C API library. The CLR will handle the binding of the library.</summary>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.EnableNativeLibraryPreloading">
            <summary>Enable automatic preloading of the native C API library. The operating system will handle the binding of the library</summary>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetNativeLibPath(System.String)">
            <summary>Preload the native C API library from a specifc path (relative of absolute) where the fdb_c.dll library is located</summary>
            <example>SetNativeLibPath(@".\libs\x64") will attempt to load ".\libs\x64\fdb_c.dll"</example>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="F:FoundationDB.Client.Fdb.Options.TracePath">
            <summary>Default path to the network thread tracing file</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTracePath(System.String)">
            <summary>Sets the custom path where the logs will be stored</summary>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTLSPlugin(System.String)">
            <summary>Set the file path or linker-resolved name of the custom TLS plugin to load. </summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTLSCertificate(FoundationDB.Client.Slice)">
            <summary>Sets the path to the root certificate and public key for TLS connections</summary>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTLSCertificate(System.String)">
            <summary>Sets the path to the root certificate and public key for TLS connections</summary>
            <remarks>This *must* be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTLSPrivateKey(FoundationDB.Client.Slice)">
            <summary>Sets the path to the private key for TLS connections</summary>
            <remarks>This must be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTLSPrivateKey(System.String)">
            <summary>Sets the path to the private key for TLS connections</summary>
            <remarks>This must be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.SetTlsVerificationPattern(FoundationDB.Client.Slice)">
            <summary>Sets the pattern with wich to verify certificates of TLS peers</summary>
            <remarks>This must be called before the start of the network thread, otherwise it won't have any effects.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.UseTLS(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.String)">
            <summary>Use TLS to secure the connections to the cluster</summary>
            <param name="certificateBytes">Content of the root certificate and public key</param>
            <param name="privateKeyBytes">Content of the private key</param>
            <param name="verificationPattern">Verification with which to verify certificates of TLS peers</param>
            <param name="plugin">Optional file path or linker-resolved name of the custom TLS plugin to load</param>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Options.UseTLS(System.String,System.String,FoundationDB.Client.Slice,System.String)">
            <summary>Use TLS to secure the connections to the cluster</summary>
            <param name="certificatePath">Path to the root certificate and public key</param>
            <param name="privateKeyPath">Path to the private key</param>
            <param name="verificationPattern">Verification with which to verify certificates of TLS peers</param>
            <param name="plugin">Optional file path or linker-resolved name of the custom TLS plugin to load</param>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSPlugin">
            <summary>File path or linker-resolved name of the custom TLS plugin to load.</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSCertificateBytes">
            <summary>Content of the TLS root and client certificates used for TLS connections (none by default)</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSCertificatePath">
            <summary>Path to the TLS root and client certificates used for TLS connections (none by default)</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSPrivateKeyBytes">
            <summary>Path to the Private Key used for TLS connections (none by default)</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSPrivateKeyPath">
            <summary>Path to the Private Key used for TLS connections (none by default)</summary>
        </member>
        <member name="P:FoundationDB.Client.Fdb.Options.TLSVerificationPattern">
            <summary>Pattern used to verifiy certificates of TLS peers (none by default)</summary>
        </member>
        <member name="T:FoundationDB.Client.Fdb.Directory">
            <summary>Static helper class to open named partitions</summary>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Directory.OpenNamedPartitionAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Open a named partition of the default cluster</summary>
            <param name="path">Path of the named partition to open</param>
            <param name="cancellationToken">Token used to cancel this operation</param>
            <returns>Returns a new database instance that will only be able to read and write inside the specified partition. If the partition does not exist, it will be automatically created</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Directory.OpenNamedPartitionAsync(System.String,System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Threading.CancellationToken)">
            <summary>Open a named partition of a specific cluster</summary>
            <param name="clusterFile">Path to the 'fdb.cluster' file to use, or null for the default cluster file</param>
            <param name="dbName">Name of the database, or "DB" if not specified.</param>
            <param name="path">Path of the named partition to open</param>
            <param name="readOnly">If true, the database instance will only allow read operations</param>
            <param name="cancellationToken">Token used to cancel this operation</param>
            <returns>Returns a new database instance that will only be able to read and write inside the specified partition. If the partition does not exist, it will be automatically created</returns>
        </member>
        <member name="M:FoundationDB.Client.Fdb.Directory.BrowseAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Layers.Directories.IFdbDirectory,System.Threading.CancellationToken)">
            <summary>List and open the sub-directories of the given directory</summary>
            <param name="db">Database used for the operation</param>
            <param name="parent">Parent directory</param>
            <param name="cancellationToken">Token used to cancel this operation</param>
            <returns>Dictionary of all the sub directories of the <paramref name="parent"/> directory.</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbConflictRangeType">
            <summary>Defines a type of conflict artificially added to a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbConflictRangeType.Read">
            <summary>
            Used to add a read conflict range.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbConflictRangeType.Write">
            <summary>
            Used to add a write conflict range.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbMutationType">
            <summary>Defines a type of mutation applied to a key</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Invalid">
            <summary>
            Invalid
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Add">
            <summary>
            Performs an addition of little-endian integers. If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``. The integers to be added must be stored in a little-endian representation.  They can be signed in two's complement representation or unsigned. You can add to an integer at a known offset in the value by prepending the appropriate number of zero bytes to ``param`` and padding with zero bytes to match the length of the value. However, this offset technique requires that you know the addition will not cause the integer field within the value to overflow.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.BitAnd">
            <summary>
            Performs a bitwise ``and`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.BitOr">
            <summary>
            Performs a bitwise ``or`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.BitXor">
            <summary>
            Performs a bitwise ``xor`` operation.  If the existing value in the database is not present or shorter than ``param``, it is first extended to the length of ``param`` with zero bytes.  If ``param`` is shorter than the existing value in the database, the existing value is truncated to match the length of ``param``.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.And">
            <summary>Deprecated name of <see cref="F:FoundationDB.Client.FdbMutationType.BitAnd"/></summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Or">
            <summary>Deprecated name of <see cref="F:FoundationDB.Client.FdbMutationType.BitAnd"/></summary>
        </member>
        <member name="F:FoundationDB.Client.FdbMutationType.Xor">
            <summary>Deprecated name of <see cref="F:FoundationDB.Client.FdbMutationType.BitAnd"/></summary>
        </member>
        <member name="T:FoundationDB.Client.FdbTransaction">
            <summary>Wraps an FDB_TRANSACTION handle</summary>
            <summary>FoundationDB transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_snapshotted">
            <summary>Snapshot version of this transaction (lazily allocated)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_state">
            <summary>Current state of the transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_database">
            <summary>Owner database that created this instance</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_context">
            <summary>Context of the transaction when running inside a retry loop, or other custom scenario</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_id">
            <summary>Unique internal id for this transaction (for debugging purpose)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_readOnly">
            <summary>True if the transaction has been opened in read-only mode</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_timeout">
            <summary>Timeout (in ms) of this transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_retryLimit">
            <summary>Retry Limit of this transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_cts">
            <summary>Cancelletation source specific to this instance.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransaction.m_cancellation">
            <summary>CancellationToken that should be used for all async operations executing inside this transaction</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption)">
            <summary>Set an option on this transaction that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.String)">
            <summary>Set an option on this transaction that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetOption(FoundationDB.Client.FdbTransactionOption,System.Int64)">
            <summary>Set an option on this transaction that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetReadVersionAsync">
            <summary>Returns this transaction snapshot read version.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetCommittedVersion">
            <summary>Retrieves the database version number at which a given transaction was committed.</summary>
            <returns>Version number, or -1 if this transaction was not committed (or did nothing)</returns>
            <remarks>The value return by this method is undefined if Commit has not been called</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.SetReadVersion(System.Int64)">
            <summary>
            Sets the snapshot read version used by a transaction. This is not needed in simple cases.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetAsync(FoundationDB.Client.Slice)">
            <summary>
            Reads a value from the database snapshot represented by transaction.
            </summary>
            <param name="key">Key to be looked up in the database</param>
            <returns>Task that will return the value of the key if it is found, Slice.Nil if the key does not exist, or an exception</returns>
            <exception cref="T:System.ArgumentException">If the <paramref name="key"/> is null</exception>
            <exception cref="T:System.OperationCanceledException">If the cancellation token is already triggered</exception>
            <exception cref="T:System.ObjectDisposedException">If the transaction has already been completed</exception>
            <exception cref="T:System.InvalidOperationException">If the operation method is called from the Network Thread</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetValuesAsync(FoundationDB.Client.Slice[])">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetRangeAsync(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by limit, target_bytes, or mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, StreamingMode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetRange(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbRangeOptions)">
            <summary>
            Create a new range query that will read all key-value pairs in the database snapshot represented by the transaction
            </summary>
            <param name="beginInclusive">key selector defining the beginning of the range</param>
            <param name="endExclusive">key selector defining the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <returns>Range query that, once executed, will return all the key-value pairs matching the providing selector pair</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetKeyAsync(FoundationDB.Client.FdbKeySelector)">
            <summary>Resolves a key selector against the keys in the database snapshot represented by transaction.</summary>
            <param name="selector">Key selector to resolve</param>
            <returns>Task that will return the key matching the selector, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetKeysAsync(FoundationDB.Client.FdbKeySelector[])">
            <summary>
            Resolves several key selectors against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selectors">Key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Set(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to change the given key to have the given value. If the given key was not previously present in the database it is inserted.
            The modification affects the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Atomic(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbMutationType)">
            <summary>
            Modify the database snapshot represented by this transaction to perform the operation indicated by <paramref name="mutation"/> with operand <paramref name="param"/> to the value stored by the given key.
            </summary>
            <param name="key">Name of the key whose value is to be mutated.</param>
            <param name="param">Parameter with which the atomic operation will mutate the value associated with key_name.</param>
            <param name="mutation">Type of mutation that should be performed on the key</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Clear(FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Name of the key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.ClearRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Modify the database snapshot represented by transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="beginKeyInclusive">Name of the key specifying the beginning of the range to clear.</param>
            <param name="endKeyExclusive">Name of the key specifying the end of the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.AddConflictRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="beginKeyInclusive">Key specifying the beginning of the conflict range. The key is included</param>
            <param name="endKeyExclusive">Key specifying the end of the conflict range. The key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.GetAddressesForKeyAsync(FoundationDB.Client.Slice)">
            <summary>
            Returns a list of public network addresses as strings, one for each of the storage servers responsible for storing <paramref name="key"/> and its associated value
            </summary>
            <param name="key">Name of the key whose location is to be queried.</param>
            <returns>Task that will return an array of strings, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.CommitAsync">
            <summary>
            Attempts to commit the sets and clears previously applied to the database snapshot represented by this transaction to the actual database. 
            The commit may or may not succeed – in particular, if a conflicting transaction previously committed, then the commit must fail in order to preserve transactional isolation. 
            If the commit does succeed, the transaction is durably committed to the database and all subsequently started transactions will observe its effects.
            </summary>
            <returns>Task that succeeds if the transaction was comitted successfully, or fails if the transaction failed to commit.</returns>
            <remarks>As with other client/server databases, in some failure scenarios a client may be unable to determine whether a transaction succeeded. In these cases, CommitAsync() will throw CommitUnknownResult error. The OnErrorAsync() function treats this error as retryable, so retry loops that don’t check for CommitUnknownResult could execute the transaction twice. In these cases, you must consider the idempotence of the transaction.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Watch(FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>
            Watch a key for any change in the database.
            </summary>
            <param name="key">Key to watch</param>
            <param name="cancellationToken">CancellationToken used to abort the watch if the caller doesn't want to wait anymore. Note that you can manually cancel the watch by calling Cancel() on the returned FdbWatch instance</param>
            <returns>FdbWatch that can be awaited and will complete when the key has changed in the database, or cancellation occurs. You can call Cancel() at any time if you are not interested in watching the key anymore. You MUST always call Dispose() if the watch completes or is cancelled, to ensure that resources are released properly.</returns>
            <remarks>You can directly await an FdbWatch, or obtain a Task&lt;Slice&gt; by reading the <see cref="P:FoundationDB.Client.FdbWatch.Task"/> property</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.OnErrorAsync(FoundationDB.Client.FdbError)">
            <summary>
            Implements the recommended retry and backoff behavior for a transaction.
            
            This function knows which of the error codes generated by other query functions represent temporary error conditions and which represent application errors that should be handled by the application. 
            It also implements an exponential backoff strategy to avoid swamping the database cluster with excessive retries when there is a high level of conflict between transactions.
            </summary>
            <param name="code">FdbError code thrown by the previous command</param>
            <returns>Returns a task that completes if the operation can be safely retried, or that rethrows the original exception if the operation is not retryable.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Reset">
            <summary>Reset the transaction to its initial state.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Cancel">
            <summary>Rollback this transaction, and dispose it. It should not be used after that.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanRead">
            <summary>Throws if the transaction is not a valid state (for reading/writing) and that we can proceed with a read operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanWrite">
            <summary>Throws if the transaction is not a valid state (for writing) and that we can proceed with a write operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureCanRetry">
            <summary>Throws if the transaction is not safely retryable</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureStilValid(System.Boolean,System.Boolean)">
            <summary>Throws if the transaction is not a valid state (for reading/writing) and that we can proceed with a read or write operation</summary>
            <param name="allowFromNetworkThread">If true, this operation is allowed to run from a callback on the network thread and should NEVER block.</param>
            <param name="allowFailedState">If true, this operation can run even if the transaction is in a failed state.</param>
            <exception cref="T:System.ObjectDisposedException">If Dispose as already been called on the transaction</exception>
            <exception cref="T:System.InvalidOperationException">If CommitAsync() or Rollback() have already been called on the transaction, or if the database has been closed</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.EnsureNotFailedOrDisposed">
            <summary>Throws if the transaction is not a valid state (for reading/writing)</summary>
            <exception cref="T:System.ObjectDisposedException">If Dispose as already been called on the transaction</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbTransaction.Dispose">
            <summary>
            Destroy the transaction and release all allocated resources, including all non-committed changes.
            </summary>
            <remarks>This instance will not be usable again and most methods will throws an ObjectDisposedException.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Snapshot">
            <summary>Returns a version of this transaction that perform snapshotted operations</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Id">
            <summary>Internal local identifier of the transaction</summary>
            <remarks>Should only used for logging/debugging purpose.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.IsSnapshot">
            <summary>Always returns false. Use the <see cref="P:FoundationDB.Client.FdbTransaction.Snapshot"/> property to get a different view of this transaction that will perform snapshot reads.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Context">
            <summary>Returns the context of this transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Database">
            <summary>Database instance that manages this transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Handler">
            <summary>Returns the handler for this transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.StillAlive">
            <summary>If true, the transaction is still pending (not committed or rolledback).</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Size">
            <summary>Estimated size of the transaction payload (in bytes)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Cancellation">
            <summary>Cancellation Token that is cancelled when the transaction is disposed</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.IsReadOnly">
            <summary>Returns true if this transaction only supports read operations, or false if it supports both read and write operations</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.Timeout">
            <summary>Timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.RetryLimit">
            <summary>Maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbTransaction.State">
            <summary>Get/Sets the internal state of the exception</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbTransaction.Snapshotted">
            <summary>Wrapper on a transaction, that will use Snmapshot mode on all read operations</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.HasMore">
            <summary>Set to true if there are more results in the database than could fit in a single chunk</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Chunk">
            <summary>Contains the items that where </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Iteration">
            <summary>Iteration number of this chunk (used when paging through a long range)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeChunk.Reversed">
            <summary>Set to true if the original range read was reversed (meaning the items are in reverse lexicographic order</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.Count">
            <summary>Returns the number of results in this chunk</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.IsEmpty">
            <summary>Returns true if the chunk does not contain any item.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.First">
            <summary>Returns the first item in the chunk</summary>
            <remarks>Note that if the range is reversed, then the first item will be GREATER than the last !</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeChunk.Last">
            <summary>Returns the last item in the chunk</summary>
            <remarks>Note that if the range is reversed, then the last item will be LESS than the first!</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbTransactionExtensions">
            <summary>Provides a set of extensions methods shared by all FoundationDB transaction implementations.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithAccessToSystemKeys``1(``0)">
            <summary>Allows this transaction to read and modify system keys (those that start with the byte 0xFF)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithPrioritySystemImmediate``1(``0)">
            <summary>Specifies that this transaction should be treated as highest priority and that lower priority transactions should block behind this one. Use is discouraged outside of low-level tools</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithPriorityBatch``1(``0)">
            <summary>Specifies that this transaction should be treated as low priority and that default priority transactions should be processed first. Useful for doing batch work simultaneously with latency-sensitive work</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithReadYourWritesDisable``1(``0)">
            <summary>Reads performed by a transaction will not see any prior mutations that occurred in that transaction, instead seeing the value which was in the database at the transaction's read version. This option may provide a small performance benefit for the client, but also disables a number of client-side optimizations which are beneficial for transactions which tend to read and write the same keys within a single transaction. Also note that with this option invoked any outstanding reads will return errors when transaction commit is called (rather than the normal behavior of commit waiting for outstanding reads to complete).</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithReadAheadDisable``1(``0)">
            <summary>Disables read-ahead caching for range reads. Under normal operation, a transaction will read extra rows from the database into cache if range reads are used to page through a series of data one row at a time (i.e. if a range read with a one row limit is followed by another one row range read starting immediately after the result of the first).</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithNextWriteNoWriteConflictRange``1(``0)">
            <summary>The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not conflict with this transaction. Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithTimeout``1(``0,System.TimeSpan)">
            <summary>Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
            <param name="timeout">Timeout (with millisecond precision), or TimeSpan.Zero for infinite timeout</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithTimeout``1(``0,System.Int32)">
            <summary>Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.</summary>
            <param name="milliseconds">Timeout in millisecond, or 0 for infinite timeout</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.WithRetryLimit``1(``0,System.Int32)">
            <summary>Set a maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRange(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelectorPair,FoundationDB.Client.FdbRangeOptions)">
            <summary>
            Create a new range query that will read all key-value pairs in the database snapshot represented by the transaction
            </summary>
            <param name="range">Pair of key selectors defining the beginning and the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <returns>Range query that, once executed, will return all the key-value pairs matching the providing selector pair</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRangeAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelectorPair,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="range">key selector pair defining the beginning and the end of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRangeAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeyRange,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="range">Range of keys defining the beginning (inclusive) and the end (exclusive) of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetRangeAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.FdbRangeOptions,System.Int32)">
            <summary>
            Reads all key-value pairs in the database snapshot represented by transaction (potentially limited by Limit, TargetBytes, or Mode)
            which have a key lexicographically greater than or equal to the key resolved by the begin key selector
            and lexicographically less than the key resolved by the end key selector.
            </summary>
            <param name="beginInclusive">Key defining the beginning (inclusive) of the range</param>
            <param name="endExclusive">Key defining the end (exclusive) of the range</param>
            <param name="options">Optionnal query options (Limit, TargetBytes, Mode, Reverse, ...)</param>
            <param name="iteration">If streaming mode is FdbStreamingMode.Iterator, this parameter should start at 1 and be incremented by 1 for each successive call while reading this range. In all other cases it is ignored.</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.Clear``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Modify the database snapshot represented by this transaction to remove the given key from the database. If the key was not previously present in the database, there is no effect.
            </summary>
            <param name="key">Key to be removed from the database.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.ClearRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Modify the database snapshot represented by this transaction to remove all keys (if any) which are lexicographically greater than or equal to the given begin key and lexicographically less than the given end_key.
            Sets and clears affect the actual database only if transaction is later committed with CommitAsync().
            </summary>
            <param name="range">Pair of keys defining the range to clear.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange,FoundationDB.Client.FdbConflictRangeType)">
            <summary>
            Adds a conflict range to a transaction without performing the associated read or write.
            </summary>
            <param name="range">Range of the keys specifying the conflict range. The end key is excluded</param>
            <param name="type">One of the FDBConflictRangeType values indicating what type of conflict range is being set.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictRange``1(FoundationDB.Client.IFdbTransaction,``0,``0)">
            <summary>
            Adds a range of keys to the transaction’s read conflict ranges as if you had read the range. As a result, other transactions that write a key in this range could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictKey(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice)">
            <summary>
            Adds a key to the transaction’s read conflict ranges as if you had read the key. As a result, other transactions that write to this key could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddReadConflictKey``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Adds a key to the transaction’s read conflict ranges as if you had read the key. As a result, other transactions that write to this key could cause the transaction to fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbKeyRange)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictRange``1(FoundationDB.Client.IFdbTransaction,``0,``0)">
            <summary>
            Adds a range of keys to the transaction’s write conflict ranges as if you had cleared the range. As a result, other transactions that concurrently read a key in this range could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictKey(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice)">
            <summary>
            Adds a key to the transaction’s write conflict ranges as if you had cleared the key. As a result, other transactions that concurrently read this key could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.AddWriteConflictKey``1(FoundationDB.Client.IFdbTransaction,``0)">
            <summary>
            Adds a key to the transaction’s write conflict ranges as if you had cleared the key. As a result, other transactions that concurrently read this key could fail with a conflict.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetAndWatchAsync(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Reads the value associated with <paramref name="key"/>, and returns a Watch that will complete after a subsequent change to key in the database.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Key to be looked up in the database</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property contains the current value of the key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetAndWatchAsync``1(FoundationDB.Client.IFdbTransaction,``0,System.Threading.CancellationToken)">
            <summary>Reads the value associated with <paramref name="key"/>, and returns a Watch that will complete after a subsequent change to key in the database.</summary>
            <typeparam name="TKey">Type of the key, which must implement the IFdbKey interface</typeparam>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Key to be looked up in the database</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property contains the current value of the key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch``1(FoundationDB.Client.IFdbTransaction,``0,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <typeparam name="TKey">Type of the key, which must implement the IFdbKey interface</typeparam>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch``1(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.Slice,``0,FoundationDB.Client.IValueEncoder{``0},System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <typeparam name="TValue">Type of the value</typeparam>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="encoder">Encoder use to convert <paramref name="value"/> into a slice</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.SetAndWatch``2(FoundationDB.Client.IFdbTransaction,``0,``1,FoundationDB.Client.IValueEncoder{``1},System.Threading.CancellationToken)">
            <summary>Sets <paramref name="key"/> to <paramref name="value"/> and returns a Watch that will complete after a subsequent change to the key in the database.</summary>
            <typeparam name="TKey">Type of the key, which must implement the IFdbKey interface</typeparam>
            <typeparam name="TValue">Type of the value</typeparam>
            <param name="trans">Transaction to use for the operation</param>
            <param name="key">Name of the key to be inserted into the database.</param>
            <param name="value">Value to be inserted into the database.</param>
            <param name="encoder">Encoder use to convert <paramref name="value"/> into a slice</param>
            <param name="cancellationToken">Token that can be used to cancel the Watch from the outside.</param>
            <returns>A new Watch that will track any changes to <paramref name="key"/> in the database, and whose <see cref="P:FoundationDB.Client.FdbWatch.Value">Value</see> property will be a copy of <paramref name="value"/> argument</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value will be Slice.Nil.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice},FoundationDB.Client.IValueEncoder{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <param name="decoder">Decoder used to decoded the results into values of type <typeparamref name="TValue"/></param>
            <returns>Task that will return an array of decoded values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value depends on the behavior of <paramref name="decoder"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value will be Slice.Nil.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetValuesAsync``2(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{``0},FoundationDB.Client.IValueEncoder{``1})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <param name="decoder">Decoder used to decoded the results into values of type <typeparamref name="TValue"/></param>
            <returns>Task that will return an array of decoded values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value depends on the behavior of <paramref name="decoder"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetKeysAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.FdbKeySelector})">
            <summary>
            Resolves several key selectors against the keys in the database snapshot represented by the current transaction.
            </summary>
            <param name="selectors">Sequence of key selectors to resolve</param>
            <returns>Task that will return an array of keys matching the selectors, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of key/value pairs, or an exception. Each pair in the array will contain the key at the same index in <paramref name="keys"/>, and its corresponding value in the database or Slice.Nil if that key does not exist.</returns>
            <remarks>This method is equivalent to calling <see cref="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetValuesAsync(FoundationDB.Client.Slice[])"/>, except that it will return the keys in addition to the values.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.Slice[])">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Array of keys to be looked up in the database</param>
            <returns>Task that will return an array of key/value pairs, or an exception. Each pair in the array will contain the key at the same index in <paramref name="keys"/>, and its corresponding value in the database or Slice.Nil if that key does not exist.</returns>
            <remarks>This method is equivalent to calling <see cref="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetValuesAsync(FoundationDB.Client.Slice[])"/>, except that it will return the keys in addition to the values.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice},FoundationDB.Client.IValueEncoder{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Array of keys to be looked up in the database</param>
            <param name="decoder">Decoder used to decoded the results into values of type <typeparamref name="TValue"/></param>
            <returns>Task that will return an array of pairs of key and decoded values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value depends on the behavior of <paramref name="decoder"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.Slice[],FoundationDB.Client.IValueEncoder{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <param name="decoder">Decoder used to decoded the results into values of type <typeparamref name="TValue"/></param>
            <returns>Task that will return an array of pairs of key and decoded values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value depends on the behavior of <paramref name="decoder"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync``1(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <returns>Task that will return an array of key/value pairs, or an exception. Each pair in the array will contain the key at the same index in <paramref name="keys"/>, and its corresponding value in the database or Slice.Nil if that key does not exist.</returns>
            <remarks>This method is equivalent to calling <see cref="M:FoundationDB.Client.IFdbReadOnlyTransaction.GetValuesAsync(FoundationDB.Client.Slice[])"/>, except that it will return the keys in addition to the values.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.GetBatchAsync``2(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{``0},FoundationDB.Client.IValueEncoder{``1})">
            <summary>
            Reads several values from the database snapshot represented by the current transaction.
            </summary>
            <param name="keys">Sequence of keys to be looked up in the database</param>
            <param name="decoder">Decoder used to decoded the results into values of type <typeparamref name="TValue"/></param>
            <returns>Task that will return an array of pairs of key and decoded values, or an exception. The position of each item in the array is the same as its coresponding key in <paramref name="keys"/>. If a key does not exist in the database, its value depends on the behavior of <paramref name="decoder"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbTransactionExtensions.QueryAsync``1(FoundationDB.Client.IFdbReadOnlyTransactional,System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Linq.IFdbAsyncEnumerable{``0}},System.Threading.CancellationToken)">
            <summary>Runs a query inside a read-only transaction context, with retry-logic.</summary>
            <param name="db">Database used for the operation</param>
            <param name="handler">Lambda function that returns an async enumerable. The function may be called multiple times if the transaction conflicts.</param>
            <param name="cancellationToken">Token used to cancel the operation</param>
            <returns>Task returning the list of all the elements of the async enumerable returned by the last successfull call to <paramref name="handler"/>.</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeOptions">
            <summary>Container class for options in a Range query</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor">
            <summary>Create a new empty set of options</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor(System.Nullable{System.Int32},System.Nullable{System.Boolean},System.Nullable{System.Int32},System.Nullable{FoundationDB.Client.FdbStreamingMode})">
            <summary>Create a new set of options</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.#ctor(FoundationDB.Client.FdbRangeOptions)">
            <summary>Copy an existing set of options</summary>
            <param name="options"></param>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.EnsureDefaults(FoundationDB.Client.FdbRangeOptions,System.Nullable{System.Int32},System.Nullable{System.Int32},FoundationDB.Client.FdbStreamingMode,System.Boolean)">
            <summary>Add all missing values from the provided defaults</summary>
            <param name="options">Options provided by the caller (can be null)</param>
            <param name="limit">Default value for Limit if not provided</param>
            <param name="targetBytes">Default TargetBytes for limit if not provided</param>
            <param name="mode">Default value for StreamingMode if not provided</param>
            <param name="reverse">Default value for Reverse if not provided</param>
            <returns>Options with all the values filled</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeOptions.EnsureLegalValues">
            <summary>Throws if values are not legal</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Limit">
            <summary>Maximum number of items to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Reverse">
            <summary>If true, results are returned in reverse order (from last to rist)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.TargetBytes">
            <summary>Maximum number of bytes to read</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeOptions.Mode">
            <summary>Streaming mode</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbOperationContext">
            <summary>
            Represents the context of a retryable transactional function wich accept a read-only or read-write transaction.
            </summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunReadAsync(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbReadOnlyTransaction},System.Threading.CancellationToken)">
            <summary>Run a read-only operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunReadWithResultAsync``1(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbReadOnlyTransaction},System.Threading.CancellationToken)">
            <summary>Run a read-only operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteAsync(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a read/write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteAsync(FoundationDB.Client.IFdbDatabase,System.Action{FoundationDB.Client.IFdbTransaction},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbOperationContext.RunWriteWithResultAsync``1(FoundationDB.Client.IFdbDatabase,System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Run a read/write operation until it suceeds, timeouts, or fail with non-retryable error</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Database">
            <summary>The database used by the operation</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Result">
            <summary>Result of the operation (or null)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Cancellation">
            <summary>Cancellation token associated with the operation</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Abort">
            <summary>If set to true, will abort and not commit the transaction. If false, will try to commit the transaction (and retry on failure)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Retries">
            <summary>Current attempt number (0 for first, 1+ for retries)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.StartedUtc">
            <summary>Date at wich the operation was first started</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Duration">
            <summary>Time spent since the start of the first attempt</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Committed">
            <summary>If true, the transaction has been committed successfully</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Shared">
            <summary>If true, the lifetime of the context is handled by an external retry loop. If false, the context is linked to the lifetime of the transaction instance.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.Mode">
            <summary>Mode of the transaction</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbOperationContext.TokenSource">
            <summary>Internal source of cancellation, able to abort any pending IO operations attached to this transaction</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbExceptIterator`3">
            <summary>Returns only the values for the keys that are in the first sub query, but not in the others</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Client.FdbQueryMergeIterator`3">
            <summary>Performs a Merge Sort on several concurrent range queries</summary>
            <typeparam name="TSource">Type of the elements in the source queries</typeparam>
            <typeparam name="TKey">Type of values extracted from the keys, that will be used for sorting</typeparam>
            <typeparam name="TResult">Type of results returned</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncIterator`1">
            <summary>Base class for all async iterators</summary>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncEnumerable`1">
            <summary>Asynchronous version of the <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface, allowing elements of the enumerable sequence to be retrieved asynchronously.</summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncEnumerable`1.GetEnumerator">
            <summary>Gets an asynchronous enumerator over the sequence.</summary>
            <returns>Enumerator for asynchronous enumeration over the sequence.</returns>
        </member>
        <member name="M:FoundationDB.Linq.IFdbAsyncEnumerable`1.GetEnumerator(FoundationDB.Linq.FdbAsyncMode)">
            <summary>
            Gets an asynchronous enumerator over the sequence.
            </summary>
            <param name="mode">Defines how the enumerator will be used by the caller. The source provider can use the mode to optimize how the results are produced.</param>
            <returns>Enumerator for asynchronous enumeration over the sequence.</returns>
        </member>
        <member name="T:FoundationDB.Async.IAsyncEnumerator`1">
            <summary>Asynchronous version of the <see cref="T:System.Collections.Generic.IEnumerator`1"/> interface, allowing elements to be retrieved asynchronously.</summary>
            <typeparam name="T">Element type.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncEnumerator`1.MoveNext(System.Threading.CancellationToken)">
            <summary>Advances the enumerator to the next element in the sequence, returning the result asynchronously.</summary>
            <param name="cancellationToken">Cancellation token that can be used to cancel the operation.</param>
            <returns>
            Task containing the result of the operation: true if the enumerator was successfully advanced 
            to the next element; false if the enumerator has passed the end of the sequence.
            </returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncEnumerator`1.Current">
            <summary>Gets the current element in the iteration.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbQueryMergeIterator`3.OnNextAsync(System.Threading.CancellationToken)">
            <summary>Finds the next smallest item from all the active iterators</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbExceptIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the intersection</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbExceptIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the intersection</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New Intersect that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbIntersectIterator`3">
            <summary>Returns only the values for the keys that are in all the sub queries</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="M:FoundationDB.Client.FdbIntersectIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the intersection</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbIntersectIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the intersection</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New Intersect that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbKeySelectorPair">
            <summary>Represents of pair of key selectors that range 'GetKey(Begin) &lt;= key &lt; GetKey(End)'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelectorPair.Begin">
            <summary>Start of the range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelectorPair.End">
            <summary>End of the range</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.#ctor(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector)">
            <summary>Create a new pair of key selectors</summary>
            <param name="beginInclusive">Selector for key from which to start iterating</param>
            <param name="endExclusive">Selector for key where to stop iterating</param>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector)">
            <summary>Factory method for a pair of key selectors</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create``1(``0,``0)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.Create(FoundationDB.Client.FdbKeyRange)">
            <summary>Create a new pair of key selectors using FIRST_GREATER_OR_EQUAL on both keys</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.StartsWith(FoundationDB.Client.Slice)">
            <summary>Create a new pair of key selectors that will select all the keys that start with the specified prefix</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.StartsWith``1(``0)">
            <summary>Create a new pair of key selectors that will select all the keys that start with the specified prefix</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelectorPair.ToString">
            <summary>Returns a printable version of the pair of key selectors</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbMergeSortIterator`3">
            <summary>Merge all the elements of several ordered queries into one single async sequence</summary>
            <typeparam name="TSource">Type of the elements from the source async sequences</typeparam>
            <typeparam name="TKey">Type of the keys extracted from the source elements</typeparam>
            <typeparam name="TResult">Type of the elements of resulting async sequence</typeparam>
        </member>
        <member name="M:FoundationDB.Client.FdbMergeSortIterator`3.Select``1(System.Func{`2,``0})">
            <summary>Apply a transformation on the results of the merge sort</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbMergeSortIterator`3.Take(System.Int32)">
            <summary>Limit the number of elements returned by the MergeSort</summary>
            <param name="limit">Maximum number of results to return</param>
            <returns>New MergeSort that will only return the specified number of results</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1">
            <summary>Query describing an ongoing GetRange operation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.#ctor(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbKeySelector,FoundationDB.Client.FdbKeySelector,System.Func{System.Collections.Generic.KeyValuePair{FoundationDB.Client.Slice,FoundationDB.Client.Slice},`0},System.Boolean,FoundationDB.Client.FdbRangeOptions)">
            <summary>Construct a query with a set of initial settings</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.#ctor(FoundationDB.Client.FdbRangeQuery{`0},FoundationDB.Client.FdbRangeOptions)">
            <summary>Copy constructor</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Take(System.Int32)">
            <summary>Only return up to a specific number of results</summary>
            <param name="count">Maximum number of results to return</param>
            <returns>A new query object that will only return up to <paramref name="count"/> results when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Skip(System.Int32)">
            <summary>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</summary>
            <param name="count"></param>
            <returns>A new query object that will skip the first <paramref name="count"/> results when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Reverse">
            <summary>Reverse the order in which the results will be returned</summary>
            <returns>A new query object that will return the results in reverse order when executed</returns>
            <remarks>Calling Reverse() on an already reversed query will cancel the effect, and the results will be returned in their natural order.
            Note: Combining the effects of Take()/Skip() and Reverse() may have an impact on performance, especially if the ReadYourWriteDisabled transaction is options set.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.WithTargetBytes(System.Int32)">
            <summary>Use a specific target bytes size</summary>
            <param name="bytes"></param>
            <returns>A new query object that will use the specified target bytes size when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.WithMode(FoundationDB.Client.FdbStreamingMode)">
            <summary>Use a different Streaming Mode</summary>
            <param name="mode">Streaming mode to use when reading the results from the database</param>
            <returns>A new query object that will use the specified streaming mode when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.UseTransaction(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Force the query to use a specific transaction</summary>
            <param name="transaction">Transaction to use when executing this query</param>
            <returns>A new query object that will use the specified transaction when executed</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToListAsync">
            <summary>Return a list of all the elements of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToArrayAsync">
            <summary>Return an array with all the elements of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.CountAsync">
            <summary>Return the number of elements in the range, by reading them</summary>
            <remarks>This method has to read all the keys and values, which may exceed the lifetime of a transaction. Please consider using <see cref="M:FoundationDB.Client.Fdb.System.EstimateCountAsync(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.FdbKeyRange,System.Threading.CancellationToken)"/> when reading potentially large ranges.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Select``1(System.Func{`0,``0})">
            <summary>Projects each element of the range results into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.Where(System.Func{`0,System.Boolean})">
            <summary>Filters the range results based on a predicate.</summary>
            <remarks>Caution: filtering occurs on the client side !</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.AnyAsync">
            <summary>Return true if the range query returns at least one element, or false if there was no result.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.NoneAsync">
            <summary>Return true if the range query does not return any valid elements, or false if there was at least one result.</summary>
            <remarks>This is a convenience method that is there to help porting layer code from other languages. This is strictly equivalent to calling "!(await query.AnyAsync())".</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ForEachAsync(System.Action{`0})">
            <summary>Execute an action on each key/value pair of the range results</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.ToString">
            <summary>Returns a printable version of the range query</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Begin">
            <summary>Key selector describing the beginning of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.End">
            <summary>Key selector describing the end of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Range">
            <summary>Key selector pair describing the beginning and end of the range that will be queried</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Options">
            <summary>Stores all the settings for this range query</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.OriginalRange">
            <summary>Original key selector pair describing the bounds of the parent range. All the results returned by the query will be bounded by this original range.</summary>
            <remarks>May differ from <see cref="P:FoundationDB.Client.FdbRangeQuery`1.Range"/> when combining certain operators.</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Limit">
            <summary>Limit in number of rows to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.TargetBytes">
            <summary>Limit in number of bytes to return</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Mode">
            <summary>Streaming mode</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Snapshot">
            <summary>Should we perform the range using snapshot mode ?</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Reversed">
            <summary>Should the results be returned in reverse order (from last key to first key)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Transaction">
            <summary>Parent transaction used to perform the GetRange operation</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.Transform">
            <summary>Transformation applied to the result</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1.ResultIterator">
            <summary>Async iterator that fetches the results by batch, but return them one by one</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_resultTransform">
            <summary>Lambda used to transform pairs of key/value into the expected result</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_chunkIterator">
            <summary>Iterator used to read chunks from the database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_outOfChunks">
            <summary>True if we have reached the last page</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_chunk">
            <summary>Current chunk (may contain all records or only a segment at a time)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_itemsRemainingInChunk">
            <summary>Number of remaining items in the current batch</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbRangeQuery`1.ResultIterator.m_currentOffsetInChunk">
            <summary>Offset in the current batch of the current item</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQuery`1.PagingIterator">
            <summary>Async iterator that fetches the results by batch, but return them one by one</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.FetchNextPageAsync(System.Threading.CancellationToken)">
            <summary>Asynchronously fetch a new page of results</summary>
            <param name="cancellationToken"></param>
            <returns>True if Chunk contains a new page of results. False if all results have been read.</returns>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Begin">
            <summary>Key selector describing the beginning of the current range (when paging)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.End">
            <summary>Key selector describing the end of the current range (when paging)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Remaining">
            <summary>If non null, contains the remaining allowed number of rows</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Iteration">
            <summary>Iteration number of current page (in iterator mode)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.Chunk">
            <summary>Current page (may contain all records or only a segment at a time)</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.HasMore">
            <summary>If true, we have more records pending</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.AtEnd">
            <summary>True if we have reached the last page</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.RowCount">
            <summary>Running total of rows that have been read</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbRangeQuery`1.PagingIterator.PendingReadTask">
            <summary>Current/Last batch read task</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbException">
            <summary>FoundationDB API Error Code</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbException.Code">
            <summary>Gets the code for this error.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbException.Success">
            <summary>Determine if this FDBError represents a success code from the native layer.</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbRangeQueryExtensions">
            <summary>Extension methods for <see cref="T:FoundationDB.Client.FdbRangeQuery`1"/></summary>
        </member>
        <member name="T:FoundationDB.Client.FdbKeyRange">
            <summary>Represents a pair of keys defining the range 'Begin &lt;= key &gt; End'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeyRange.Begin">
            <summary>Start of the range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeyRange.End">
            <summary>End of the range</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.#ctor(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>
            Create a new range of keys
            </summary>
            <param name="begin">Start of range (usually included)</param>
            <param name="end">End of range (usually excluded)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.StartsWith(FoundationDB.Client.Slice)">
            <summary>Create a range that will return all keys starting with <paramref name="prefix"/>: ('prefix' &lt;= k &lt; strinc('prefix'))</summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.PrefixedBy(FoundationDB.Client.Slice)">
            <summary>Create a range that selects all keys starting with <paramref name="prefix"/>, but not the prefix itself: ('prefix\x00' &lt;= k &lt; string('prefix')</summary>
            <param name="prefix">Key prefix (that will be excluded from the range)</param>
            <returns>Range including all keys with the specified prefix.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.FromKey(FoundationDB.Client.Slice)">
            <summary>Create a range that will only return <paramref name="key"/> itself ('key' &lt;= k &lt; 'key\x00')</summary>
            <param name="key">Key that will be returned by the range</param>
            <returns>Range that only return the specified key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Merge(FoundationDB.Client.FdbKeyRange)">
            <summary>Combine another range with the current range, to produce a range that includes both (and all keys in between it the ranges are disjoint)</summary>
            <param name="other">Range to merge with the current range</param>
            <returns>New range where the Begin key is the smallest bound and the End key is the largest bound of both ranges.</returns>
            <remarks>If both range are disjoint, then the resulting range will also contain the keys in between.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Intersects(FoundationDB.Client.FdbKeyRange)">
            <summary>Checks whether the current and the specified range are intersecting (i.e: there exists at at least one key that belongs to both ranges)</summary>
            <param name="other">Range that is being checked for interection</param>
            <returns>True if the other range intersects the current range.</returns>
            <remarks>Note that ranges [0, 1) and [1, 2) do not intersect, since the end is exclusive by default</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Disjoint(FoundationDB.Client.FdbKeyRange)">
            <summary>Checks whether the current and the specified range are disjoint (i.e: there exists at least one key between both ranges)</summary>
            <param name="other"></param>
            <returns></returns>
            <remarks>Note that ranges [0, 1) and [1, 2) are not disjoint because, even though they do not intersect, they are both contiguous.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Contains(FoundationDB.Client.Slice)">
            <summary>Returns true, if the key is contained in the range</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.Test(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Test if <paramref name="key"/> is contained inside the range</summary>
            <param name="key">Key that will be compared with the the range's bounds</param>
            <param name="endIncluded">If true, the End bound is inclusive, otherwise it is exclusive</param>
            <returns>-1 if key is less than the lower bound of the range (<paramref name="key"/> &lt; Begin), +1 if the key is greater or equal to the higher bound of the range (<paramref name="key"/> &gt;= End) or 0 if it is inside the range (Begin &lt;= <paramref name="key"/> &lt; End)</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeyRange.ToString">
            <summary>Returns a printable version of the range</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbKeyRange.Empty">
            <summary>Returns an empty pair of keys</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbKey">
            <summary>Factory class for keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.MinValue">
            <summary>Smallest possible key ('\0')</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.MaxValue">
            <summary>Bigest possible key ('\xFF'), excluding the system keys</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.Directory">
            <summary>Default Directory Layer prefix ('\xFE')</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKey.System">
            <summary>Default System prefix ('\xFF')</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Increment(FoundationDB.Client.Slice)">
            <summary>Returns the first key lexicographically that does not have the passed in <paramref name="slice"/> as a prefix</summary>
            <param name="slice">Slice to increment</param>
            <returns>New slice that is guaranteed to be the first key lexicographically higher than <paramref name="slice"/> which does not have <paramref name="slice"/> as a prefix</returns>
            <remarks>If the last byte is already equal to 0xFF, it will rollover to 0x00 and the next byte will be incremented.</remarks>
            <exception cref="T:System.ArgumentException">If the Slice is equal to Slice.Nil</exception>
            <exception cref="T:System.OverflowException">If the Slice is the empty string or consists only of 0xFF bytes</exception>
            <example>
            FdbKey.Increment(Slice.FromString("ABC")) =&gt; "ABD"
            FdbKey.Increment(Slice.FromHexa("01 FF")) =&gt; { 02 }
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Merge(FoundationDB.Client.Slice,FoundationDB.Client.Slice[])">
            <summary>Merge an array of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Array of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Merge(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Merge a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.SplitIntoSegments(System.Byte[],System.Int32,System.Collections.Generic.List{System.Int32})">
            <summary>Split a buffer containing multiple contiguous segments into an array of segments</summary>
            <param name="buffer">Buffer containing all the segments</param>
            <param name="start">Offset of the start of the first segment</param>
            <param name="endOffsets">Array containing, for each segment, the offset of the following segment</param>
            <returns>Array of segments</returns>
            <example>SplitIntoSegments("HelloWorld", 0, [5, 10]) => [{"Hello"}, {"World"}]</example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.BatchedRange(System.Int32,System.Int32,System.Int32)">
            <summary>Split a range of indexes into several batches</summary>
            <param name="offset">Offset from which to start counting</param>
            <param name="count">Total number of values that will be returned</param>
            <param name="batchSize">Maximum size of each batch</param>
            <returns>Collection of B batches each containing at most <paramref name="batchSize"/> contiguous indices, counting from <paramref name="offset"/> to (<paramref name="offset"/> + <paramref name="count"/> - 1)</returns>
            <example>Batched(0, 100, 20) => [ {0..19}, {20..39}, {40..59}, {60..79}, {80..99} ]</example>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Batched(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Split range of indexes into a fixed number of 'worker' sequence, that will consume batches in parallel
            </summary>
            <param name="offset">Offset from which to start counting</param>
            <param name="count">Total number of values that will be returned</param>
            <param name="workers">Number of concurrent workers that will take batches from the pool</param>
            <param name="batchSize">Maximum size of each batch</param>
            <returns>List of '<paramref name="workers"/>' enumerables that all fetch batches of values from the same common pool. All enumerables will stop when the last batch as been consumed by the last worker.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.Dump(FoundationDB.Client.Slice)">
            <summary>Produce a user-friendly version of the slice</summary>
            <param name="key">Random binary key</param>
            <returns>User friendly version of the key. Attempts to decode the key as a tuple first. Then as an ASCII string. Then as an hex dump of the key.</returns>
            <remarks>This can be slow, and should only be used for logging or troubleshooting.</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbKey.PrettyPrint(FoundationDB.Client.Slice,FoundationDB.Client.FdbKey.PrettyPrintMode)">
            <summary>Produce a user-friendly version of the slice</summary>
            <param name="key">Random binary key</param>
            <param name="mode">Defines if the key is standalone, or is the begin or end part or a key range. This will enable or disable some heuristics that try to properly format key ranges.</param>
            <returns>User friendly version of the key. Attempts to decode the key as a tuple first. Then as an ASCII string. Then as an hex dump of the key.</returns>
            <remarks>This can be slow, and should only be used for logging or troubleshooting.</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbTransactionOption">
            <summary>Defines a set of options for a transaction</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CausalWriteRisky">
            <summary>
            The transaction, if not self-conflicting, may be committed a second time after commit succeeds, in the event of a fault
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CausalReadRisky">
            <summary>
            The read version will be committed, and usually will be the latest committed, but might not be the latest committed in the event of a fault or partition
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CausalReadDisable">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.NextWriteNoWriteConflictRange">
            <summary>
            The next write performed on this transaction will not generate a write conflict range. As a result, other transactions which read the key(s) being modified by the next write will not conflict with this transaction. Care needs to be taken when using this option on a transaction that is shared between multiple threads. When setting this option, write conflict ranges will be disabled on the next write operation, regardless of what thread it is on.
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.CheckWritesEnable">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.ReadYourWritesDisable">
            <summary>
            Reads performed by a transaction will not see any prior mutations that occurred in that transaction, instead seeing the value which was in the database at the transaction's read version. This option may provide a small performance benefit for the client, but also disables a number of client-side optimizations which are beneficial for transactions which tend to read and write the same keys within a single transaction. Also note that with this option invoked any outstanding reads will return errors when transaction commit is called (rather than the normal behavior of commit waiting for outstanding reads to complete).
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.ReadAheadDisable">
            <summary>
            Disables read-ahead caching for range reads. Under normal operation, a transaction will read extra rows from the database into cache if range reads are used to page through a series of data one row at a time (i.e. if a range read with a one row limit is followed by another one row range read starting immediately after the result of the first).
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DurabilityDataCenter">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DurabilityRisky">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DevNullIsWebScale">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.PrioritySystemImmediate">
            <summary>
            Specifies that this transaction should be treated as highest priority and that lower priority transactions should block behind this one. Use is discouraged outside of low-level tools
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.PriorityBatch">
            <summary>
            Specifies that this transaction should be treated as low priority and that default priority transactions should be processed first. Useful for doing batch work simultaneously with latency-sensitive work
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.InitializeNewDatabase">
            <summary>
            This is a write-only transaction which sets the initial configuration
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.AccessSystemKeys">
            <summary>
            Allows this transaction to read and modify system keys (those that start with the byte 0xFF)
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.DebugDump">
            <summary>
            Parameter: Option takes no parameter
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.Timeout">
            <summary>
            Set a timeout in milliseconds which, when elapsed, will cause the transaction automatically to be cancelled. Valid parameter values are ``[0, INT_MAX]``. If set to 0, will disable all timeouts. All pending and any future uses of the transaction will throw an exception. The transaction can be used again after it is reset.
            Parameter: (Int) value in milliseconds of timeout
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbTransactionOption.RetryLimit">
            <summary>
            Set a maximum number of retries after which additional calls to onError will throw the most recently seen error code. Valid parameter values are ``[-1, INT_MAX]``. If set to -1, will disable the retry limit.
            Parameter: (Int) number of times to retry
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabaseOption">
            <summary>Defines a set of options for the database connection</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.None">
            <summary>No option defined</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.LocationCacheSize">
            <summary>
            Set the size of the client location cache. Raising this value can boost performance in very large databases where clients access data in a near-random pattern. Defaults to 100000.
            Parameter: (Int) Max location cache entries
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.MaxWatches">
            <summary>
            Set the maximum number of watches allowed to be outstanding on a database connection. Increasing this number could result in increased resource usage. Reducing this number will not cancel any outstanding watches. Defaults to 10000 and cannot be larger than 1000000.
            Parameter: (Int) Max outstanding watches
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.MachineId">
            <summary>
            Specify the machine ID that was passed to fdbserver processes running on the same machine as this client, for better location-aware load balancing.
            Parameter: (String) Hexadecimal ID
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabaseOption.DataCenterId">
            <summary>
            Specify the datacenter ID that was passed to fdbserver processes running in the same datacenter as this client, for better location-aware load balancing.
            Parameter: (String) Hexadecimal ID
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbStreamingMode">
            <summary>Defines how the client would like the data in a range a returned</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.WantAll">
            <summary>
            Client intends to consume the entire range and would like it all transferred as early as possible. 
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Iterator">
            <summary>
            The default. The client doesn't know how much of the range it is likely to used and wants different performance concerns to be balanced. Only a small portion of data is transferred to the client initially (in order to minimize costs if the client doesn't read the entire range), and as the caller iterates over more items in the range larger batches will be transferred in order to minimize latency.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Exact">
            <summary>
            Infrequently used. The client has passed a specific row limit and wants that many rows delivered in a single batch. Because of iterator operation in client drivers make request batches transparent to the user, consider WANT_ALL StreamingMode instead. A row limit must be specified if this mode is used.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Small">
            <summary>
            Infrequently used. Transfer data in batches small enough to not be much more expensive than reading individual rows, to minimize cost if iteration stops early.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Medium">
            <summary>
            Infrequently used. Transfer data in batches sized in between small and large. Usually the default
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Large">
            <summary>
            Infrequently used. Transfer data in batches large enough to be, in a high-concurrency environment, nearly as efficient as possible. If the client stops iteration early, some disk and network bandwidth may be wasted. The batch size may still be too small to allow a single client to get high throughput from the database, so if that is what you need consider the SERIAL StreamingMode.
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbStreamingMode.Serial">
            <summary>
            Transfer data in batches large enough that an individual client can get reasonable read bandwidth from the database. If the client stops iteration early, considerable disk and network bandwidth may be wasted.
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbClusterOption">
            <summary>Defines a set of options for the cluster connection</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbClusterOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbClusterOption.Invalid">
            <summary>This option is only a placeholder for C compatibility and should not be used</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbNetworkOption">
            <summary>Defines a set of options for the network thread</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.None">
            <summary>None</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.LocalAddress">
            <summary>
            Deprecated
            Parameter: (String) IP:PORT
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.ClusterFile">
            <summary>
            Deprecated
            Parameter: (String) Path to cluster file
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TraceEnable">
            <summary>
            Enables trace output to a file in a directory of the clients choosing
            Parameter: (String) path to output directory (or NULL for current working directory)
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.Knob">
            <summary>
            Set internal tuning or debugging knobs
            Parameter: (String) knob_name=knob_value
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSPlugin">
            <summary>
            Set the TLS plugin to load. This option, if used, must be set before any other TLS options
            Parameter: (String) file path or linker-resolved name
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSCertBytes">
            <summary>
            Set the certificate chain
            Parameter: (Bytes) certificates
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSCertPath">
            <summary>
            Set the file from which to load the certificate chain
            Parameter: (String) File path
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSKeyBytes">
            <summary>
            Set the private key corresponding to your own certificate
            Parameter: (Bytes) Key
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSKeyPath">
            <summary>
            Set the file from which to load the private key corresponding to your own certificate
            Parameter: (String) File path
            </summary>
        </member>
        <member name="F:FoundationDB.Client.FdbNetworkOption.TLSVerifyPeers">
            <summary>
            Set the peer certificate field verification criteria
            Parameter: (Bytes) Verification pattern
            </summary>
        </member>
        <member name="T:FoundationDB.Client.FdbError">
            <summary>FoundationDB API Error Code</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.Success">
            <summary>Success</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.OperationFailed">
            <summary>Operation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TimedOut">
            <summary> Operation timed out</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PastVersion">
            <summary>Version no longer available</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureVersion">
            <summary>Request for future version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NotCommitted">
            <summary>Transaction not committed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.CommitUnknownResult">
            <summary>Transaction may or may not have committed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionCancelled">
            <summary>Operation aborted because the transaction was cancelled</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionTimedOut">
            <summary>Operation aborted because the transaction timed out</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TooManyWatches">
            <summary>Too many watches are currently set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.WatchesDisabled">
            <summary>Disabling read your writes also disables watches</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.BrokenPromise">
            <summary>Broken Promise [UNDOCUMENTED]</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.OperationCancelled">
            <summary>Asynchronous operation cancelled</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureReleased">
            <summary>The future has been released</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PlatformError">
            <summary>A platform error occurred</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.LargeAllocFailed">
            <summary>Large block allocation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.PerformanceCounterError">
            <summary>QueryPerformanceCounter doesn’t work</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.IOError">
            <summary>A disk i/o operation failed</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotFound">
            <summary>File not found</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.BindFailed">
            <summary>Unable to bind to network</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotReadable">
            <summary>File could not be read from</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FileNotWriteable">
            <summary>File could not be written to</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NoClusterFileFound">
            <summary>No cluster file found in current directory or default location</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ClusterFileTooLarge">
            <summary>Cluster file to large to be read</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ClientInvalidOperation">
            <summary>The client made an invalid API call</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.CommitReadIncomplete">
            <summary>Commit with incomplete read</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TestSpecificationInvalid">
            <summary>The test specification is invalid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.KeyOutsideLegalRange">
            <summary>The specified key was outside the legal range</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvertedRange">
            <summary>The specified range has a begin key larger than the end key</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidOptionValue">
            <summary>An invalid value was passed with the specified option</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidOption">
            <summary>Option not valid in this context</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NetworkNotSetup">
            <summary>Action not possible before the network is configured</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.NetworkAlreadySetup">
            <summary>Network can be configured only once</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ReadVersionAlreadySet">
            <summary>Transaction already has a read version set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.VersionInvalid">
            <summary>Version not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.RangeLimitsInvalid">
            <summary>getRange limits not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidDatabaseName">
            <summary>Database name not supported in this version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.AttributeNotFound">
            <summary>Attribute not found in string</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureNotSet">
            <summary>The future has not been set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.FutureNotError">
            <summary>The future is not an error</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.UsedDuringCommit">
            <summary>An operation was issued while a commit was outstanding</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidMutationType">
            <summary>An invalid atomic mutation type was issued</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.IncompatibleProtocolVersion">
            <summary>Incompatible protocol version</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TransactionTooLarge">
            <summary>Transaction too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.KeyTooLarge">
            <summary>Key too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ValueTooLarge">
            <summary>Value too large</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ConnectionStringInvalid">
            <summary>Connection string invalid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.AddressInUse">
            <summary>Local address in use</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InvalidLocalAddress">
            <summary>Invalid local address</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.TlsError">
            <summary>TLS error</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionUnset">
            <summary>Api version must be set</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionAlreadySet">
            <summary>Api version may be set only once</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionInvalid">
            <summary>Api version not valid</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ApiVersionNotSupported">
            <summary>Api version not supported in this version or binding</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.ExactModeWithoutLimits">
            <summary>EXACT streaming mode requires limits, but none were given</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.UnknownError">
            <summary>An unknown error occurred</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbError.InternalError">
            <summary>An internal error occurred</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <param name="path"/>.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <param name="path"/>.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <param name="name"/>.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <param name="name"/>.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateOrOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransaction,System.String,FoundationDB.Client.Slice)">
            <summary>Opens the directory with the given <param name="name"/>.
            If the directory does not exist, it is created (creating parent directories if necessary).
            If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An error is raised if the given directory already exists.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An error is raised if the given directory already exists.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="name"/>.
            An error is raised if the given directory already exists.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Creates a directory with the given <paramref name="name"/>.
            An error is raised if the given directory already exists.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.CreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransaction,System.String,FoundationDB.Client.Slice)">
            <summary>Creates a directory with the given <paramref name="name"/>.
            An error is raised if the given directory already exists.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to create a directory with the given <paramref name="name"/>.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryCreateAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransaction,System.String,FoundationDB.Client.Slice)">
            <summary>Attempts to create a directory with the given <paramref name="name"/>.
            If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An error is raised if the directory does not exist.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An error is raised if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Opens the sub-directory with the given <paramref name="name"/>.
            An error is raised if the directory does not exist.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Opens the sub-directory with the given <paramref name="name"/>.
            An error is raised if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.OpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String,FoundationDB.Client.Slice)">
            <summary>Opens the sub-directory with the given <paramref name="name"/>.
            An error is raised if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryOpenAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Attempts to open the directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.MoveToAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Moves the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if a directory already exists at `new_path`, or if the new path points to a child of the current directory.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryMoveToAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Attempts to move the current directory to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.RemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransaction,System.String)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryRemoveAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbTransaction,System.String)">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Checks if a directory already exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Checks if a directory already exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String)">
            <summary>Checks if a directory already exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ExistsAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Checks if this directory exists</summary>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of the sub-directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String)">
            <summary>Returns the list of subdirectories of the sub-directory with the given <paramref name="name"/>.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransactional,System.String,System.Threading.CancellationToken)">
            <summary>Returns the list of subdirectories of the sub-directory with the given <paramref name="name"/>, if it exists</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.IFdbDirectory,FoundationDB.Client.IFdbReadOnlyTransaction,System.String)">
            <summary>Returns the list of subdirectories of the sub-directory with the given <paramref name="name"/>, if it exists</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ListAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Returns the list of all the subdirectories of the current directory.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.TryListAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbReadOnlyTransactional,System.Threading.CancellationToken)">
            <summary>Returns the list of all the subdirectories of the current directory, it it exists.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ChangeLayerAsync(FoundationDB.Layers.Directories.FdbDirectoryLayer,FoundationDB.Client.IFdbTransactional,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Change the layer id of the directory at <param name="path"/></summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryTransactionals.ChangeLayerAsync(FoundationDB.Layers.Directories.FdbDirectorySubspace,FoundationDB.Client.IFdbTransactional,FoundationDB.Client.Slice,System.Threading.CancellationToken)">
            <summary>Change the layer id of this directory</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`4">
            <summary>Tuple that can hold four items</summary>
            <typeparam name="T1">Type of the first item</typeparam>
            <typeparam name="T2">Type of the second item</typeparam>
            <typeparam name="T3">Type of the third item</typeparam>
            <typeparam name="T4">Type of the fourth item</typeparam>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.IFdbTuple">
            <summary>Represents a Tuple of N elements</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Get``1(System.Int32)">
            <summary>Return the typed value of an item of the tuple, given its position</summary>
            <typeparam name="T">Expected type of the item</typeparam>
            <param name="index">Position of the item (if negative, means relative from the end)</param>
            <returns>Value of the item at position <paramref name="index"/>, adapted into type <typeparamref name="T"/>.</returns>
            <exception cref="T:System.IndexOutOfRangeException">If <paramref name="index"/> is outside the bounds of the tuple</exception>
            <example>
            ("Hello", "World", 123,).Get&lt;string&gt;(0) =&gt; "Hello"
            ("Hello", "World", 123,).Get&lt;int&gt;(-1) =&gt; 123
            ("Hello", "World", 123,).Get&lt;string&gt;(-1) =&gt; "123"
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Last``1">
            <summary>Return the typed value of the last item in the tuple</summary>
            <typeparam name="T">Expected type of the item</typeparam>
            <returns>Value of the last item of this tuple, adapted into type <typeparamref name="T"/></returns>
            <remarks>Equivalent of tuple.Get&lt;T&gt;(-1)</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.Append``1(``0)">
            <summary>Create a new Tuple by appending a new value at the end the this tuple</summary>
            <typeparam name="T">Type of the new value</typeparam>
            <param name="value">Value that will be appended at the end</param>
            <returns>New tuple with the new value</returns>
            <example>("Hello,").Append("World") => ("Hello", "World",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.CopyTo(System.Object[],System.Int32)">
            <summary>Copy all items of the tuple into an array at a specific location</summary>
            <param name="array">Destination array (must be big enough to contains all the items)</param>
            <param name="offset">Offset at wich to start copying items</param>
            <example>
            var tmp = new object[3];
            ("Hello", "World", 123,).CopyTo(tmp, 0);
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.PackTo(FoundationDB.Client.SliceWriter@)">
            <summary>Appends the packed bytes of this instance to the end of a buffer</summary>
            <param name="writer">Buffer that will received the packed bytes of this instance</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.IFdbTuple.ToSlice">
            <summary>Pack this instance into a Slice</summary>
            <example>
            ("Hello", "World", 123).ToSlice() => '\x02Hello\x00\x02World\x00\x15\x7B'
            </example>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.IFdbTuple.Item(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Return a section of the tuple</summary>
            <param name="fromIncluded">Starting offset of the sub-tuple to return, or null to select from the start. Negative values means from the end</param>
            <param name="toExcluded">Ending offset (excluded) of the sub-tuple to return or null to select until the end. Negative values means from the end.</param>
            <returns>Tuple that include all items in the current tuple whose offset are greather than or equal to <paramref name="fromIncluded"/> and strictly less than <paramref name="toExcluded"/>. The tuple may be smaller than expected if the range is larger than the parent tuple. If the range does not intersect with the tuple, the Empty tuple will be returned.</returns>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`4.Item1">
            <summary>First element of the quartet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`4.Item2">
            <summary>Second element of the quartet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`4.Item3">
            <summary>Third element of the quartet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`4.Item4">
            <summary>Fourth and last element of the quartet</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabasePartition">
            <summary>Database instance that manages the content of a KeySpace partition</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabasePartition.ListAsync(System.Threading.CancellationToken)">
            <summary>Returns the list of all the top level directories of this database instance.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabasePartition.ListAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Returns the list of all the top level directories of this database instance.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabasePartition.TryListAsync(System.Threading.CancellationToken)">
            <summary>Returns the list of all the top level directories of this database instance.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabasePartition.TryListAsync(System.Collections.Generic.IEnumerable{System.String},System.Threading.CancellationToken)">
            <summary>Returns the list of all the top level directories of this database instance.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabasePartition.Directory">
            <summary>Wrapped Directory instance</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabasePartition.Database">
            <summary>Wrapped Directory instance</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbHighContentionAllocator.AllocateAsync(FoundationDB.Client.IFdbTransaction)">
            <summary>Returns a 64-bit integer that
            1) has never and will never be returned by another call to this
               method on the same subspace
            2) is nearly as short as possible given the above
            </summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbHighContentionAllocator.Subspace">
            <summary>Location of the allocator</summary>
        </member>
        <member name="T:FoundationDB.Layers.Directories.FdbDirectoryLayer">
            <summary>Provides a FdbDirectoryLayer class for managing directories in FoundationDB.
            Directories are a recommended approach for administering layers and applications. Directories work in conjunction with subspaces. Each layer or application should create or open at least one directory with which to manage its subspace(s).
            Directories are identified by paths (specified as tuples) analogous to the paths in a Unix-like file system. Each directory has an associated subspace that is used to store content. The layer uses a high-contention allocator to efficiently map each path to a short prefix for its corresponding subspace.
            <see cref="T:FoundationDB.Layers.Directories.FdbDirectoryLayer"/> exposes methods to create, open, move, remove, or list directories. Creating or opening a directory returns the corresponding subspace.
            The <see cref="T:FoundationDB.Layers.Directories.FdbDirectorySubspace"/> class represents subspaces that store the contents of a directory. An instance of <see cref="T:FoundationDB.Layers.Directories.FdbDirectorySubspace"/> can be used for all the usual subspace operations. It can also be used to operate on the directory with which it was opened.
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.PartitionSubPath(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Convert a relative path in this Directory Layer, into an absolute path from the root of partition of the database</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.#ctor(FoundationDB.Client.FdbSubspace,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>
            Creates a new instance that will manages directories in FoudnationDB.
            </summary>
            <param name="nodeSubspace">Subspace where all the node metadata will be stored ('\xFE' by default)</param>
            <param name="contentSubspace">Subspace where all automatically allocated directories will be stored (empty by default)</param>
            <param name="location">Location of the root of all the directories managed by this Directory Layer. Ususally empty for the root partition of the database.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.Create">
            <summary>Create an instance of the default Directory Layer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.Create(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Create an instance of a Directory Layer located under a specific prefix and path</summary>
            <param name="prefix">Prefix for the content. The nodes will be stored under <paramref name="prefix"/> + &lt;FE&gt;</param>
            <param name="path">Optional path, if the Directory Layer is not located at the root of the database.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.Create(FoundationDB.Client.FdbSubspace,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Create an instance of a Directory Layer located under a specific subspace and path</summary>
            <param name="subspace">Subspace for the content. The nodes will be stored under <paramref name="subspace"/>.Key + &lt;FE&gt;</param>
            <param name="path">Optional path, if the Directory Layer is not located at the root of the database.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.Create(FoundationDB.Client.FdbSubspace,FoundationDB.Client.FdbSubspace,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Create an instance of a Directory Layer located under a specific subpsace and path</summary>
            <param name="nodeSubspace">Subspace for the nodes of the Directory Layer.</param>
            <param name="contentSubspace">Subspace for the content of the Directory Layer.</param>
            <param name="path">Optional path, if the Directory Layer is not located at the root of the database</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateOrOpenAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens the directory with the given path. If the directory does not exist, it is created (creating parent directories if necessary).</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create or open</param>
            <param name="layer">If layer is specified, it is checked against the layer of an existing directory or set as the layer of a new directory.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.OpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Opens the directory with the given <paramref name="path"/>.
            An exception is thrown if the directory does not exist, or if a layer is specified and a different layer was specified when the directory was created.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.CreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Creates a directory with the given <paramref name="path"/> (creating parent directories if necessary).
            An exception is thrown if the given directory already exists.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryOpenAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Attempts to open the directory with the given <paramref name="path"/>.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to open.</param>
            <param name="layer">Optional layer id of the directory. If it is different than the layer specified when creating the directory, an exception will be thrown.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryCreateAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Attempts to create a directory with the given <paramref name="path"/> (creating parent directories if necessary).</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RegisterAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Registers an existing prefix as a directory with the given <paramref name="path"/> (creating parent directories if necessary). This method is only indented for advanced use cases.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">The directory will be created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryRegisterAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Attempts to register an existing prefix as a directory with the given <paramref name="path"/> (creating parent directories if necessary). This method is only indented for advanced use cases.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to create</param>
            <param name="layer">If <paramref name="layer"/> is specified, it is recorded with the directory and will be checked by future calls to open.</param>
            <param name="prefix">The directory will be created with the given physical prefix; otherwise a prefix is allocated automatically.</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.MoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Moves the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            An error is raised if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryMoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to move the directory found at <paramref name="oldPath"/> to <paramref name="newPath"/>.
            There is no effect on the physical prefix of the given directory, or on clients that already have the directory open.
            Returns null if the old directory does not exist, a directory already exists at `new_path`, or the parent directory of `new_path` does not exist.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="oldPath">Path of the directory to move</param>
            <param name="newPath">New path of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Removes the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryRemoveAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Attempts to remove the directory, its contents, and all subdirectories.
            Warning: Clients that have already opened the directory might still insert data into its contents after it is removed.
            </summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ExistsAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Checks if a directory already exists</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to remove (including any subdirectories)</param>
            <returns>Returns true if the directory exists, otherwise false.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/></summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ListAsync(FoundationDB.Client.IFdbReadOnlyTransaction)">
            <summary>Returns the list of subdirectories of the root directory</summary>
            <param name="trans">Transaction to use for the operation</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.TryListAsync(FoundationDB.Client.IFdbReadOnlyTransaction,System.Collections.Generic.IEnumerable{System.String})">
            <summary>Returns the list of subdirectories of directory at <paramref name="path"/>, if it exists.</summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to list</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ChangeLayerAsync(FoundationDB.Client.IFdbTransaction,System.Collections.Generic.IEnumerable{System.String},FoundationDB.Client.Slice)">
            <summary>Change the layer id of the directory at <param name="path"/></summary>
            <param name="trans">Transaction to use for the operation</param>
            <param name="path">Path of the directory to change</param>
            <param name="newLayer">New layer id of the directory</param>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ToRelativePath(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Maps an absolute path to a relative path within this directory layer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.NodeWithPrefix(FoundationDB.Client.Slice)">
            <summary>Returns the subspace to a node metadata, given its prefix</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ContentsOfNode(FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Client.Slice)">
            <summary>Returns a new Directory Subspace given its node subspace, path and layer id</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.FindAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Finds a node subspace, given its path, by walking the tree from the root.</summary>
            <returns>Node if it was found, or null</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.SubdirNamesAndNodes(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Returns the list of names and nodes of all children of the specified node</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveFromParent(FoundationDB.Client.IFdbTransaction,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Remove an existing node from its parents</summary>
            <returns>True if the parent node was found, otherwise false</returns>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.RemoveRecursive(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Resursively remove a node (including the content), all its children</summary>
        </member>
        <member name="M:FoundationDB.Layers.Directories.FdbDirectoryLayer.ParsePath(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Convert a tuple representing a path, into a string array</summary>
            <param name="path">Tuple that should only contain strings</param>
            <returns>Array of strings</returns>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.ContentSubspace">
            <summary>Subspace where the content of each folder will be stored</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.NodeSubspace">
            <summary>Subspace where all the metadata nodes for each folder will be stored</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.RootNode">
            <summary>Root node of the directory</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.Allocator">
            <summary>Allocated used to generated prefix for new content</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.Location">
            <summary>Gets the path for the root node of this <code>FdbDirectoryLayer</code>.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.Name">
            <summary>Name of root directory of this layer</summary>
            <remarks>Returns String.Empty for the root Directory Layer, or the name of the partition</remarks>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.FullName">
            <summary>Formatted path of the root directory of this layer</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.Path">
            <summary>Gets the path for the root node of this <code>FdbDirectoryLayer</code></summary>
            <remarks>Normally constructed <code>DirectoryLayer</code>s have an empty path, but <code>DirectoryLayer</code>s returned by <see cref="P:FoundationDB.Layers.Directories.IFdbDirectory.DirectoryLayer"/> for <see cref="T:FoundationDB.Layers.Directories.IFdbDirectory"/>s inside of a <see cref="T:FoundationDB.Layers.Directories.FdbDirectoryPartition"/> could have non-empty paths.</remarks>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.FoundationDB#Layers#Directories#IFdbDirectory#Layer">
            <summary>Returns the layer id for this <code>FdbDirectoryLayer</code>, which is always Slice.Empty.</summary>
        </member>
        <member name="P:FoundationDB.Layers.Directories.FdbDirectoryLayer.FoundationDB#Layers#Directories#IFdbDirectory#DirectoryLayer">
            <summary>Self reference</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbPrefixedTuple">
            <summary>Tuple that has a fixed abitrary binary prefix</summary>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbPrefixedTuple.Prefix">
            <summary>Binary prefix to all the keys produced by this tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleAlias">
            <summary>Special tuple values</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.Zero">
            <summary>Alias that represents the Null or Min value '\0' when used in the last position.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.Directory">
            <summary>Alias that represents the value '\xFE', frequently used by the Directory Layer</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleAlias.System">
            <summary>Alias that represents the Max value '\xFF', also used by the System Keys when in the first position</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbAnonymousTupleFormatter`1">
            <summary>Customer formatter that will called the provided lambda functions to convert to and from a tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.ITupleFormatter`1">
            <summary>
            Defines methods to support converting keys into/from tuples
            </summary>
            <typeparam name="TKey">Type of the keys</typeparam>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormatter`1.ToTuple(`0)">
            <summary>Convert a key into a tuple sequence</summary>
            <param name="key">Key to convert to a tuple</param>
            <returns>Tuple that represent the key (can contain a single item for primitive keys, or several items for composite keys)</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormatter`1.FromTuple(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Convert a tuple sequence into a key</summary>
            <param name="tuple">Tuple to convert back into a key</param>
            <returns>Key that corresponds to the tuple</returns>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbGenericTupleFormatter`1">
            <summary>Simple key formatter that maps a value into a singleton tuple, and back</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbFormattableTupleFormatter`1">
            <summary>Specialized formatter for types that implement ITupleFormattable</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.ITupleFormattable">
            <summary>
            Defines a generalized method to convert a custom type into a tuple and back
            </summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormattable.ToTuple">
            <summary>Return the tuple representation of this instance</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.ITupleFormattable.FromTuple(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Load a tuple representation into a newly created instance</summary>
            <param name="tuple"></param>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleComparisons">
            <summary>Helper class for tuple comparisons</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Default">
            <summary>Tuple comparer that treats similar values as equal ("123" = 123 = 123L = 123.0d)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Bcl">
            <summary>Tuple comparer that uses the default BCL object comparison ("123" != 123 != 123L != 123.0d)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleComparisons.Binary">
            <summary>Tuple comparer that compared the packed bytes (slow!)</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbJoinedTuple">
            <summary>Tuple that represents the concatenation of two tuples</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.Head">
            <summary>First tuple (first N items)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.Tail">
            <summary>Second tuple (last M items)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.m_split">
            <summary>Offset at which the Tail tuple starts. Items are in Head tuple if index &lt; split. Items are in Tail tuple if index &gt;= split.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbJoinedTuple.m_count">
            <summary>Total size of the tuple (sum of the size of the two inner tuples)</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbSubspaceExtensions">
            <summary>Extensions methods to add FdbSubspace overrides to various types</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ClearRange(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace)">
            <summary>Clear the entire content of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ClearRangeAsync(FoundationDB.Client.IFdbTransactional,FoundationDB.Client.FdbSubspace,System.Threading.CancellationToken)">
            <summary>Clear the entire content of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.GetRangeStartsWith(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Client.FdbRangeOptions)">
            <summary>Returns all the keys inside of a subspace</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.GetAsync(FoundationDB.Client.IFdbReadOnlyTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Read a key inside a subspace</summary>
            <example>
            Both lines are equivalent:
            tr.GetAsync(new FdbSubspace("Hello"), FdbTuple.Create("World"));
            tr.GetAsync(FdbTuple.Create("Hello", "World"));
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Set(FoundationDB.Client.IFdbTransaction,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Client.Slice)">
            <summary>Write a key inside a subspace</summary>
            <example>
            Both lines are equivalent:
            tr.Set(new FdbSubspace("Hello"), FdbTuple.Create("World"), some_value);
            tr.Set(FdbTuple.Create("Hello", "World"), some_value);
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Contains``1(FoundationDB.Client.FdbSubspace,``0)">
            <summary>Tests whether the specified <paramref name="key"/> starts with this Subspace's prefix, indicating that the Subspace logically contains <paramref name="key"/>.</summary>
            <param name="key">The key to be tested</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Concat(FoundationDB.Client.IFdbSubspace,FoundationDB.Client.Slice)">
            <summary>Append a key to the subspace key</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Concat``1(FoundationDB.Client.IFdbSubspace,``0)">
            <summary>Append a key to the subspace key</summary>
            <typeparam name="TKey">type of the key, must implements IFdbKey</typeparam>
            <param name="key"></param>
            <returns>Return Slice : 'subspace.Key + key'</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ConcatRange(FoundationDB.Client.IFdbSubspace,FoundationDB.Client.Slice[])">
            <summary>Merge an array of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Array of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ConcatRange(FoundationDB.Client.IFdbSubspace,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ConcatRange``1(FoundationDB.Client.IFdbSubspace,System.Collections.Generic.IEnumerable{``0})">
            <summary>Append a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="TKey">type of the key, must implements IFdbKey</typeparam>
            <param name="keys"></param>
            <returns>Return Slice : 'subspace.Key + key'</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition``1(FoundationDB.Client.IFdbSubspace,``0)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T">Type of the child subspace key</typeparam>
            <param name="value">Value of the child subspace</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <remarks>Subspace([Foo, ]).Partition(Bar) is equivalent to Subspace([Foo, Bar, ])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts") == new FdbSubspace(["Users", "Contacts", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition``2(FoundationDB.Client.IFdbSubspace,``0,``1)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T1">Type of the first subspace key</typeparam>
            <typeparam name="T2">Type of the second subspace key</typeparam>
            <param name="value1">Value of the first subspace key</param>
            <param name="value2">Value of the second subspace key</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <remarks>Subspace([Foo, ]).Partition(Bar, Baz) is equivalent to Subspace([Foo, Bar, Baz])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts", "Friends") == new FdbSubspace(["Users", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition``3(FoundationDB.Client.IFdbSubspace,``0,``1,``2)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T1">Type of the first subspace key</typeparam>
            <typeparam name="T2">Type of the second subspace key</typeparam>
            <typeparam name="T3">Type of the third subspace key</typeparam>
            <param name="value1">Value of the first subspace key</param>
            <param name="value2">Value of the second subspace key</param>
            <param name="value3">Value of the third subspace key</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <example>
            new FdbSubspace(["Users", ]).Partition("John Smith", "Contacts", "Friends") == new FdbSubspace(["Users", "John Smith", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition``4(FoundationDB.Client.IFdbSubspace,``0,``1,``2,``3)">
            <summary>Partition this subspace into a child subspace</summary>
            <typeparam name="T1">Type of the first subspace key</typeparam>
            <typeparam name="T2">Type of the second subspace key</typeparam>
            <typeparam name="T3">Type of the third subspace key</typeparam>
            <typeparam name="T4">Type of the fourth subspace key</typeparam>
            <param name="value1">Value of the first subspace key</param>
            <param name="value2">Value of the second subspace key</param>
            <param name="value3">Value of the third subspace key</param>
            <param name="value4">Value of the fourth subspace key</param>
            <returns>New subspace that is logically contained by the current subspace</returns>
            <example>
            new FdbSubspace(["Users", ]).Partition("John Smith", "Contacts", "Friends", "Messages") == new FdbSubspace(["Users", "John Smith", "Contacts", "Friends", "Messages", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Parition this subspace by appending a tuple</summary>
            <param name="tuple">Tuple that will be used for this partition</param>
            <returns>New subspace that is creating by combining the namespace prefix and <paramref name="tuple"/></returns>
            <remarks>Subspace([Foo, ]).Partition([Bar, Baz, ]) is equivalent to Subspace([Foo, Bar, Baz,])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition(["Contacts", "Friends", ]) => new FdbSubspace(["Users", "Contacts", "Friends", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Partition(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.ITupleFormattable)">
            <summary>Partition this subspace into a child subspace</summary>
            <param name="formattable">a ITupleFormattable, <paramref name="formattable"/>.ToTuple() will be used for this partition</param>
            <returns>New subspace that is creating by combining the namespace prefix and <paramref name="formattable"/></returns>
            <remarks>Subspace([Foo, ]).Partition(Bar) is equivalent to Subspace([Foo, Bar, ])</remarks>
            <example>
            new FdbSubspace(["Users", ]).Partition("Contacts") == new FdbSubspace(["Users", "Contacts", ])
            </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ToTuple(FoundationDB.Client.IFdbSubspace)">
            <summary>Return an empty tuple that is attached to this subspace</summary>
            <returns>Empty tuple that can be extended, and whose packed representation will always be prefixed by the subspace key</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Attach a tuple to an existing subspace.</summary>
            <param name="tuple">Tuple whose items will be appended at the end of the current subspace</param>
            <returns>Tuple that wraps the items of <paramref name="tuple"/> and whose packed representation will always be prefixed by the subspace key.</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.ITupleFormattable)">
            <summary>Convert a formattable item into a tuple that is attached to this subspace.</summary>
            <param name="formattable">Item that can be converted into a tuple</param>
            <returns>Tuple that is the logical representation of the item, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(formattable.ToTuple())'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append``1(FoundationDB.Client.IFdbSubspace,``0)">
            <summary>Create a new 1-tuple that is attached to this subspace</summary>
            <typeparam name="T">Type of the value to append</typeparam>
            <param name="value">Value that will be appended</param>
            <returns>Tuple of size 1 that contains <paramref name="value"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T&gt;(value))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append``2(FoundationDB.Client.IFdbSubspace,``0,``1)">
            <summary>Create a new 2-tuple that is attached to this subspace</summary>
            <typeparam name="T1">Type of the first value to append</typeparam>
            <typeparam name="T2">Type of the second value to append</typeparam>
            <param name="value1">First value that will be appended</param>
            <param name="value2">Second value that will be appended</param>
            <returns>Tuple of size 2 that contains <paramref name="value1"/> and <paramref name="value2"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T1, T2&gt;(value1, value2))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append``3(FoundationDB.Client.IFdbSubspace,``0,``1,``2)">
            <summary>Create a new 3-tuple that is attached to this subspace</summary>
            <typeparam name="T1">Type of the first value to append</typeparam>
            <typeparam name="T2">Type of the second value to append</typeparam>
            <typeparam name="T3">Type of the third value to append</typeparam>
            <param name="value1">First value that will be appended</param>
            <param name="value2">Second value that will be appended</param>
            <param name="value3">Third value that will be appended</param>
            <returns>Tuple of size 3 that contains <paramref name="value1"/>, <paramref name="value2"/> and <paramref name="value3"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T1, T2, T3&gt;(value1, value2, value3))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Append``4(FoundationDB.Client.IFdbSubspace,``0,``1,``2,``3)">
            <summary>Create a new 4-tuple that is attached to this subspace</summary>
            <typeparam name="T1">Type of the first value to append</typeparam>
            <typeparam name="T2">Type of the second value to append</typeparam>
            <typeparam name="T3">Type of the third value to append</typeparam>
            <typeparam name="T4">Type of the fourth value to append</typeparam>
            <param name="value1">First value that will be appended</param>
            <param name="value2">Second value that will be appended</param>
            <param name="value3">Third value that will be appended</param>
            <param name="value4">Fourth value that will be appended</param>
            <returns>Tuple of size 4 that contains <paramref name="value1"/>, <paramref name="value2"/>, <paramref name="value3"/> and <paramref name="value4"/>, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create&lt;T1, T2, T3, T4&gt;(value1, value2, value3, value4))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.AppendBoxed(FoundationDB.Client.IFdbSubspace,System.Object[])">
            <summary>Create a new N-tuple that is attached to this subspace</summary>
            <param name="items">Array of items of the new tuple</param>
            <returns>Tuple of size <paramref name="items"/>.Length, and whose packed representation will always be prefixed by the subspace key.</returns>
            <remarks>This is the equivalent of calling 'subspace.Create(FdbTuple.Create(items))'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a new key by appending a formattable object to the current subspace</summary>
            <param name="tuple">Tuple to pack (can be empty)</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix and the packed representation of <paramref name="tuple"/></returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.ITupleFormattable)">
            <summary>Create a new key by appending a formattable object to the current subspace</summary>
            <param name="item">Instance of a type that can be transformed into a Tuple</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix and the packed representation of the tuple returned by <paramref name="item"/>.ToTuple()</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="item"/> is null</exception>
            <exception cref="T:System.InvalidOperationException">If calling <paramref name="item"/>.ToTuple() returns null.</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackBoxed(FoundationDB.Client.IFdbSubspace,System.Object)">
            <summary>Create a new key by appending a value to the current subspace</summary>
            <param name="item">Value that will be appended at the end of the key</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix and <paramref name="item"/></returns>
            <example>tuple.PackBoxed(x) is the non-generic equivalent of tuple.Pack&lt;object&gt;(tuple)</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack``1(FoundationDB.Client.IFdbSubspace,``0)">
            <summary>Create a new key by appending a value to the current subspace</summary>
            <typeparam name="T">Type of the value</typeparam>
            <param name="key">Value that will be appended at the end of the key</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix and <paramref name="key"/></returns>
            <example>tuple.Pack(x) is equivalent to tuple.Append(x).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack``2(FoundationDB.Client.IFdbSubspace,``0,``1)">
            <summary>Create a new key by appending two values to the current subspace</summary>
            <typeparam name="T1">Type of the next to last value</typeparam>
            <typeparam name="T2">Type of the last value</typeparam>
            <param name="key1">Value that will be in the next to last position</param>
            <param name="key2">Value that will be in the last position</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix, <paramref name="key1"/> and <paramref name="key2"/></returns>
            <example>(...,).Pack(x, y) is equivalent to (...,).Append(x).Append(y).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack``3(FoundationDB.Client.IFdbSubspace,``0,``1,``2)">
            <summary>Create a new key by appending three values to the current subspace</summary>
            <typeparam name="T1">Type of the first value</typeparam>
            <typeparam name="T2">Type of the second value</typeparam>
            <typeparam name="T3">Type of the thrid value</typeparam>
            <param name="key1">Value that will be appended first</param>
            <param name="key2">Value that will be appended second</param>
            <param name="key3">Value that will be appended third</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix, <paramref name="key1"/>, <paramref name="key2"/> and <paramref name="key3"/></returns>
            <example>tuple.Pack(x, y, z) is equivalent to tuple.Append(x).Append(y).Append(z).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Pack``4(FoundationDB.Client.IFdbSubspace,``0,``1,``2,``3)">
            <summary>Create a new key by appending three values to the current subspace</summary>
            <typeparam name="T1">Type of the first value</typeparam>
            <typeparam name="T2">Type of the second value</typeparam>
            <typeparam name="T3">Type of the third value</typeparam>
            <typeparam name="T4">Type of the fourth value</typeparam>
            <param name="key1">Value that will be appended first</param>
            <param name="key2">Value that will be appended second</param>
            <param name="key3">Value that will be appended third</param>
            <param name="key4">Value that will be appended fourth</param>
            <returns>Key the correspond to the concatenation of the current subspace's prefix, <paramref name="key1"/>, <paramref name="key2"/>, <paramref name="key3"/> and <paramref name="key4"/></returns>
            <example>tuple.Pack(w, x, y, z) is equivalent to tuple.Append(w).Append(x).Append(y).Append(z).ToSlice()</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackRange(FoundationDB.Client.IFdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple[])">
            <summary>Pack a sequence of tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack("abc", [ ("Foo", 1), ("Foo", 2) ]) => [ "abc\x02Foo\x00\x15\x01", "abc\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackRange(FoundationDB.Client.IFdbSubspace,System.Collections.Generic.IEnumerable{FoundationDB.Layers.Tuples.IFdbTuple})">
            <summary>Pack a sequence of tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack("abc", [ ("Foo", 1), ("Foo", 2) ]) => [ "abc\x02Foo\x00\x15\x01", "abc\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackRange``1(FoundationDB.Client.IFdbSubspace,System.Collections.Generic.IEnumerable{``0})">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackRange``1(FoundationDB.Client.IFdbSubspace,``0[])">
            <summary>Merge a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackBoxedRange(FoundationDB.Client.IFdbSubspace,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.PackBoxedRange(FoundationDB.Client.IFdbSubspace,System.Object[])">
            <summary>Pack a sequence of keys with the subspace's prefix, all sharing the same buffer</summary>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Unpack(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice)">
            <summary>Unpack a key into a tuple, with the subspace prefix removed</summary>
            <param name="key">Packed version of a key that should fit inside this subspace.</param>
            <returns>Unpacked tuple that is relative to the current subspace, or null if the key is equal to Slice.Nil</returns>
            <example>new Subspace([FE]).Unpack([FE 02 'H' 'e' 'l' 'l' 'o' 00 15 1]) =&gt; ("hello", 1,)</example>
            <exception cref="T:System.ArgumentOutOfRangeException">If the unpacked tuple is not contained in this subspace</exception>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackFirst``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice)">
            <summary>Unpack a key into a tuple, and return only the first element</summary>
            <typeparam name="T">Expected type of the last element</typeparam>
            <param name="key">Packed version of a key that should fit inside this subspace</param>
            <returns>Converted value of the last element of the tuple</returns>
            <example>new Subspace([FE]).UnpackLast&lt;int&gt;([FE 02 'H' 'e' 'l' 'l' 'o' 00 15 1]) => (string) "Hello"</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackLast``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice)">
            <summary>Unpack a key into a tuple, and return only the last element</summary>
            <typeparam name="T">Expected type of the last element</typeparam>
            <param name="key">Packed version of a key that should fit inside this subspace</param>
            <returns>Converted value of the last element of the tuple</returns>
            <example>new Subspace([FE]).UnpackLast&lt;int&gt;([FE 02 'H' 'e' 'l' 'l' 'o' 00 15 1]) => (int) 1</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackSingle``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice)">
            <summary>Unpack a key into a singleton tuple, and return the single element</summary>
            <typeparam name="T">Expected type of the only element</typeparam>
            <param name="key">Packed version of a key that should fit inside this subspace</param>
            <returns>Converted value of the only element in the tuple. Throws an exception if the tuple is empty or contains more than one element</returns>
            <example>new Subspace([FE]).UnpackSingle&lt;int&gt;([FE 02 'H' 'e' 'l' 'l' 'o' 00]) => (string) "Hello"</example>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.Unpack(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice[])">
            <summary>Unpack an array of keys in tuples, with the subspace prefix removed</summary>
            <param name="keys">Packed version of keys inside this subspace</param>
            <returns>Unpacked tuples that are relative to the current subspace</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackFirst``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice[])">
            <summary>Unpack an array of key into tuples, and return an array with only the first elements of each tuple</summary>
            <typeparam name="T">Expected type of the first element of all the keys</typeparam>
            <param name="keys">Array of packed keys that should all fit inside this subspace</param>
            <returns>Array containing the converted values of the first elements of each tuples</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackLast``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice[])">
            <summary>Unpack an array of key into tuples, and return an array with only the last elements of each tuple</summary>
            <typeparam name="T">Expected type of the last element of all the keys</typeparam>
            <param name="keys">Array of packed keys that should all fit inside this subspace</param>
            <returns>Array containing the converted values of the last elements of each tuples</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.UnpackSingle``1(FoundationDB.Client.FdbSubspace,FoundationDB.Client.Slice[])">
            <summary>Unpack an array of key into singleton tuples, and return an array with value of each tuple</summary>
            <typeparam name="T">Expected type of the only element of all the keys</typeparam>
            <param name="keys">Array of packed keys that should all fit inside this subspace</param>
            <returns>Array containing the converted values of the only elements of each tuples. Throws an exception if one key contains more than one element</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbSubspaceExtensions.ToRange(FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Gets a key range representing all keys in the Subspace strictly starting with the specified Tuple.</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbLinkedTuple`1">
            <summary>Tuple that adds a value at the end of an already existing tuple</summary>
            <typeparam name="T">Type of the last value of the tuple</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Tail">
            <summary>Value of the last element of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Head">
            <summary>Link to the parent tuple that contains the head.</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Depth">
            <summary>Cached size of the size of the Head tuple. Add 1 to get the size of this tuple.</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.#ctor(FoundationDB.Layers.Tuples.IFdbTuple,`0)">
            <summary>Append a new value at the end of an existing tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.PackTo(FoundationDB.Client.SliceWriter@)">
            <summary>Pack this tuple into a buffer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.ToSlice">
            <summary>Pack this tuple into a slice</summary>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbLinkedTuple`1.Count">
            <summary>Returns the number of elements in this tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple">
            <summary>Factory class for Tuples</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple.Empty">
            <summary>Empty tuple</summary>
            <remarks>Not to be mistaken with a 1-tuple containing 'null' !</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateBoxed(System.Object)">
            <summary>Create a new 1-tuple, holding only one item</summary>
            <remarks>This is the non-generic equivalent of FdbTuple.Create&lt;object&gt;()</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``1(``0)">
            <summary>Create a new 1-tuple, holding only one item</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``2(``0,``1)">
            <summary>Create a new 2-tuple, holding two items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``3(``0,``1,``2)">
            <summary>Create a new 3-tuple, holding three items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create``4(``0,``1,``2,``3)">
            <summary>Create a new 4-tuple, holding four items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Create(System.Object[])">
            <summary>Create a new N-tuple, from N items</summary>
            <param name="items">Items to wrap in a tuple</param>
            <remarks>If you already have an array of items, you should call <see cref="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[])"/> instead. Mutating the array, would also mutate the tuple!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Wrap(System.Object[])">
            <summary>Create a new N-tuple that wraps an array of untyped items</summary>
            <remarks>If the original array is mutated, the tuple will reflect the changes!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Wrap(System.Object[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple that wraps a section of an array of untyped items</summary>
            <remarks>If the original array is mutated, the tuple will reflect the changes!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[])">
            <summary>Create a new N-tuple, from an array of untyped items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Object[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple, from a section of an array of untyped items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Create a new N-tuple from a sequence of items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(``0[])">
            <summary>Create a new N-tuple, from an array of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(``0[],System.Int32,System.Int32)">
            <summary>Create a new N-tuple, from a section of an array of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Create a new N-tuple from a sequence of typed items</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxed(System.Object)">
            <summary>Pack a 1-tuple directly into a slice</summary>
            <remarks>This is the non-generic equivalent of FdbTuple.Pack&lt;object&gt;()</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``1(``0)">
            <summary>Pack a 1-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``2(``0,``1)">
            <summary>Pack a 2-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``3(``0,``1,``2)">
            <summary>Pack a 3-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``4(``0,``1,``2,``3)">
            <summary>Pack a 4-tuple directly into a slice</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{``0})">
            <summary>Merge a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Client.Slice,``0[])">
            <summary>Merge an array of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(System.Collections.Generic.IEnumerable{FoundationDB.Layers.Tuples.IFdbTuple})">
            <summary>Pack a sequence of N-tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack([ ("Foo", 1), ("Foo", 2) ]) => [ "\x02Foo\x00\x15\x01", "\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{FoundationDB.Layers.Tuples.IFdbTuple})">
            <summary>Pack a sequence of N-tuples, all sharing the same buffer</summary>
            <param name="prefix">Commong prefix added to all the tuples</param>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack("abc", [ ("Foo", 1), ("Foo", 2) ]) => [ "abc\x02Foo\x00\x15\x01", "abc\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(FoundationDB.Layers.Tuples.IFdbTuple[])">
            <summary>Pack an array of N-tuples, all sharing the same buffer</summary>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack([ ("Foo", 1), ("Foo", 2) ]) => [ "\x02Foo\x00\x15\x01", "\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange(FoundationDB.Client.Slice,FoundationDB.Layers.Tuples.IFdbTuple[])">
            <summary>Pack an array of N-tuples, all sharing the same buffer</summary>
            <param name="prefix">Commong prefix added to all the tuples</param>
            <param name="tuples">Sequence of N-tuples to pack</param>
            <returns>Array containing the buffer segment of each packed tuple</returns>
            <example>BatchPack("abc", [ ("Foo", 1), ("Foo", 2) ]) => [ "abc\x02Foo\x00\x15\x01", "abc\x02Foo\x00\x15\x02" ] </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Layers.Tuples.IFdbTuple,System.Collections.Generic.IEnumerable{``0})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackRange``1(FoundationDB.Layers.Tuples.IFdbTuple,``0[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <typeparam name="T">Type of the keys</typeparam>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Client.Slice,System.Object[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Object[])">
            <summary>Pack a sequence of keys with a same prefix, all sharing the same buffer</summary>
            <param name="prefix">Prefix shared by all keys</param>
            <param name="keys">Sequence of keys to pack</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Unpack(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a serialied key blob</summary>
            <param name="packedKey">Binary key containing a previously packed tuple</param>
            <returns>Unpacked tuple, or null if the key is Slice.Nil</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackWithoutPrefix(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a serialized key, after removing the prefix</summary>
            <param name="packedKey">Packed key</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Unpacked tuple (minus the prefix) or an exception if the key is outside the prefix</returns>
            <exception cref="T:System.ArgumentNullException">If prefix is null</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If the unpacked key is outside the specified prefix</exception>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackFirst``1(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its first element</summary>
            <typeparam name="T">Type of the first value in the decoded tuple</typeparam>
            <param name="packedKey">Slice that should be entirely parsable as a tuple</param>
            <returns>Decoded value of the first item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackFirstWithoutPrefix``1(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its first element, after removing <paramref name="prefix"/> from the start of the buffer</summary>
            <typeparam name="T">Type of the first value in the decoded tuple</typeparam>
            <param name="packedKey">Slice composed of <paramref name="prefix"/> followed by a packed tuple</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Decoded value of the first item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackLast``1(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its last element</summary>
            <typeparam name="T">Type of the last value in the decoded tuple</typeparam>
            <param name="packedKey">Slice that should be entirely parsable as a tuple</param>
            <returns>Decoded value of the last item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackLastWithoutPrefix``1(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack a tuple and only return its last element, after removing <paramref name="prefix"/> from the start of the buffer</summary>
            <typeparam name="T">Type of the last value in the decoded tuple</typeparam>
            <param name="packedKey">Slice composed of <paramref name="prefix"/> followed by a packed tuple</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Decoded value of the last item in the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackSingle``1(FoundationDB.Client.Slice)">
            <summary>Unpack the value of a singletion tuple</summary>
            <typeparam name="T">Type of the single value in the decoded tuple</typeparam>
            <param name="packedKey">Slice that should contain the packed representation of a tuple with a single element</param>
            <returns>Decoded value of the only item in the tuple. Throws an exception if the tuple is empty of has more than one element.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.UnpackSingleWithoutPrefix``1(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Unpack the value of a singleton tuple, after removing <paramref name="prefix"/> from the start of the buffer</summary>
            <typeparam name="T">Type of the single value in the decoded tuple</typeparam>
            <param name="packedKey">Slice composed of <paramref name="prefix"/> followed by a packed singleton tuple</param>
            <param name="prefix">Expected prefix of the key (that is not part of the tuple)</param>
            <returns>Decoded value of the only item in the tuple. Throws an exception if the tuple is empty of has more than one element.</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackWithPrefix(FoundationDB.Client.Slice,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Efficiently concatenate a prefix with the packed representation of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackBoxedWithPrefix(FoundationDB.Client.Slice,System.Object)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 1-tuple</summary>
            <remarks>This is the non-generic equivalent of <see cref="M:FoundationDB.Layers.Tuples.FdbTuple.Pack``1(``0)"/></remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackWithPrefix``1(FoundationDB.Client.Slice,``0)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 1-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackWithPrefix``2(FoundationDB.Client.Slice,``0,``1)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 2-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackWithPrefix``3(FoundationDB.Client.Slice,``0,``1,``2)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 3-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.PackWithPrefix``4(FoundationDB.Client.Slice,``0,``1,``2,``3)">
            <summary>Efficiently concatenate a prefix with the packed representation of a 4-tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Equals(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Determines whether the specified tuple instances are considered equal</summary>
            <param name="left">Left tuple</param>
            <param name="right">Right tuple</param>
            <returns>True if the tuples are considered equal; otherwise, false. If both <paramref name="left"/> and <paramref name="right"/> are null, the methods returns true;</returns>
            <remarks>This method is equivalent of calling left.Equals(right), </remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Equivalent(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Determines whether the specifield tuple instances are considered similar</summary>
            <param name="left">Left tuple</param>
            <param name="right">Right tuple</param>
            <returns>True if the tuples are considered similar; otherwise, false. If both <paramref name="left"/> and <paramref name="right"/> are null, the methods returns true;</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToRange(FoundationDB.Client.Slice)">
            <summary>Create a range that selects all tuples that are stored under the specified subspace: 'prefix\x00' &lt;= k &lt; 'prefix\xFF'</summary>
            <param name="prefix">Subspace binary prefix (that will be excluded from the range)</param>
            <returns>Range including all possible tuples starting with the specified prefix.</returns>
            <remarks>FdbTuple.ToRange(Slice.FromAscii("abc")) returns the range [ 'abc\x00', 'abc\xFF' )</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToRange(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>
            Create a range that selects all the tuples of greater length than the specified <paramref name="tuple"/>, and that start with the specified elements: packed(tuple)+'\x00' &lt;= k &lt; packed(tuple)+'\xFF'
            </summary>
            <example>FdbTuple.ToRange(FdbTuple.Create("a", "b")) includes all tuples ("a", "b", ...), but not the tuple ("a", "b") itself.</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Stringify(System.Object)">
            <summary>Converts any object into a displayble string, for logging/debugging purpose</summary>
            <param name="item">Object to stringify</param>
            <returns>String representation of the object</returns>
            <example>
            Stringify(null) => "nil"
            Stringify("hello") => "\"hello\""
            Stringify(123) => "123"
            Stringify(123.4) => "123.4"
            Stringify(true) => "true"
            Stringify(Slice) => hexa decimal string ("01 23 45 67 89 AB CD EF")
            </example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToString(System.Object[],System.Int32,System.Int32)">
            <summary>Convert a list of object into a displaying string, for loggin/debugging purpose</summary>
            <param name="items">Array containing items to stringfy</param>
            <param name="offset">Start offset of the items to convert</param>
            <param name="count">Number of items to convert</param>
            <returns>String representation of the tuple in the form "(item1, item2, ... itemN,)"</returns>
            <example>ToString(FdbTuple.Create("hello", 123, true, "world")) => "(\"hello\", 123, true, \"world\",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.ToString(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Convert a sequence of object into a displaying string, for loggin/debugging purpose</summary>
            <param name="items">Sequence of items to stringfy</param>
            <returns>String representation of the tuple in the form "(item1, item2, ... itemN,)"</returns>
            <example>ToString(FdbTuple.Create("hello", 123, true, "world")) => "(\"hello\", 123, true, \"world\",)</example>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.Splice(FoundationDB.Layers.Tuples.IFdbTuple,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Default (non-optimized) implementation of IFdbTuple.this[long?, long?]</summary>
            <param name="tuple">Tuple to slice</param>
            <param name="fromIncluded">Start offset of the section (included)</param>
            <param name="toExcluded">End offset of the section (included)</param>
            <returns>New tuple only containing items inside this section</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.StartsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Default (non-optimized) implementation for IFdbTuple.StartsWith()</summary>
            <param name="a">Larger tuple</param>
            <param name="b">Smaller tuple</param>
            <returns>True if <paramref name="a"/> starts with (or is equal to) <paramref name="b"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.EndsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Default (non-optimized) implementation for IFdbTuple.EndsWith()</summary>
            <param name="a">Larger tuple</param>
            <param name="b">Smaller tuple</param>
            <returns>True if <paramref name="a"/> starts with (or is equal to) <paramref name="b"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.CopyTo(FoundationDB.Layers.Tuples.IFdbTuple,System.Object[],System.Int32)">
            <summary>Helper to copy the content of a tuple at a specific position in an array</summary>
            <returns>Updated offset just after the last element of the copied tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.MapIndex(System.Int32,System.Int32)">
            <summary>Maps a relative index into an absolute index</summary>
            <param name="index">Relative index in the tuple (from the end if negative)</param>
            <param name="count">Size of the tuple</param>
            <returns>Absolute index from the start of the tuple, or exception if outside of the tuple</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the absolute index is outside of the tuple (&lt;0 or &gt;=<paramref name="count"/>)</exception>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuple.MapIndexBounded(System.Int32,System.Int32)">
            <summary>Maps a relative index into an absolute index</summary>
            <param name="index">Relative index in the tuple (from the end if negative)</param>
            <param name="count">Size of the tuple</param>
            <returns>Absolute index from the start of the tuple. Truncated to 0 if index is before the start of the tuple, or to <paramref name="count"/> if the index is after the end of the tuple</returns>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple.EmptyTuple">
            <summary>Empty tuple (singleton that is used as a base for other tuples)</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbKeySelector">
            <summary>Defines a selector for a key in the database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelector.None">
            <summary>Empty key selector</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelector.Key">
            <summary>Key of the selector</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelector.OrEqual">
            <summary>If true, the selected key can be equal to <see cref="F:FoundationDB.Client.FdbKeySelector.Key"/>.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbKeySelector.Offset">
            <summary>Offset of the selected key</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.#ctor(FoundationDB.Client.Slice,System.Boolean,System.Int32)">
            <summary>Creates a new selector</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.#ctor(FoundationDB.Client.IFdbKey,System.Boolean,System.Int32)">
            <summary>Creates a new selector</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.PrettyPrint(FoundationDB.Client.FdbKey.PrettyPrintMode)">
            <summary>Returns a displayable representation of the key selector</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.ToString">
            <summary>Converts the value of the current <see cref="T:FoundationDB.Client.FdbKeySelector"/> object into its equivalent string representation</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessThan(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the last key that is less than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessOrEqual(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the last key that is less than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterThan(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the first key that is greater than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterOrEqual(FoundationDB.Client.Slice)">
            <summary>Creates a key selector that will select the first key that is greater than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessThan``1(``0)">
            <summary>Creates a key selector that will select the last key that is less than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.LastLessOrEqual``1(``0)">
            <summary>Creates a key selector that will select the last key that is less than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterThan``1(``0)">
            <summary>Creates a key selector that will select the first key that is greater than <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.FirstGreaterOrEqual``1(``0)">
            <summary>Creates a key selector that will select the first key that is greater than or equal to <paramref name="key"/></summary>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.op_Addition(FoundationDB.Client.FdbKeySelector,System.Int32)">
            <summary>Add a value to the selector's offset</summary>
            <param name="selector">ex: fGE('abc')</param>
            <param name="offset">ex: 7</param>
            <returns>fGE('abc')+7</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbKeySelector.op_Subtraction(FoundationDB.Client.FdbKeySelector,System.Int32)">
            <summary>Substract a value to the selector's offset</summary>
            <param name="selector">ex: fGE('abc')</param>
            <param name="offset">ex: 7</param>
            <returns>fGE('abc')-7</returns>
        </member>
        <member name="T:FoundationDB.Client.FdbDatabase">
            <summary>FoundationDB Database</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_cluster">
            <summary>Parent cluster that owns the database.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_handler">
            <summary>Underlying handler for this database (native, dummy, memory, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_name">
            <summary>Name of the database (note: value it is the value that was passed to Connect(...) since we don't have any API to read the name from an FDB_DATABASE* handle)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_ownsCluster">
            <summary>If true, the cluster instance will be disposed at the same time as the current db instance.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_readOnly">
            <summary>If true, the database will only allow read-only transactions.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_cts">
            <summary>Global cancellation source that is cancelled when the current db instance gets disposed.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_disposed">
            <summary>Set to true when the current db instance gets disposed.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.s_transactionCounter">
            <summary>Global counters used to generate the transaction's local id (for debugging purpose)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_transactions">
            <summary>List of all "pending" transactions created from this database instance (and that have not yet been disposed)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_globalSpace">
            <summary>Global namespace used to prefix ALL keys and subspaces accessible by this database instance (default is empty)</summary>
            <remarks>This is readonly and is set when creating the database instance</remarks>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_globalSpaceCopy">
            <summary>Copy of the namespace, that is exposed to the outside.</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_defaultTimeout">
            <summary>Default Timeout value for all transactions</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_defaultRetryLimit">
            <summary>Default RetryLimit value for all transactions</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbDatabase.m_directory">
            <summary>Instance of the DirectoryLayer used by this detabase (lazy initialized)</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.#ctor(FoundationDB.Client.IFdbCluster,FoundationDB.Client.Core.IFdbDatabaseHandler,System.String,FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Directories.IFdbDirectory,System.Boolean,System.Boolean)">
            <summary>Create a new database instance</summary>
            <param name="cluster">Parent cluster</param>
            <param name="handler">Handle to the native FDB_DATABASE*</param>
            <param name="name">Name of the database</param>
            <param name="contentSubspace">Subspace of the all keys accessible by this database instance</param>
            <param name="directory">Root directory of the database instance</param>
            <param name="readOnly">If true, the database instance will only allow read-only transactions</param>
            <param name="ownsCluster">If true, the cluster instance lifetime is linked with the database instance</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.GetRootDirectory">
            <summary>When overriden in a derived class, gets a database partition that wraps the root directory of this database instance</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.BeginTransaction(FoundationDB.Client.FdbTransactionMode,System.Threading.CancellationToken,FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database</summary>
            <param name="mode">Mode of the new transaction (read-only, read-write, ...)</param>
            <param name="cancellationToken">Optional cancellation token that can abort all pending async operations started by this transaction.</param>
            <param name="context">If not null, attach the new transaction to an existing context.</param>
            <returns>New transaction instance that can read from or write to the database.</returns>
            <remarks>You MUST call Dispose() on the transaction when you are done with it. You SHOULD wrap it in a 'using' statement to ensure that it is disposed in all cases.</remarks>
            <example>
            using(var tr = db.BeginTransaction(CancellationToken.None))
            {
            	tr.Set(Slice.FromString("Hello"), Slice.FromString("World"));
            	tr.Clear(Slice.FromString("OldValue"));
            	await tr.CommitAsync();
            }</example>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.CreateNewTransaction(FoundationDB.Client.FdbOperationContext)">
            <summary>Start a new transaction on this database, with an optional context</summary>
            <param name="context">Optional context in which the transaction will run</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.RegisterTransaction(FoundationDB.Client.FdbTransaction)">
            <summary>Add a new transaction to the list of tracked transactions</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.UnregisterTransaction(FoundationDB.Client.FdbTransaction)">
            <summary>Remove a transaction from the list of tracked transactions</summary>
            <param name="transaction"></param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadAsync(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-only transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-only transaction on each retry.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadAsync``1(System.Func{FoundationDB.Client.IFdbReadOnlyTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-only transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-only transaction on each retry. The result of the task will also be the result of the transactional.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.WriteAsync(System.Action{FoundationDB.Client.IFdbTransaction},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a write-only transaction context, with retry logic.</summary>
            <param name="handler">Lambda function that is passed a new read-write transaction on each retry. It should only call non-async methods, such as Set, Clear or any atomic operation.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.WriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a write-only transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-write transaction on each retry.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadWriteAsync(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-write transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-write transaction on each retry.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ReadWriteAsync``1(System.Func{FoundationDB.Client.IFdbTransaction,System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>Runs a transactional lambda function against this database, inside a read-write transaction context, with retry logic.</summary>
            <param name="asyncHandler">Asynchronous lambda function that is passed a new read-write transaction on each retry. The result of the task will also be the result of the transactional.</param>
            <param name="cancellationToken">Optional cancellation token that will be passed to the transaction context, and that can also be used to abort the retry loop.</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption)">
            <summary>Set a parameter-less option on this database</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.String)">
            <summary>Set an option on this database that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.SetOption(FoundationDB.Client.FdbDatabaseOption,System.Int64)">
            <summary>Set an option on this database that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ChangeRoot(FoundationDB.Client.FdbSubspace,FoundationDB.Layers.Directories.IFdbDirectory,System.Boolean)">
            <summary>Change the current global namespace.</summary>
            <remarks>Do NOT call this, unless you know exactly what you are doing !</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.ValidateKey(FoundationDB.Client.IFdbDatabase,FoundationDB.Client.Slice,System.Boolean,System.Boolean,System.Exception@)">
            <summary>Checks that a key is valid, and is inside the global key space of this database</summary>
            <param name="key">Key to verify</param>
            <param name="endExclusive">If true, the key is allowed to be one past the maximum key allowed by the global namespace</param>
            <returns>An exception if the key is outside of the allowed key space of this database</returns>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.IsSystemKey(FoundationDB.Client.Slice)">
            <summary>Returns true if the key is inside the system key space (starts with '\xFF')</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbDatabase.EnsureValueIsValid(FoundationDB.Client.Slice)">
            <summary>Ensures that a serialized value is valid</summary>
            <remarks>Throws an exception if the value is null, or exceeds the maximum allowed size (Fdb.MaxValueSize)</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Cluster">
            <summary>Cluster where the database is located</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Name">
            <summary>Name of the database</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Cancellation">
            <summary>Returns a cancellation token that is linked with the lifetime of this database instance</summary>
            <remarks>The token will be cancelled if the database instance is disposed</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.IsReadOnly">
            <summary>If true, this database instance will only allow starting read-only transactions.</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.Directory">
            <summary>Root directory of this database instance</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.GlobalSpace">
            <summary>Returns the global namespace used by this database instance</summary>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.DefaultTimeout">
            <summary>Default Timeout value (in milliseconds) for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="P:FoundationDB.Client.FdbDatabase.DefaultRetryLimit">
            <summary>Default Retry Limit value for all transactions created from this database instance.</summary>
            <remarks>Only effective for future transactions</remarks>
        </member>
        <member name="T:FoundationDB.Client.FdbCluster">
            <summary>FoundationDB Cluster</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbCluster.m_handler">
            <summary>Underlying handler for this cluster (native, dummy, memory, ...)</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbCluster.m_path">
            <summary>Path to the cluster file userd by this connection</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbCluster.m_disposed">
            <summary>Set to true when the current db instance gets disposed.</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.Dispose">
            <summary>Close the connection with the FoundationDB cluster</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.OpenDatabaseAsync(System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster, configured to only access a specific subspace of keys</summary>
            <param name="databaseName">Name of the database. Must be 'DB' (as of Beta 2)</param>
            <param name="subspace">Subspace of keys that will be accessed.</param>
            <param name="readOnly">If true, the database will only allow read operations.</param>
            <param name="cancellationToken">Cancellation Token (optionnal) for the connect operation</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.InvalidOperationException">If <paramref name="databaseName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
            <remarks>Any attempt to use a key outside the specified subspace will throw an exception</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.OpenDatabaseInternalAsync(System.String,FoundationDB.Client.FdbSubspace,System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>Opens a database on this cluster</summary>
            <param name="databaseName">Name of the database. Must be 'DB'</param>
            <param name="subspace">Subspace of keys that will be accessed.</param>
            <param name="readOnly">If true, the database will only allow read operations.</param>
            <param name="ownsCluster">If true, the database will dispose this cluster when it is disposed.</param>
            <param name="cancellationToken">Cancellation Token</param>
            <returns>Task that will return an FdbDatabase, or an exception</returns>
            <exception cref="T:System.InvalidOperationException">If <paramref name="databaseName"/> is anything other than 'DB'</exception>
            <exception cref="T:System.OperationCanceledException">If the token <paramref name="cancellationToken"/> is cancelled</exception>
            <remarks>As of Beta2, the only supported database name is 'DB'</remarks>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.SetOption(FoundationDB.Client.FdbClusterOption)">
            <summary>Set an option on this cluster that does not take any parameter</summary>
            <param name="option">Option to set</param>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.SetOption(FoundationDB.Client.FdbClusterOption,System.String)">
            <summary>Set an option on this cluster that takes a string value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter (can be null)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbCluster.SetOption(FoundationDB.Client.FdbClusterOption,System.Int64)">
            <summary>Set an option on this cluster that takes an integer value</summary>
            <param name="option">Option to set</param>
            <param name="value">Value of the parameter</param>
        </member>
        <member name="P:FoundationDB.Client.FdbCluster.Path">
            <summary>Path to the cluster file used by this connection, or null if the default cluster file is being used</summary>
        </member>
        <member name="T:FoundationDB.Client.FdbFutureSingle`1">
            <summary>FDBFuture wrapper</summary>
            <typeparam name="T">Type of result</typeparam>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.m_handle">
            <summary>Value of the 'FDBFuture*'</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.m_resultSelector">
            <summary>Lambda used to extract the result of this FDBFuture</summary>
        </member>
        <member name="F:FoundationDB.Client.FdbFutureSingle`1.CallbackHandler">
            <summary>Cached delegate of the future completion callback handler</summary>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureSingle`1.FutureCompletionCallback(System.IntPtr,System.IntPtr)">
            <summary>Handler called when a FDBFuture becomes ready</summary>
            <param name="futureHandle">Handle on the future that became ready</param>
            <param name="parameter">Paramter to the callback (unused)</param>
        </member>
        <member name="M:FoundationDB.Client.FdbFutureSingle`1.HandleCompletion(System.Boolean)">
            <summary>Update the Task with the state of a ready Future</summary>
            <param name="fromCallback">If true, we are called from the network thread</param>
            <returns>True if we got a result, or false in case of error (or invalid state)</returns>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncMode">
            <summary>
            Defines the intent of a consumer of an async iterator
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Default">
            <summary>
            Use the default settings. The provider will make no attempt at optimizing the query.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Iterator">
            <summary>
            The query will be consumed by chunks and may be aborted at any point. The provider will produce small chunks of data for the first few reads but should still be efficient if the caller consume all the sequence.
            </summary>
            
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.All">
            <summary>
            The query will consume all the items in the source. The provider will produce large chunks of data immediately, and reduce the number of pages needed to consume the sequence.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Head">
            <summary>
            The query will consume the first element (or a very small fraction) of the source. The provider will only produce data in small chunks and expect the caller to abort after one or two iterations. This can also be used to reduce the latency of the first result.
            </summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncMode.Bulk">
            <summary>
            The query will consume all (or most of) the items of a very large sequence of data. The provider will use the appropriate page size in ordre to optimize the bandwith.
            </summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbTakeWhileAsyncIterator`1">
            <summary>Reads an async sequence of items until a condition becomes false</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncFilter`2.m_source">
            <summary>Source sequence (when in iterable mode)</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncFilter`2.m_iterator">
            <summary>Active iterator on the source (when in iterator mode)</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbParallelQueryOptions">
            <summary>Container class for all settings relative to parallel operations</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbParallelQueryOptions.MaxConcurrency">
            <summary>Maximum number of concurrent async tasks that can run in parallel</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbParallelQueryOptions.Scheduler">
            <summary>Task Scheduler to use when executing async tasks</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncIteratorPump`1">
            <summary>Pump that repeatedly calls MoveNext on an iterator and tries to publish the values in a Producer/Consumer queue</summary>
            <typeparam name="TInput"></typeparam>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncIteratorPump`1.PumpAsync(System.Threading.CancellationToken)">
            <summary>Run the pump until the inner iterator is done, an error occurs, or the cancellation token is fired</summary>
        </member>
        <member name="P:FoundationDB.Linq.FdbAsyncIteratorPump`1.IsCompleted">
            <summary>Returns true if the pump has completed (with success or failure)</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncCancelableMutex">
            <summary>Implements a async mutex that supports cancellation</summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncCancelableMutex.CancellationHandler(System.Object)">
            <summary>Handler called if the CancellationToken linked to a waiter is signaled</summary>
            <param name="state"></param>
        </member>
        <member name="T:FoundationDB.Async.AsyncHelpers">
            <summary>
            Helper methods for creating and manipulating async sequences.
            </summary>
        </member>
        <member name="M:FoundationDB.Async.AsyncHelpers.PumpToListAsync``1(FoundationDB.Async.IAsyncSource{``0},System.Threading.CancellationToken)">
            <summary>Pump the content of a source into a list</summary>
        </member>
        <member name="T:FoundationDB.Async.AsyncTransformQueue`2">
            <summary>Implements an async queue that asynchronously transform items, outputing them in arrival order, while throttling the producer</summary>
            <typeparam name="TInput">Type of the input elements (from the inner async iterator)</typeparam>
            <typeparam name="TOutput">Type of the output elements (produced by an async lambda)</typeparam>
        </member>
        <member name="T:FoundationDB.Async.IAsyncBuffer`2">
            <summary>Defines a producer/consumer buffer queue that can hold several items before blocking the producer</summary>
            <typeparam name="TInput">Type of elements entering the buffer</typeparam>
            <typeparam name="TOutput">Type of elements exiting the buffer. Can be different from <typeparamref name="TInput"/> if the buffer also transforms the elements.</typeparam>
        </member>
        <member name="M:FoundationDB.Async.IAsyncBuffer`2.DrainAsync">
            <summary>Wait for all the consumers to drain the queue</summary>
            <returns>Task that completes when all consumers have drained the queue</returns>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.Count">
            <summary>Returns the current number of items in the buffer</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.Capacity">
            <summary>Returns the maximum capacity of the buffer</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.IsProducerBlocked">
            <summary>Returns true if the producer is blocked (queue is full)</summary>
        </member>
        <member name="P:FoundationDB.Async.IAsyncBuffer`2.IsConsumerBlocked">
            <summary>Returns true if the consumer is blocked (queue is empty)</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.Count">
            <summary>Returns the current number of items in the queue</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.Capacity">
            <summary>Returns the maximum capacity of the queue</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.IsConsumerBlocked">
            <summary>Returns true if the producer is blocked (queue is full)</summary>
        </member>
        <member name="P:FoundationDB.Async.AsyncTransformQueue`2.IsProducerBlocked">
            <summary>Returns true if the consumer is blocked (queue is empty)</summary>
        </member>
        <member name="T:FoundationDB.Async.Maybe`1">
            <summary>Either has a value, nothing, or an exception</summary>
            <typeparam name="T">Type of the value</typeparam>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.HasValue">
            <summary>If true, there is a value. If false, either no value or an exception</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.Value">
            <summary>If HasValue is true, holds the value. Else, contains default(T)</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.m_errorContainer">
            <summary>If HasValue is false optinally holds an error that was captured</summary>
        </member>
        <member name="F:FoundationDB.Async.Maybe`1.EmptyTask">
            <summary>Cached completed Task that always return an empty value</summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe`1.GetValueOrDefault">
            <summary>Returns the stored value, of the default value for the type if it was empty</summary>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Async.Maybe`1.ThrowIfFailed">
            <summary>Rethrows any captured error, if there was one.</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.Empty">
            <summary>Returns an empty value</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.IsEmpty">
            <summary>If true, then there is no value and no error</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.HasFailed">
            <summary>If true then there was an error captured</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.Error">
            <summary>Return the captured Error, or null if there wasn't any</summary>
        </member>
        <member name="P:FoundationDB.Async.Maybe`1.CapturedError">
            <summary>Return the captured error context, or null if there wasn't any</summary>
        </member>
        <member name="T:FoundationDB.Async.Maybe">
            <summary>
            Helper methods for creating <see cref="T:FoundationDB.Async.Maybe`1"/> instances
            </summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Return``1(``0)">
            <summary>Wraps a value into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Nothing``1">
            <summary>Returns an empty <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Error``1(System.Exception)">
            <summary>Capture an exception into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Error``1(System.Runtime.ExceptionServices.ExceptionDispatchInfo)">
            <summary>Capture an exception into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(``0,System.Func{``0,``1})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(``0,System.Func{``0,FoundationDB.Async.Maybe{``1}})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(FoundationDB.Async.Maybe{``0},System.Func{``0,``1})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Apply``2(FoundationDB.Async.Maybe{``0},System.Func{``0,FoundationDB.Async.Maybe{``1}})">
            <summary>Immediately apply a function to a value, and capture the result into a <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.FromTask``1(System.Threading.Tasks.Task{``0})">
            <summary>Convert a completed <see cref="T:System.Threading.Tasks.Task`1"/> into an equivalent <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.FromTask``1(System.Threading.Tasks.Task{FoundationDB.Async.Maybe{``0}})">
            <summary>Convert a completed <see cref="T:System.Threading.Tasks.Task`1"/> into an equivalent <see cref="T:FoundationDB.Async.Maybe`1"/></summary>
        </member>
        <member name="M:FoundationDB.Async.Maybe.Unwrap``1(System.Threading.Tasks.Task{FoundationDB.Async.Maybe{``0}})">
            <summary>Streamline a potentially failed Task&lt;Maybe&lt;T&gt;&gt; into a version that capture the error into the <see cref="T:FoundationDB.Async.Maybe`1"/> itself</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2">
            <summary>[EXPERIMENTAL] Iterates over an async sequence of items, kick off an async task in parallel, and returning the results in order</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.DefaultMaxConcurrency">
            <summary>Default max concurrency when doing batch queries</summary>
            <remarks>TODO: this is a placeholder value !</remarks>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_pump">
            <summary>Pump that reads values from the inner iterator</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_pumpTask">
            <summary>Inner pump task</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbParallelSelectAsyncIterator`2.m_processingQueue">
            <summary>Queue that holds items that are being processed</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable">
            <summary>Provides a set of static methods for querying objects that implement <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/>.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Create``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{FoundationDB.Linq.IFdbAsyncEnumerator{``0},FoundationDB.Linq.IFdbAsyncEnumerator{``1}})">
            <summary>Create a new async sequence that will transform an inner async sequence</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
            <param name="source">Source async sequence that will be wrapped</param>
            <param name="factory">Factory method called when the outer sequence starts iterating. Must return an async enumerator</param>
            <returns>New async sequence</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Create``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Collections.Generic.IEnumerator{``0},FoundationDB.Linq.IFdbAsyncEnumerator{``1}})">
            <summary>Create a new async sequence that will transform an inner sequence</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
            <param name="source">Source sequence that will be wrapped</param>
            <param name="factory">Factory method called when the outer sequence starts iterating. Must return an async enumerator</param>
            <returns>New async sequence</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Create``1(System.Func{System.Object,FoundationDB.Linq.IFdbAsyncEnumerator{``0}},System.Object)">
            <summary>Create a new async sequence from a factory method</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Action{``0},System.Threading.CancellationToken)">
            <summary>Immediately execute an action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="mode">If different than default, can be used to optimise the way the source will produce the items</param>
            <param name="action">Action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Immediately execute an asunc action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="mode">Expected execution mode of the query</param>
            <param name="action">Asynchronous action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Run``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},FoundationDB.Linq.FdbAsyncMode,System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Immediately execute an asunc action on each element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="mode">Expected execution mode of the query</param>
            <param name="action">Asynchronous action to perform on each element as it arrives</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Number of items that have been processed</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Head``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Boolean,System.Boolean,System.Threading.CancellationToken)">
            <summary>Helper async method to get the first element of an async sequence</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
            <param name="source">Source async sequence</param>
            <param name="single">If true, the sequence must contain at most one element</param>
            <param name="orDefault">When the sequence is empty: If true then returns the default value for the type. Otherwise, throws an exception</param>
            <param name="ct">Cancellation token that can be used to cancel the operation</param>
            <returns>Value of the first element of the <param ref="source"/> sequence, or the default value, or an exception (depending on <paramref name="single"/> and <paramref name="orDefault"/></returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Empty``1">
            <summary>Returns an empty async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Singleton``1(``0)">
            <summary>Returns an async sequence that only holds one item</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToAsyncEnumerable``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Apply an async lambda to a sequence of elements to transform it into an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToAsyncEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Apply an async lambda to a sequence of elements to transform it into an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FromTask``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>Wraps an async lambda into an async sequence that will return the result of the lambda</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Buffered``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Split a sequence of items into several batches</summary>
            <typeparam name="T">Type of the elemenst in <paramref name="source"/></typeparam>
            <param name="source">Source sequence</param>
            <param name="batchSize">Maximum size of each batch</param>
            <returns>Sequence of batches, whose size will always we <paramref name="batchSize"/>, except for the last batch that will only hold the remaning items. If the source is empty, an empty sequence is returned.</returns>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> and flattens the resulting sequences into one async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectMany``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Collections.Generic.IEnumerable{``1}}},System.Func{``0,``1,``2})">
            <summary>Projects each element of an async sequence to an <see cref="T:FoundationDB.Linq.IFdbAsyncEnumerable`1"/> flattens the resulting sequences into one async sequence, and invokes a result selector function on each element therein.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,``1})">
            <summary>Projects each element of an async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Projects each element of an async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Select``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}})">
            <summary>Projects each element of an async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Where``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{System.Boolean}})">
            <summary>Filters an async sequence of values based on a predicate.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Take``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Int32)">
            <summary>Returns a specified number of contiguous elements from the start of an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.TakeWhile``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Returns elements from an async sequence as long as a specified condition is true, and then skips the remaining elements.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.Skip``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Int32)">
            <summary>Skips the first elements of an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SelectAsync``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task{``1}},FoundationDB.Linq.FdbParallelQueryOptions)">
            <summary>Projects each element of an async sequence into a new form.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Action{``0},System.Threading.CancellationToken)">
            <summary>Execute an action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Execute an async action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ForEachAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Threading.CancellationToken,System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>Execute an async action for each element of an async sequence</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToListAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Create a list from an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToArrayAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Create an array from an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToArrayAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Int32,System.Threading.CancellationToken)">
            <summary>Create an array from an async sequence, knowing a rough estimation of the number of elements.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToDictionaryAsync``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,``1},System.Collections.Generic.IEqualityComparer{``1},System.Threading.CancellationToken)">
            <summary>Creates a Dictionary from an async sequence according to a specified key selector function and key comparer.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToDictionaryAsync``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2},System.Collections.Generic.IEqualityComparer{``1},System.Threading.CancellationToken)">
            <summary>Creates a Dictionary from an async sequence according to a specified key selector function, a comparer, and an element selector function.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.ToDictionaryAsync``2(FoundationDB.Linq.IFdbAsyncEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}},System.Collections.Generic.IEqualityComparer{``0},System.Threading.CancellationToken)">
            <summary>Creates a Dictionary from an async sequence of pairs of keys and values.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AggregateAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,``0,``0},System.Threading.CancellationToken)">
            <summary>Applies an accumulator function over an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AggregateAsync``2(FoundationDB.Linq.IFdbAsyncEnumerable{``0},``1,System.Func{``1,``0,``1},System.Threading.CancellationToken)">
            <summary>Applies an accumulator function over an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AggregateAsync``3(FoundationDB.Linq.IFdbAsyncEnumerable{``0},``1,System.Func{``1,``0,``1},System.Func{``1,``2},System.Threading.CancellationToken)">
            <summary>Applies an accumulator function over an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FirstAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first element of an async sequence, or an exception if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.FirstOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first element of an async sequence, or the default value for the type if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SingleAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first and only element of an async sequence, or an exception if it is empty or have two or more elements</summary>
            <remarks>Will need to call MoveNext at least twice to ensure that there is no second element.</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SingleOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the first and only element of an async sequence, the default value for the type if it is empty, or an exception if it has two or more elements</summary>
            <remarks>Will need to call MoveNext at least twice to ensure that there is no second element.</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.LastAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the last element of an async sequence, or an exception if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.LastOrDefaultAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the last element of an async sequence, or the default value for the type if it is empty</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.CountAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Returns the number of elements in an async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.CountAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Returns a number that represents how many elements in the specified async sequence satisfy a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SumAsync(FoundationDB.Linq.IFdbAsyncEnumerable{System.UInt64},System.Threading.CancellationToken)">
            <summary>Returns the sum of all elements in the specified async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SumAsync(FoundationDB.Linq.IFdbAsyncEnumerable{System.UInt64},System.Func{System.UInt64,System.Boolean},System.Threading.CancellationToken)">
            <summary>Returns the sum of all elements in the specified async sequence that satisfy a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SumAsync(FoundationDB.Linq.IFdbAsyncEnumerable{System.Int64},System.Threading.CancellationToken)">
            <summary>Returns the sum of all elements in the specified async sequence.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.SumAsync(FoundationDB.Linq.IFdbAsyncEnumerable{System.Int64},System.Func{System.Int64,System.Boolean},System.Threading.CancellationToken)">
            <summary>Returns the sum of all elements in the specified async sequence that satisfy a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AnyAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Determines whether an async sequence contains any elements.</summary>
            <remarks>This is the logical equivalent to "source.Count() > 0" but can be better optimized by some providers</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.AnyAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Determines whether any element of an async sequence satisfies a condition.</summary>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.NoneAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Threading.CancellationToken)">
            <summary>Determines wether an async sequence contains no elements at all.</summary>
            <remarks>This is the logical equivalent to "source.Count() == 0" or "!source.Any()" but can be better optimized by some providers</remarks>
        </member>
        <member name="M:FoundationDB.Linq.FdbAsyncEnumerable.NoneAsync``1(FoundationDB.Linq.IFdbAsyncEnumerable{``0},System.Func{``0,System.Boolean},System.Threading.CancellationToken)">
            <summary>Determines whether none of the elements of an async sequence satisfies a condition.</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EnumerableIterator`2">
            <summary>Iterates over a sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EnumerableSequence`2">
            <summary>Wraps a sequence of items into an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.EmptySequence`1">
            <summary>An empty sequence</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1">
            <summary>Small buffer that keeps a list of chunks that are larger and larger</summary>
            <typeparam name="T">Type of elements stored in the buffer</typeparam>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.DefaultCapacity">
            <summary>Default intial capacity, if not specified</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.MaxChunkSize">
            <summary>Maximum size of a chunk</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Count">
            <summary>Number of items in the buffer</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Index">
            <summary>Index in the current chunk</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Chunks">
            <summary>List of chunks</summary>
        </member>
        <member name="F:FoundationDB.Linq.FdbAsyncEnumerable.Buffer`1.Current">
            <summary>Current (and last) chunk</summary>
        </member>
        <member name="T:FoundationDB.Linq.FdbSelectManyAsyncIterator`2">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbSelectManyAsyncIterator`3">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TCollection">Type of the elements of the sequences produced from each <typeparamref name="TSource"/> elements</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbWhereAsyncIterator`1">
            <summary>Filters an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbWhereSelectAsyncIterator`2">
            <summary>Iterates over an async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Linq.FdbAsyncSequence`2">
            <summary>Wraps an async sequence of items into another async sequence of items</summary>
            <typeparam name="TSource">Type of elements of the inner async sequence</typeparam>
            <typeparam name="TResult">Type of elements of the outer async sequence</typeparam>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleParser">
            <summary>Helper class that contains low-level encoders for the tuple binary format</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNil(FoundationDB.Client.SliceWriter@)">
            <summary>Writes a null value at the end, and advance the cursor</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt8(FoundationDB.Client.SliceWriter@,System.Byte)">
            <summary>Writes an UInt8 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Unsigned BYTE, 32 bits</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt32(FoundationDB.Client.SliceWriter@,System.Int32)">
            <summary>Writes an Int32 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed DWORD, 32 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteInt64(FoundationDB.Client.SliceWriter@,System.Int64)">
            <summary>Writes an Int64 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed QWORD, 64 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUInt32(FoundationDB.Client.SliceWriter@,System.UInt32)">
            <summary>Writes an UInt32 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed DWORD, 32 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUInt64(FoundationDB.Client.SliceWriter@,System.UInt64)">
            <summary>Writes an UInt64 at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Signed QWORD, 64 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteSingle(FoundationDB.Client.SliceWriter@,System.Single)">
            <summary>Writes an Single at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">IEEE Floating point, 32 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteDouble(FoundationDB.Client.SliceWriter@,System.Double)">
            <summary>Writes an Double at the end, and advance the cursor</summary>
            <param name="writer">Target buffer</param>
            <param name="value">IEEE Floating point, 64 bits, High Endian</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.SliceWriter@,System.Byte[])">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteString(FoundationDB.Client.SliceWriter@,System.String)">
            <summary>Writes a string encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteChars(FoundationDB.Client.SliceWriter@,System.Char[],System.Int32,System.Int32)">
            <summary>Writes a char array encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteChar(FoundationDB.Client.SliceWriter@,System.Char)">
            <summary>Writes a char encoded in UTF-8</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.SliceWriter@,System.Byte[],System.Int32,System.Int32)">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteBytes(FoundationDB.Client.SliceWriter@,System.ArraySegment{System.Byte})">
            <summary>Writes a binary string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNulEscapedBytes(FoundationDB.Client.SliceWriter@,System.Byte,System.Byte[],System.Int32,System.Int32)">
            <summary>Writes a buffer with all instances of 0 escaped as '00 FF'</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteNulEscapedBytes(FoundationDB.Client.SliceWriter@,System.Byte,System.Byte[])">
            <summary>Writes a buffer with all instances of 0 escaped as '00 FF'</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteGuid(FoundationDB.Client.SliceWriter@,System.Guid)">
            <summary>Writes a RFC 4122 encoded 16-byte Microsoft GUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.WriteUuid(FoundationDB.Client.SliceWriter@,FoundationDB.Client.Uuid)">
            <summary>Writes a RFC 4122 encoded 128-bit UUID</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleParser.MultiplyDeBruijnBitPosition">
            <summary>Lookup table used to compute the index of the most significant bit</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.UInt32)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <remarks>Note: will return 1 even for <param name="v"/> == 0</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.Int64)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <remarks>Note: will return 1 even for <param name="v"/> == 0</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.NumberOfBytes(System.UInt64)">
            <summary>Returns the minimum number of bytes needed to represent a value</summary>
            <returns>Note: will return 1 even for <param name="v"/> == 0</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleParser.MostSignificantBit(System.UInt32)">
            <summary>Returns the position of the most significant bit (0-based) in a 32-bit integer</summary>
            <param name="v">32-bit integer</param>
            <returns>Index of the most significant bit (0-based)</returns>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage
            </summary>
            <example><code>
            [CanBeNull] public object Test() { return null; }
            public void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>
            </summary>
            <example><code>
            [NotNull] public object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            public void ShowError(string message, params object[] args) { /* do something */ }
            public void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>
            </summary>
            <example><code>
            public void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methos doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null, and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            class UsesNoEquality {
              public void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled
            when the invoked method is on stack. If the parameter is a delegate,
            indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated
            while the method is executed
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>
            </summary>
            <example><code>
            [Pure] private int Multiply(int x, int y) { return x * y; }
            public void Foo() {
              const int a = 2, b = 2;
              Multiply(a, b); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:FoundationDB.Client.Utils.DebugCounters">
            <summary>Simple debug counters container that is used to troubleshoot alloc/free problems...</summary>
        </member>
        <member name="T:FoundationDB.Client.KeyValueEncoders">
            <summary>Helper class for all key/value encoders</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.EncodeRange``1(FoundationDB.Client.IKeyEncoder{``0},``0[])">
            <summary>Convert an array of <typeparamref name="T"/>s into an array of slices, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.EncodeRange``1(FoundationDB.Client.IKeyEncoder{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Transform a sequence of <typeparamref name="T"/>s into a sequence of slices, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IKeyEncoder{``0},FoundationDB.Client.Slice[])">
            <summary>Convert an array of slices back into an array of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IKeyEncoder{``0},System.Collections.Generic.List{FoundationDB.Client.Slice})">
            <summary>Convert an array of slices back into an array of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IKeyEncoder{``0},System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Transform a sequence of slices back into a sequence of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Head``2(FoundationDB.Client.ICompositeKeyEncoder{``0,``1})">
            <summary>Returns a partial encoder that will only encode the first element</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Head``3(FoundationDB.Client.ICompositeKeyEncoder{``0,``1,``2})">
            <summary>Returns a partial encoder that will only encode the first element</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Pair``3(FoundationDB.Client.ICompositeKeyEncoder{``0,``1,``2})">
            <summary>Returns a partial encoder that will only encode the first and second elements</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.EncodeRange``1(FoundationDB.Client.IValueEncoder{``0},``0[])">
            <summary>Convert an array of <typeparamref name="T"/>s into an array of slices, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.EncodeRange``1(FoundationDB.Client.IValueEncoder{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>Transform a sequence of <typeparamref name="T"/>s into a sequence of slices, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IValueEncoder{``0},FoundationDB.Client.Slice[])">
            <summary>Convert an array of slices back into an array of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IValueEncoder{``0},System.Collections.Generic.List{FoundationDB.Client.Slice})">
            <summary>Convert an array of slices back into an array of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.DecodeRange``1(FoundationDB.Client.IValueEncoder{``0},System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Transform a sequence of slices back into a sequence of <typeparamref name="T"/>s, using a serializer (or the default serializer if none is provided)</summary>
        </member>
        <member name="T:FoundationDB.Client.KeyValueEncoders.Ordered">
            <summary>Encoders that produce lexicographically ordered slices, suitable for use as keys</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Ordered.Bind``1(FoundationDB.Client.IOrderedTypeCodec{``0})">
            <summary>Create a simple encoder from a codec</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Ordered.Bind``2(FoundationDB.Client.IOrderedTypeCodec{``0},FoundationDB.Client.IOrderedTypeCodec{``1})">
            <summary>Create a composite encoder from a pair of codecs</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Ordered.Bind``3(FoundationDB.Client.IOrderedTypeCodec{``0},FoundationDB.Client.IOrderedTypeCodec{``1},FoundationDB.Client.IOrderedTypeCodec{``2})">
            <summary>Create a composite encoder from a triplet of codecs</summary>
        </member>
        <member name="T:FoundationDB.Client.KeyValueEncoders.Unordered">
            <summary>Encoders that produce compact but unordered slices, suitable for use as values, or unordered keys</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Unordered.Bind``1(FoundationDB.Client.IUnorderedTypeCodec{``0})">
            <summary>Create a simple encoder from a codec</summary>
        </member>
        <member name="M:FoundationDB.Client.KeyValueEncoders.Values.Bind``1(FoundationDB.Client.IUnorderedTypeCodec{``0})">
            <summary>Create a simple encoder from a codec</summary>
        </member>
        <member name="T:FoundationDB.Client.ISliceSerializable">
            <summary>Allows an object to control the way it is packed or unpacked</summary>
        </member>
        <member name="M:FoundationDB.Client.ISliceSerializable.ToSlice">
            <summary>Return the packed representation of this instance</summary>
        </member>
        <member name="M:FoundationDB.Client.ISliceSerializable.FromSlice(FoundationDB.Client.Slice)">
            <summary>Load a packed representation into a newly created instance</summary>
        </member>
        <member name="T:FoundationDB.Client.SlicePairComparer">
            <summary>Performs optimized equality and comparison checks on key/value pairs of <see cref="T:FoundationDB.Client.Slice"/></summary>
        </member>
        <member name="F:FoundationDB.Client.SlicePairComparer.Default">
            <summary>Compare both keys and values</summary>
        </member>
        <member name="F:FoundationDB.Client.SlicePairComparer.KeyOnly">
            <summary>Compare only the key of the pair</summary>
        </member>
        <member name="F:FoundationDB.Client.SlicePairComparer.ValueOnly">
            <summary>Compare only the value of the pair</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.ThrowMalformedSlice(FoundationDB.Client.Slice)">
            <summary>Reject an invalid slice by throw an error with the appropriate diagnostic message.</summary>
            <param name="slice">Slice that is being naugthy</param>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.ThrowMalformedBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Reject an invalid slice by throw an error with the appropriate diagnostic message.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.Align(System.Int32)">
            <summary>Round a size to a multiple of 16</summary>
            <param name="size">Minimum size required</param>
            <returns>Size rounded up to the next multiple of 16</returns>
            <exception cref="T:System.OverflowException">If the rounded size overflows over 2 GB</exception>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.NextPowerOfTwo(System.Int32)">
            <summary>Round a number to the next power of 2</summary>
            <param name="x">Positive integer that will be rounded up (if not already a power of 2)</param>
            <returns>Smallest power of 2 that is greater then or equal to <paramref name="x"/></returns>
            <remarks>Will return 1 for <paramref name="x"/> = 0 (because 0 is not a power 2 !), and will throws for <paramref name="x"/> &lt; 0</remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="x"/> is a negative number</exception>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.ComputeHashCode(System.Byte[],System.Int32,System.Int32)">
            <summary>Compute the hash code of a byte segment</summary>
            <param name="bytes">Buffer</param>
            <param name="offset">Offset of the start of the segment in the buffer</param>
            <param name="count">Number of bytes in the segment</param>
            <returns>A 32-bit signed hash code calculated from all the bytes in the segment.</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.ComputeHashCodeUnsafe(System.Byte[],System.Int32,System.Int32)">
            <summary>Compute the hash code of a byte segment, without validating the arguments</summary>
            <param name="bytes">Buffer</param>
            <param name="offset">Offset of the start of the segment in the buffer</param>
            <param name="count">Number of bytes in the segment</param>
            <returns>A 32-bit signed hash code calculated from all the bytes in the segment.</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.SameBytes(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments for equality</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="count">Number of bytes to compare</param>
            <returns>true if all bytes are the same in both segments</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.SameBytesUnsafe(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments for equality, without validating the arguments</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="count">Number of bytes to compare</param>
            <returns>true if all bytes are the same in both segments</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CompareBytes(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments lexicographically</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="leftCount">Number of bytes in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="rightCount">Number of bytes in right buffer</param>
            <returns>Returns zero if segments are identical (same bytes), a negative value if left is lexicographically less than right, or a positive value if left is lexicographically greater than right</returns>
            <remarks>The comparison algorithm respect the following:
            * "A" &lt; "B"
            * "A" &lt; "AA"
            * "AA" &lt; "B"</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CompareBytesUnsafe(System.Byte[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Compare two byte segments lexicographically, without validating the arguments</summary>
            <param name="left">Left buffer</param>
            <param name="leftOffset">Start offset in left buffer</param>
            <param name="leftCount">Number of bytes in left buffer</param>
            <param name="right">Right buffer</param>
            <param name="rightOffset">Start offset in right buffer</param>
            <param name="rightCount">Number of bytes in right buffer</param>
            <returns>Returns zero if segments are identical (same bytes), a negative value if left is lexicographically less than right, or a positive value if left is lexicographically greater than right</returns>
            <remarks>The comparison algorithm respect the following:
            * "A" &lt; "B"
            * "A" &lt; "AA"
            * "AA" &lt; "B"</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CopyBytes(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Copy the content of a byte segment into another. CAUTION: The arguments are NOT in the same order as Buffer.BlockCopy() or Array.Copy() !</summary>
            <param name="dst">Destination buffer</param>
            <param name="dstOffset">Offset in destination buffer</param>
            <param name="src">Source buffer</param>
            <param name="srcOffset">Offset in source buffer</param>
            <param name="count">Number of bytes to copy</param>
            <remarks>CAUTION: THE ARGUMENTS ARE REVERSED! They are in the same order as memcpy() and memmove(), with destination first, and source second!</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CopyBytesUnsafe(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>Copy the content of a byte segment into another, without validating the arguments. CAUTION: The arguments are NOT in the same order as Buffer.BlockCopy() or Array.Copy() !</summary>
            <param name="dst">Destination buffer</param>
            <param name="dstOffset">Offset in destination buffer</param>
            <param name="src">Source buffer</param>
            <param name="srcOffset">Offset in source buffer</param>
            <param name="count">Number of bytes to copy</param>
            <remarks>CAUTION: THE ARGUMENTS ARE REVERSED! They are in the same order as memcpy() and memmove(), with destination first, and source second!</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CopyBytesUnsafe(System.Byte[],System.Int32,System.Byte*,System.Int32)">
            <summary>Copy the content of a native byte segment into a managed segment, without validating the arguments.</summary>
            <param name="dst">Destination buffer</param>
            <param name="dstOffset">Offset in destination buffer</param>
            <param name="src">Point to the source buffer</param>
            <param name="count">Number of bytes to copy</param>
            <remarks>CAUTION: THE ARGUMENTS ARE REVERSED! They are in the same order as memcpy() and memmove(), with destination first, and source second!</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.MoveMemoryUnsafe(System.Byte*,System.Byte*,System.Int32)">
            <summary>Dangerously copy native memory from one location to another</summary>
            <param name="dest">Where to copy the bytes</param>
            <param name="src">Where to read the bytes</param>
            <param name="count">Number of bytes to copy</param>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.CompareMemoryUnsafe(System.Byte*,System.Byte*,System.Int32)">
            <summary>Returns the offset of the first difference found between two buffers of the same size</summary>
            <param name="left">Pointer to the first byte of the left buffer</param>
            <param name="right">Pointer to the first byte of the right buffer</param>
            <param name="count">Number of bytes to compare in both buffers</param>
            <returns>Offset (from the first byte) of the first difference encountered, or -1 if both buffers are identical.</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.NativeMethods.memcmp(System.Byte*,System.Byte*,System.IntPtr)">
            <summary>Compare characters in two buffers.</summary>
            <param name="buf1">First buffer.</param>
            <param name="buf2">Second buffer.</param>
            <param name="count">Number of bytes to compare.</param>
            <returns>The return value indicates the relationship between the buffers.</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceHelpers.NativeMethods.memmove(System.Byte*,System.Byte*,System.IntPtr)">
            <summary>Moves one buffer to another.</summary>
            <param name="dest">Destination object.</param>
            <param name="src">Source object.</param>
            <param name="count">Number of bytes to copy.</param>
            <returns>The value of dest.</returns>
            <remarks>Copies count bytes from src to dest. If some regions of the source area and the destination overlap, both functions ensure that the original source bytes in the overlapping region are copied before being overwritten.</remarks>
        </member>
        <member name="T:FoundationDB.Client.SliceComparer">
            <summary>Performs optimized equality and comparison checks on Slices</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceComparer.Default">
            <summary>Default instance of the slice comparator</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceComparer.Compare(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Lexicographically compare two slices and returns an indication of their relative sort order</summary>
            <param name="x">Slice compared with <paramref name="y"/></param>
            <param name="y">Slice compared with <paramref name="x"/></param>
            <returns>Returns a NEGATIVE value if <paramref name="x"/> is LESS THAN <paramref name="y"/>, ZERO if <paramref name="x"/> is EQUAL TO <paramref name="y"/>, and a POSITIVE value if <paramref name="x"/> is GREATER THAN <paramref name="y"/>.</returns>
            <remarks>If both <paramref name="x"/> and <paramref name="y"/> are nil or empty, the comparison will return ZERO. If only <paramref name="y"/> is nil or empty, it will return a NEGATIVE value. If only <paramref name="x"/> is nil or empty, it will return a POSITIVE value.</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceComparer.Equals(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Checks if two slices are equal.</summary>
            <param name="x">Slice compared with <paramref name="y"/></param>
            <param name="y">Slice compared with <paramref name="x"/></param>
            <returns>true if <paramref name="x"/> and <paramref name="y"/> have the same size and contain the same sequence of bytes; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.SliceComparer.GetHashCode(FoundationDB.Client.Slice)">
            <summary>Computes the hash code of a slice</summary>
            <param name="obj">A slice</param>
            <returns>A 32-bit signed hash coded calculated from all the bytes in the slice</returns>
        </member>
        <member name="T:FoundationDB.Client.Utils.SliceBuffer">
            <summary>Buffer that can be used to efficiently store multiple slices into as few chunks as possible</summary>
            <remarks>
            This class is usefull to centralize a lot of temporary slices whose lifetime is linked to a specific operation. Dropping the referce to the buffer will automatically reclaim all the slices that were stored with it.
            This class is not thread safe.
            </remarks>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_pageSize">
            <summary>Default initial size of pages (doubled every time until it reached the max page size)</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_current">
            <summary>Current buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_pos">
            <summary>Position of the next free slot in the current buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_remaining">
            <summary>Number of bytes remaining in the current buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_chunks">
            <summary>If non null, list of previously used buffers (excluding the current buffer)</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_allocated">
            <summary>Running total of the length of of all previously used buffers, exluding the size of the current buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Utils.SliceBuffer.m_used">
            <summary>Running total of the number of bytes stored in the previously used buffers, excluding the size of the current buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.#ctor">
            <summary>Create a new slice buffer with the default page size</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.#ctor(System.Int32)">
            <summary>Ceate a new slice buffer with the specified page size</summary>
            <param name="pageSize">Initial page size</param>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.GetPages">
            <summary>Return the list of all the pages used by this buffer</summary>
            <returns>Array of pages used by the buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.InternRange(FoundationDB.Client.FdbKeyRange)">
            <summary>Copy a pair of keys into the buffer, and return a new identical pair</summary>
            <param name="range">Key range</param>
            <returns>Equivalent pair of keys, that are backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.InternRange(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Copy a pair of keys into the buffer, and return a new identical pair</summary>
            <param name="begin">Begin key of the range</param>
            <param name="end">End key of the range</param>
            <returns>Equivalent pair of keys, that are backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.InternRangeFromKey(FoundationDB.Client.Slice)">
            <summary>Copy a key into the buffer, and return a new range containing only that key</summary>
            <param name="key">Key to copy to the buffer</param>
            <returns>Range equivalent to [key, key + '\0') that is backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.InternSelector(FoundationDB.Client.FdbKeySelector)">
            <summary>Copy a key selector into the buffer, and return a new identical selector</summary>
            <param name="selector">Key selector to copy to the buffer</param>
            <returns>Equivalent key selector that is backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.InternSelectorPair(FoundationDB.Client.FdbKeySelectorPair)">
            <summary>Copy a pair of key selectors into the buffer, and return a new identical pair</summary>
            <param name="pair">Pair of key selectors to copy to the buffer</param>
            <returns>Equivalent pair of key selectors that is backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.Allocate(System.Int32,System.Boolean)">
            <summary>Allocate an empty space in the buffer</summary>
            <param name="count">Number of bytes to allocate</param>
            <param name="aligned">If true, align the start of the slice with the default padding size.</param>
            <returns>Slice pointing to a space in the buffer</returns>
            <remarks>There is NO garantees that the allocated slice will be pre-filled with zeroes.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.Intern(FoundationDB.Client.Slice,System.Boolean)">
            <summary>Copy a slice into the buffer, with optional alignement, and return a new identical slice.</summary>
            <param name="data">Data to copy in the buffer</param>
            <param name="aligned">If true, align the index of first byte of the slice with a multiple of 8 bytes</param>
            <returns>Slice that is the equivalent of <paramref name="data"/>, backed by the buffer.</returns>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.Intern(FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.Boolean)">
            <summary>Copy a slice into the buffer, immediately followed by a suffix, and return a new slice that is the concatenation of the two.</summary>
            <param name="data">Data to copy in the buffer</param>
            <param name="suffix">Suffix to copy immediately after <paramref name="data"/>.</param>
            <param name="aligned">If true, align the index of first byte of the slice with a multiple of 8 bytes</param>
            <returns>Slice that is the equivalent of <paramref name="data"/> plus <paramref name="suffix"/>, backed by the buffer.</returns>
            <remarks>When <paramref name="data"/> is empty, <paramref name="suffix"/> is returned without being copied to the buffer itself.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.Keep(FoundationDB.Client.Slice)">
            <summary>Adds a buffer to the list of allocated slices</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.Reset">
            <summary>Reset the buffer to its initial state</summary>
            <remarks>None of the existing buffers are kept, but the new page will keep the current page size (that may be larger than the initial size).
            Any previously allocated slice from this buffer will be untouched.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.SliceBuffer.ResetUnsafe">
            <summary>Reset the buffer to its initial state, and reuse the current page.</summary>
            <remarks>This recycle the current page. The caller should ensure that nobody has a reference to a previously generated slice.</remarks>
        </member>
        <member name="P:FoundationDB.Client.Utils.SliceBuffer.Size">
            <summary>Gets the number of bytes used by all the slice allocated in this buffer</summary>
        </member>
        <member name="P:FoundationDB.Client.Utils.SliceBuffer.Allocated">
            <summary>Gets the total memory size allocated to store all the slices in this buffer</summary>
        </member>
        <member name="P:FoundationDB.Client.Utils.SliceBuffer.PageCount">
            <summary>Number of memory pages used by this buffer</summary>
        </member>
        <member name="T:FoundationDB.Client.Uuid">
            <summary>RFC 4122 compliant 128-bit UUID</summary>
            <remarks>You should use this type if you are primarily exchanged UUIDs with non-.NET platforms, that use the RFC 4122 byte ordering (big endian). The type System.Guid uses the Microsoft encoding (little endian) and is not compatible.</remarks>
        </member>
        <member name="T:FoundationDB.Client.SliceListStream">
            <summary>Merge multiple slices into a single stream</summary>
        </member>
        <member name="T:FoundationDB.Client.SliceStream">
            <summary>Stream that wraps a Slice for reading</summary>
            <remarks>This stream is optimized for blocking and async reads</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.#ctor(FoundationDB.Client.Slice)">
            <summary>Creates a new stream that reads from an underlying slice</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>Seeks to a specific location in the underlying slice</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.SetLength(System.Int64)">
            <summary>This methods is not supported</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.ReadByte">
            <summary>Reads from byte from the underyling slice and advances the position within the slice by one byte, or returns -1 if the end of the slice has been reached.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>Reads a sequence of bytes from the underlying slice and advances the position within the slice by the number of bytes that are read.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Asynchronously reads a sequence of bytes from the underlying slice and advances the position within the slice by the number of bytes read.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <summary>Asynchronously reads the bytes from the underlying slice and writes them to another stream, using a specified buffer size and cancellation token.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>This methods is not supported</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>This methods is not supported</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.Flush">
            <summary>This methods does nothing.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.FlushAsync(System.Threading.CancellationToken)">
            <summary>This methods does nothing.</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceStream.Dispose(System.Boolean)">
            <summary>Closes the stream</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceStream.CanSeek">
            <summary>Returns true if the underlying slice is not null</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceStream.Position">
            <summary>Gets or sets the current position in the underlying slice</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceStream.Length">
            <summary>Getes the length of the underlying slice</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceStream.CanRead">
            <summary>Returns true unless the current position is after the end of the underlying slice</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceStream.CanWrite">
            <summary>Always return false</summary>
        </member>
        <member name="M:FoundationDB.Client.Utils.Logging.SetLevel(System.Diagnostics.SourceLevels)">
            <summary>Set/Update the trave level</summary>
            <param name="level"></param>
        </member>
        <member name="P:FoundationDB.Client.Utils.Logging.On">
            <summary>Return true if logging is enabled; otherwise false</summary>
        </member>
        <member name="P:FoundationDB.Client.Utils.Logging.Source">
            <summary>Return the TraceSource used for logging</summary>
        </member>
        <member name="T:FoundationDB.Client.Slice">
            <summary>Delimits a section of a byte array</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Nil">
            <summary>Null slice ("no segment")</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Empty">
            <summary>Empty slice ("segment of 0 bytes")</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Array">
            <summary>Pointer to the buffer (or null for <see cref="F:FoundationDB.Client.Slice.Nil"/>)</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Offset">
            <summary>Offset of the first byte of the slice in the parent buffer</summary>
        </member>
        <member name="F:FoundationDB.Client.Slice.Count">
            <summary>Number of bytes in the slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte[])">
            <summary>Creates a slice mapping an entire buffer</summary>
            <param name="bytes"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.ArraySegment{System.Byte})">
            <summary>Creates a slice from an Array Segment</summary>
            <param name="arraySegment">Segment of buffer to convert</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a slice mapping a section of a buffer</summary>
            <param name="buffer">Original buffer</param>
            <param name="offset">Offset into buffer</param>
            <param name="count">Number of bytes</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Int32)">
            <summary>Create a new empty slice of a specified size containing all zeroes</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Create(System.Byte*,System.Int32)">
            <summary>Creates a new slice with a copy of an unmanaged memory buffer</summary>
            <param name="ptr">Pointer to unmanaged buffer</param>
            <param name="count">Number of bytes in the buffer</param>
            <returns>Slice with a managed copy of the data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Random(System.Random,System.Int32)">
            <summary>Create a new slice filled with random bytes taken from a random number generator</summary>
            <param name="prng">Pseudo random generator to use (needs locking if instance is shared)</param>
            <param name="count">Number of random bytes to generate</param>
            <returns>Slice of <paramref name="count"/> bytes taken from <paramref name="prng"/></returns>
            <remarks>Warning: <see cref="T:System.Random"/> is not thread-safe ! If the <paramref name="prng"/> instance is shared between threads, then it needs to be locked before calling this method.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Random(System.Security.Cryptography.RandomNumberGenerator,System.Int32,System.Boolean)">
            <summary>Create a new slice filled with random bytes taken from a cryptographic random number generator</summary>
            <param name="rng">Random generator to use (needs locking if instance is shared)</param>
            <param name="count">Number of random bytes to generate</param>
            <param name="nonZeroBytes">If true, produce a sequence of non-zero bytes.</param>
            <returns>Slice of <paramref name="count"/> bytes taken from <paramref name="rng"/></returns>
            <remarks>Warning: All RNG implementations may not be thread-safe ! If the <paramref name="rng"/> instance is shared between threads, then it may need to be locked before calling this method.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Find(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Reports the zero-based index of the first occurrence of the specified slice in this source.</summary>
            <param name="source">The slice Input slice</param>
            <param name="value">The slice to seek</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Join(FoundationDB.Client.Slice,FoundationDB.Client.Slice[])">
            <summary>Concatenates all the elements of a slice array, using the specified separator between each element.</summary>
            <param name="separator">The slice to use as a separator. Can be empty.</param>
            <param name="values">An array that contains the elements to concatenate.</param>
            <returns>A slice that consists of the elements in a value delimited by the <paramref name="separator"/> slice. If <paramref name="values"/> is an empty array, the method returns <see cref="F:FoundationDB.Client.Slice.Empty"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Join(FoundationDB.Client.Slice,FoundationDB.Client.Slice[],System.Int32,System.Int32)">
            <summary>Concatenates the specified elements of a slice array, using the specified separator between each element.</summary>
            <param name="separator">The slice to use as a separator. Can be empty.</param>
            <param name="values">An array that contains the elements to concatenate.</param>
            <param name="startIndex">The first element in <paramref name="values"/> to use.</param>
            <param name="count">The number of elements of <paramref name="values"/> to use.</param>
            <returns>A slice that consists of the slices in <paramref name="values"/> delimited by the <paramref name="separator"/> slice. -or- <see cref="F:FoundationDB.Client.Slice.Empty"/> if <paramref name="count"/> is zero, <paramref name="values"/> has no elements, or <paramref name="separator"/> and all the elements of <paramref name="values"/> are <see cref="F:FoundationDB.Client.Slice.Empty"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex"/> or <paramref name="count"/> is less than zero. -or- <paramref name="startIndex"/> plus <paramref name="count"/> is greater than the number of elements in <paramref name="values"/>.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Join(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Concatenates the specified elements of a slice sequence, using the specified separator between each element.</summary>
            <param name="separator">The slice to use as a separator. Can be empty.</param>
            <param name="values">A sequence will return the elements to concatenate.</param>
            <returns>A slice that consists of the slices in <paramref name="values"/> delimited by the <paramref name="separator"/> slice. -or- <see cref="F:FoundationDB.Client.Slice.Empty"/> if <paramref name="values"/> has no elements, or <paramref name="separator"/> and all the elements of <paramref name="values"/> are <see cref="F:FoundationDB.Client.Slice.Empty"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.JoinBytes(FoundationDB.Client.Slice,FoundationDB.Client.Slice[],System.Int32,System.Int32)">
            <summary>Concatenates the specified elements of a slice array, using the specified separator between each element.</summary>
            <param name="separator">The slice to use as a separator. Can be empty.</param>
            <param name="values">An array that contains the elements to concatenate.</param>
            <param name="startIndex">The first element in <paramref name="values"/> to use.</param>
            <param name="count">The number of elements of <paramref name="values"/> to use.</param>
            <returns>A byte array that consists of the slices in <paramref name="values"/> delimited by the <paramref name="separator"/> slice. -or- an emtpy array if <paramref name="count"/> is zero, <paramref name="values"/> has no elements, or <paramref name="separator"/> and all the elements of <paramref name="values"/> are <see cref="F:FoundationDB.Client.Slice.Empty"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="values"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="startIndex"/> or <paramref name="count"/> is less than zero. -or- <paramref name="startIndex"/> plus <paramref name="count"/> is greater than the number of elements in <paramref name="values"/>.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.JoinBytes(FoundationDB.Client.Slice,System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Concatenates the specified elements of a slice sequence, using the specified separator between each element.</summary>
            <param name="separator">The slice to use as a separator. Can be empty.</param>
            <param name="values">A sequence will return the elements to concatenate.</param>
            <returns>A byte array that consists of the slices in <paramref name="values"/> delimited by the <paramref name="separator"/> slice. -or- an empty array if <paramref name="values"/> has no elements, or <paramref name="separator"/> and all the elements of <paramref name="values"/> are <see cref="F:FoundationDB.Client.Slice.Empty"/>.</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="values"/> is null.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Split(FoundationDB.Client.Slice,FoundationDB.Client.Slice,System.StringSplitOptions)">
            <summary>Returns a slice array that contains the sub-slices in <paramref name="input"/> that are delimited by <paramref name="separator"/>. A parameter specifies whether to return empty array elements.</summary>
            <param name="input">Input slice that must be split into sub-slices</param>
            <param name="separator">Separator that delimits the sub-slices in <paramref name="input"/>. Cannot be empty or nil</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries"/> to omit empty array alements from the array returned; or <see cref="F:System.StringSplitOptions.None"/> to include empty array elements in the array returned.</param>
            <returns>An array whose elements contain the sub-slices that are delimited by <paramref name="separator"/>.</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="separator"/> is empty, or if <paramref name="options"/> is not one of the <see cref="T:System.StringSplitOptions"/> values.</exception>
            <remarks>If <paramref name="input"/> does not contain the delimiter, the returned array consists of a single element that repeats the input, or an empty array if input is itself empty.
            To reduce memory usage, the sub-slices returned in the array will all share the same underlying buffer of the input slice.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromBase64(System.String)">
            <summary>Decode a Base64 encoded string into a slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromByte(System.Byte)">
            <summary>Encode an unsigned 8-bit integer into a slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromInt16(System.Int16)">
            <summary>Encode a signed 16-bit integer into a variable size slice (1 or 2 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixed16(System.Int16)">
            <summary>Encode a signed 16-bit integer into a 2-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUInt16(System.UInt16)">
            <summary>Encode an unsigned 16-bit integer into a variable size slice (1 or 2 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU16(System.UInt16)">
            <summary>Encode an unsigned 16-bit integer into a 2-byte slice in little-endian</summary>
            <remarks>0x1122 => 11 22</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU16BE(System.UInt16)">
            <summary>Encode an unsigned 16-bit integer into a 2-byte slice in big-endian</summary>
            <remarks>0x1122 => 22 11</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromVarint16(System.UInt16)">
            <summary>Encode an unsigned 16-bit integer into 7-bit encoded unsigned int (aka 'Varint16')</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromInt32(System.Int32)">
            <summary>Encode a signed 32-bit integer into a variable size slice (1, 2 or 4 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixed32(System.Int32)">
            <summary>Encode a signed 32-bit integer into a 4-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUInt32(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into a variable size slice (1, 2 or 4 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU32(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into a 4-byte slice in little-endian</summary>
            <remarks>0x11223344 => 11 22 33 44</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU32BE(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into a 4-byte slice in big-endian</summary>
            <remarks>0x11223344 => 44 33 22 11</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromVarint32(System.UInt32)">
            <summary>Encode an unsigned 32-bit integer into 7-bit encoded unsigned int (aka 'Varint32')</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromInt64(System.Int64)">
            <summary>Encode a signed 64-bit integer into a variable size slice (1, 2, 4 or 8 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixed64(System.Int64)">
            <summary>Encode a signed 64-bit integer into a 8-byte slice in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUInt64(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into a variable size slice (1, 2, 4 or 8 bytes) in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU64(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into a 8-byte slice in little-endian</summary>
            <remarks>0x1122334455667788 => 11 22 33 44 55 66 77 88</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromFixedU64BE(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into a 8-byte slice in big-endian</summary>
            <remarks>0x1122334455667788 => 88 77 66 55 44 33 22 11</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromVarint64(System.UInt64)">
            <summary>Encode an unsigned 64-bit integer into 7-bit encoded unsigned int (aka 'Varint64')</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromGuid(System.Guid)">
            <summary>Create a 16-byte slice containing a System.Guid encoding according to RFC 4122 (Big Endian)</summary>
            <remarks>WARNING: Slice.FromGuid(guid).GetBytes() will not produce the same result as guid.ToByteArray() !
            If you need to produce Microsoft compatible byte arrays, use Slice.Create(guid.ToByteArray()) but then you shoud NEVER use Slice.ToGuid() to decode such a value !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromUuid(FoundationDB.Client.Uuid)">
            <summary>Create a 16-byte slice containing an RFC 4122 compliant 128-bit UUID</summary>
            <remarks>You should never call this method on a slice created from the result of calling System.Guid.ToByteArray() !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromAscii(System.String)">
            <summary>Dangerously create a slice containing string converted to ASCII. All non-ASCII characters may be corrupted or converted to '?'</summary>
            <remarks>WARNING: if you put a string that contains non-ASCII chars, it will be silently corrupted! This should only be used to store keywords or 'safe' strings.
            Note: depending on your default codepage, chars from 128 to 255 may be preserved, but only if they are decoded using the same codepage at the other end !</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromString(System.String)">
            <summary>Create a slice containing the UTF-8 bytes of the string <paramref name="value"/></summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromChar(System.Char)">
            <summary>Create a slice that holds the UTF-8 encoded representation of <paramref name="value"/></summary>
            <param name="value"></param>
            <returns>The returned slice is only guaranteed to hold 1 byte for ASCII chars (0..127). For non-ASCII chars, the size can be from 1 to 6 bytes.
            If you need to use ASCII chars, you should use Slice.FromByte() instead</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.NibbleToDecimal(System.Char)">
            <summary>Convert an hexadecimal digit (0-9A-Fa-f) into the corresponding decimal value</summary>
            <param name="c">Hexadecimal digit (case insensitive)</param>
            <returns>Decimal value between 0 and 15, or an exception</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromHexa(System.String)">
            <summary>Convert an hexadecimal encoded string ("1234AA7F") into a slice</summary>
            <param name="hexaString">String contains a sequence of pairs of hexadecimal digits with no separating spaces.</param>
            <returns>Slice containing the decoded byte array, or an exeception if the string is empty or has an odd length</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.GetBytes">
            <summary>Return a byte array containing all the bytes of the slice, or null if the slice is null</summary>
            <returns>Byte array with a copy of the slice, or null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.GetBytes(System.Int32,System.Int32)">
            <summary>Return a byte array containing a subset of the bytes of the slice, or null if the slice is null</summary>
            <returns>Byte array with a copy of a subset of the slice, or null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.AsStream">
            <summary>Return a stream that wraps this slice</summary>
            <returns>Stream that will read the slice from the start.</returns>
            <remarks>
            You can use this method to convert text into specific encodings, load bitmaps (JPEG, PNG, ...), or any serialization format that requires a Stream or TextReader instance.
            Disposing this stream will have no effect on the slice.
            </remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToAscii">
            <summary>Stringify a slice containing only ASCII chars</summary>
            <returns>ASCII string, or null if the slice is null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUnicode">
            <summary>Stringify a slice containing an UTF-8 encoded string</summary>
            <returns>Unicode string, or null if the slice is null</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToBase64">
            <summary>Converts a slice using Base64 encoding</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToHexaString">
            <summary>Converts a slice into a string with each byte encoded into hexadecimal (lowercase)</summary>
            <returns>"0123456789abcdef"</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToHexaString(System.Char)">
            <summary>Converts a slice into a string with each byte encoded into hexadecimal (uppercase) separated by a char</summary>
            <param name="sep">Character used to separate the hexadecimal pairs (ex: ' ')</param>
            <returns>"01 23 45 67 89 ab cd ef"</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToAsciiOrHexaString">
            <summary>Helper method that dumps the slice as a string (if it contains only printable ascii chars) or an hex array if it contains non printable chars. It should only be used for logging and troubleshooting !</summary>
            <returns>Returns either "'abc'", "&lt;00 42 7F&gt;", or "{ ...JSON... }". Returns "''" for Slice.Empty, and "" for <see cref="F:FoundationDB.Client.Slice.Nil"/></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToByte">
            <summary>Converts a slice into a byte</summary>
            <returns>Value of the first and only byte of the slice, or 0 if the slice is null or empty.</returns>
            <exception cref="T:System.FormatException">If the slice has more than one byte</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToBool">
            <summary>Converts a slice into a boolean.</summary>
            <returns>False if the slice is empty, or is equal to the byte 0; otherwise, true.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToInt16">
            <summary>Converts a slice into a little-endian encoded, signed 16-bit integer.</summary>
            <returns>0 of the slice is null or empty, a signed integer, or an error if the slice has more than 2 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 2 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUInt16">
            <summary>Converts a slice into a little-endian encoded, unsigned 16-bit integer.</summary>
            <returns>0 of the slice is null or empty, an unsigned integer, or an error if the slice has more than 2 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 2 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToInt32">
            <summary>Converts a slice into a little-endian encoded, signed 32-bit integer.</summary>
            <returns>0 of the slice is null or empty, a signed integer, or an error if the slice has more than 4 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 4 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUInt32">
            <summary>Converts a slice into a little-endian encoded, unsigned 32-bit integer.</summary>
            <returns>0 of the slice is null or empty, an unsigned integer, or an error if the slice has more than 4 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 4 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToInt64">
            <summary>Converts a slice into a little-endian encoded, signed 64-bit integer.</summary>
            <returns>0 of the slice is null or empty, a signed integer, or an error if the slice has more than 8 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 8 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUInt64">
            <summary>Converts a slice into a little-endian encoded, unsigned 64-bit integer.</summary>
            <returns>0 of the slice is null or empty, an unsigned integer, or an error if the slice has more than 8 bytes</returns>
            <exception cref="T:System.FormatException">If there are more than 8 bytes in the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ReadUInt64(System.Int32,System.Int32)">
            <summary>Read a variable-length, little-endian encoded, unsigned integer from a specific location in the slice</summary>
            <param name="offset">Relative offset of the first byte</param>
            <param name="bytes">Number of bytes to read (up to 8)</param>
            <returns>Decoded unsigned integer.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If <paramref name="bytes"/> is less than zero, or more than 8.</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToGuid">
            <summary>Converts a slice into a Guid.</summary>
            <returns>Native Guid decoded from the Slice.</returns>
            <remarks>The slice can either be a 16-byte RFC4122 GUID, or an ASCII string of 36 chars</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToUuid">
            <summary>Converts a slice into an Uuid.</summary>
            <returns>Uuid decoded from the Slice.</returns>
            <remarks>The slice can either be a 16-byte RFC4122 GUID, or an ASCII string of 36 chars</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Memoize">
            <summary>Returns a new slice that contains an isolated copy of the buffer</summary>
            <returns>Slice that is equivalent, but is isolated from any changes to the buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.UnsafeMapToOffset(System.Int32)">
            <summary>Map an offset in the slice into the absolute offset in the buffer, without any bound checking</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Absolute offset in the buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.MapToOffset(System.Int32)">
            <summary>Map an offset in the slice into the absolute offset in the buffer</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Absolute offset in the buffer</returns>
            <exception cref="T:System.IndexOutOfRangeException">If the index is outside the slice</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.NormalizeIndex(System.Int32)">
            <summary>Normalize negative index values into offset from the start</summary>
            <param name="index">Relative offset (negative values mean from the end)</param>
            <returns>Relative offset from the start of the slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.WriteTo(System.Byte[],System.Int32@)">
            <summary>Copy this slice into another buffer, and move the cursor</summary>
            <param name="buffer">Buffer where to copy this slice</param>
            <param name="cursor">Offset into the destination buffer</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.CopyTo(System.Byte[],System.Int32)">
            <summary>Copy this slice into another buffer</summary>
            <param name="buffer">Buffer where to copy this slice</param>
            <param name="offset">Offset into the destination buffer</param>
        </member>
        <member name="M:FoundationDB.Client.Slice.Substring(System.Int32)">
            <summary>Retrieves a substring from this instance. The substring starts at a specified character position.</summary>
            <param name="offset">The starting position of the substring. Positive values mmeans from the start, negative values means from the end</param>
            <returns>A slice that is equivalent to the substring that begins at <paramref name="offset"/> (from the start or the end depending on the sign) in this instance, or Slice.Empty if <paramref name="offset"/> is equal to the length of the slice.</returns>
            <remarks>The substring does not copy the original data, and refers to the same buffer as the original slice. Any change to the parent slice's buffer will be seen by the substring. You must call Memoize() on the resulting substring if you want a copy</remarks>
            <example>{"ABCDE"}.Substring(0) =&gt; {"ABC"}
            {"ABCDE"}.Substring(1} =&gt; {"BCDE"}
            {"ABCDE"}.Substring(-2} =&gt; {"DE"}
            {"ABCDE"}.Substring(5} =&gt; Slice.Empty
            Slice.Empty.Substring(0) =&gt; Slice.Empty
            Slice.Nil.Substring(0) =&gt; Slice.Emtpy
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> indicates a position not within this instance, or <paramref name="offset"/> is less than zero</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Substring(System.Int32,System.Int32)">
            <summary>Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.</summary>
            <param name="offset">The starting position of the substring. Positive values means from the start, negative values means from the end</param>
            <param name="count">Number of bytes in the substring</param>
            <returns>A slice that is equivalent to the substring of length <paramref name="count"/> that begins at <paramref name="offset"/> (from the start or the end depending on the sign) in this instance, or Slice.Empty if count is zero.</returns>
            <remarks>The substring does not copy the original data, and refers to the same buffer as the original slice. Any change to the parent slice's buffer will be seen by the substring. You must call Memoize() on the resulting substring if you want a copy</remarks>
            <example>{"ABCDE"}.Substring(0, 3) =&gt; {"ABC"}
            {"ABCDE"}.Substring(1, 3} =&gt; {"BCD"}
            {"ABCDE"}.Substring(-2, 2} =&gt; {"DE"}
            Slice.Empty.Substring(0, 0) =&gt; Slice.Empty
            Slice.Nil.Substring(0, 0) =&gt; Slice.Emtpy
            </example>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset"/> plus <paramref name="count"/> indicates a position not within this instance, or <paramref name="offset"/> or <paramref name="count"/> is less than zero</exception>
        </member>
        <member name="M:FoundationDB.Client.Slice.Split(FoundationDB.Client.Slice,System.StringSplitOptions)">
            <summary>Returns a slice array that contains the sub-slices in this instance that are delimited by the specified separator</summary>
            <param name="separator">The slice that delimits the sub-slices in this instance.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries"/> to omit empty array elements from the array returned; or <see cref="F:System.StringSplitOptions.None"/> to include empty array elements in the array returned.</param>
            <returns>An array whose elements contains the sub-slices in this instance that are delimited by the value of <paramref name="separator"/>.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.IndexOf(FoundationDB.Client.Slice)">
            <summary>Reports the zero-based index of the first occurence of the specified slice in this instance.</summary>
            <param name="value">The slice to seek</param>
            <returns>The zero-based index of <paramref name="value"/> if that slice is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:FoundationDB.Client.Slice.Empty"/>, then the return value is -1.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.IndexOf(FoundationDB.Client.Slice,System.Int32)">
            <summary>Reports the zero-based index of the first occurence of the specified slice in this instance. The search starts at a specified position.</summary>
            <param name="value">The slice to seek</param>
            <param name="startIndex">The search starting position</param>
            <returns>The zero-based index of <paramref name="value"/> if that slice is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:FoundationDB.Client.Slice.Empty"/>, then the return value is startIndex</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.StartsWith(FoundationDB.Client.Slice)">
            <summary>Determines whether the beginning of this slice instance matches a specified slice.</summary>
            <param name="value">The slice to compare</param>
            <returns><b>true</b> if <paramref name="value"/> matches the beginning of this slice; otherwise, <b>false</b></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.EndsWith(FoundationDB.Client.Slice)">
            <summary>Determines whether the end of this slice instance matches a specified slice.</summary>
            <param name="value">The slice to compare to the substring at the end of this instance.</param>
            <returns><b>true</b> if <paramref name="value"/> matches the end of this slice; otherwise, <b>false</b></returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.PrefixedBy(FoundationDB.Client.Slice)">
            <summary>Equivalent of StartsWith, but the returns false if both slices are identical</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.SuffixedBy(FoundationDB.Client.Slice)">
            <summary>Equivalent of EndsWith, but the returns false if both slices are identical</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Concat(FoundationDB.Client.Slice)">
            <summary>Append/Merge a slice at the end of the current slice</summary>
            <param name="tail">Slice that must be appended</param>
            <returns>Merged slice if both slices are contigous, or a new slice containg the content of the current slice, followed by the tail slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ConcatRange(FoundationDB.Client.Slice[])">
            <summary>Append an array of slice at the end of the current slice, all sharing the same buffer</summary>
            <param name="slices">Slices that must be appended</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.ConcatRange(System.Collections.Generic.IEnumerable{FoundationDB.Client.Slice})">
            <summary>Append a sequence of slice at the end of the current slice, all sharing the same buffer</summary>
            <param name="slices">Slices that must be appended</param>
            <returns>Array of slices (for all keys) that share the same underlying buffer</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Concat(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Concatenate two slices together</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Concat(FoundationDB.Client.Slice,FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Concatenate three slices together</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.Concat(FoundationDB.Client.Slice[])">
            <summary>Concatenate an array of slices into a single slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Implicit(FoundationDB.Client.Slice)~System.ArraySegment{System.Byte}">
            <summary>Implicitly converts a Slice into an ArraySegment&lt;byte&gt;</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Implicit(System.ArraySegment{System.Byte})~FoundationDB.Client.Slice">
            <summary>Implicitly converts an ArraySegment&lt;byte&gt; into a Slice</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Equality(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices for equality</summary>
            <returns>True if the slices contains the same bytes</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Inequality(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices for inequality</summary>
            <returns>True if the slice do not contain the same bytes</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_LessThan(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices</summary>
            <returns>True if <paramref name="a"/> is lexicographically less than <paramref name="a"/>; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_LessThanOrEqual(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices</summary>
            <returns>True if <paramref name="a"/> is lexicographically less than or equal to <paramref name="a"/>; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_GreaterThan(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices</summary>
            <returns>True if <paramref name="a"/> is lexicographically greater than <paramref name="a"/>; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_GreaterThanOrEqual(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Compare two slices</summary>
            <returns>True if <paramref name="a"/> is lexicographically greater than or equal to <paramref name="a"/>; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Addition(FoundationDB.Client.Slice,FoundationDB.Client.Slice)">
            <summary>Append/Merge two slices together</summary>
            <param name="a">First slice</param>
            <param name="b">Second slice</param>
            <returns>Merged slices if both slices are contigous, or a new slice containg the content of the first slice, followed by the second</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Addition(FoundationDB.Client.Slice,System.Byte)">
            <summary>Appends a byte at the end of the slice</summary>
            <param name="a">First slice</param>
            <param name="b">Byte to append at the end</param>
            <returns>New slice with the byte appended</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Subtraction(FoundationDB.Client.Slice,System.Int32)">
            <summary>Remove <paramref name="n"/> bytes at the end of slice <paramref name="s"/></summary>
            <returns>Smaller slice</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Equality(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether two specified instances of <see cref="T:FoundationDB.Client.Slice"/> are equal</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Inequality(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether two specified instances of <see cref="T:FoundationDB.Client.Slice"/> are not equal</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_LessThan(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether one specified <see cref="T:FoundationDB.Client.Slice"/> is less than another specified <see cref="T:FoundationDB.Client.Slice"/>.</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_LessThanOrEqual(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether one specified <see cref="T:FoundationDB.Client.Slice"/> is less than or equal to another specified <see cref="T:FoundationDB.Client.Slice"/>.</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_GreaterThan(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether one specified <see cref="T:FoundationDB.Client.Slice"/> is greater than another specified <see cref="T:FoundationDB.Client.Slice"/>.</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_GreaterThanOrEqual(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Determines whether one specified <see cref="T:FoundationDB.Client.Slice"/> is greater than or equal to another specified <see cref="T:FoundationDB.Client.Slice"/>.</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.op_Addition(System.Nullable{FoundationDB.Client.Slice},System.Nullable{FoundationDB.Client.Slice})">
            <summary>Concatenates two <see cref="T:FoundationDB.Client.Slice"/> together.</summary>
        </member>
        <member name="M:FoundationDB.Client.Slice.ToString">
            <summary>Returns a printable representation of the key</summary>
            <remarks>You can roundtrip the result of calling slice.ToString() by passing it to <see cref="M:FoundationDB.Client.Slice.Unescape(System.String)"/>(string) and get back the original slice.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Dump(FoundationDB.Client.Slice)">
            <summary>Returns a printable representation of a key</summary>
            <remarks>This may not be efficient, so it should only be use for testing/logging/troubleshooting</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Unescape(System.String)">
            <summary>Decode the string that was generated by slice.ToString() or Slice.Dump(), back into the original slice</summary>
            <remarks>This may not be efficient, so it should only be use for testing/logging/troubleshooting</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromStream(System.IO.Stream)">
            <summary>Read the content of a stream into a slice</summary>
            <param name="data">Source stream, that must be in a readable state</param>
            <returns>Slice containing the stream content (or <see cref="F:FoundationDB.Client.Slice.Nil"/> if the stream is <see cref="F:System.IO.Stream.Null"/>)</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.FromStreamAsync(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>Asynchronously read the content of a stream into a slice</summary>
            <param name="data">Source stream, that must be in a readable state</param>
            <param name="cancellationToken">Optional cancellation token for this operation</param>
            <returns>Slice containing the stream content (or <see cref="F:FoundationDB.Client.Slice.Nil"/> if the stream is <see cref="F:System.IO.Stream.Null"/>)</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromNonBlockingStream(System.IO.Stream,System.Int32)">
            <summary>Read from a non-blocking stream that already contains all the data in memory (MemoryStream, UnmanagedStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromBlockingStream(System.IO.Stream,System.Int32,System.Int32)">
            <summary>Synchronously read from a blocking stream (FileStream, NetworkStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <param name="chunkSize">If non zero, max amount of bytes to read in one chunk. If zero, tries to read everything at once</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.LoadFromBlockingStreamAsync(System.IO.Stream,System.Int32,System.Int32,System.Threading.CancellationToken)">
            <summary>Asynchronously read from a blocking stream (FileStream, NetworkStream, ...)</summary>
            <param name="source">Source stream</param>
            <param name="length">Number of bytes to read from the stream</param>
            <param name="chunkSize">If non zero, max amount of bytes to read in one chunk. If zero, tries to read everything at once</param>
            <param name="cancellationToken">Optional cancellation token for this operation</param>
            <returns>Slice containing the loaded data</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Equals(System.Object)">
            <summary>Checks if an object is equal to the current slice</summary>
            <param name="obj">Object that can be either another slice, a byte array, or a byte array segment.</param>
            <returns>true if the object represents a sequence of bytes that has the same size and same content as the current slice.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.GetHashCode">
            <summary>Gets the hash code for this slice</summary>
            <returns>A 32-bit signed hash code calculated from all the bytes in the slice.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Equals(FoundationDB.Client.Slice)">
            <summary>Checks if another slice is equal to the current slice.</summary>
            <param name="other">Slice compared with the current instance</param>
            <returns>true if both slices have the same size and contain the same sequence of bytes; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.CompareTo(FoundationDB.Client.Slice)">
            <summary>Lexicographically compare this slice with another one, and return an indication of their relative sort order</summary>
            <param name="other">Slice to compare with this instance</param>
            <returns>Returns a NEGATIVE value if the current slice is LESS THAN <paramref name="other"/>, ZERO if it is EQUAL TO <paramref name="other"/>, and a POSITIVE value if it is GREATER THAN <paramref name="other"/>.</returns>
            <remarks>If both this instance and <paramref name="other"/> are Nil or Empty, the comparison will return ZERO. If only <paramref name="other"/> is Nil or Empty, it will return a NEGATIVE value. If only this instance is Nil or Empty, it will return a POSITIVE value.</remarks>
        </member>
        <member name="M:FoundationDB.Client.Slice.Equals(System.ArraySegment{System.Byte})">
            <summary>Checks if the content of a byte array segment matches the current slice.</summary>
            <param name="other">Byte array segment compared with the current instance</param>
            <returns>true if both segment and slice have the same size and contain the same sequence of bytes; otherwise, false.</returns>
        </member>
        <member name="M:FoundationDB.Client.Slice.Equals(System.Byte[])">
            <summary>Checks if the content of a byte array matches the current slice.</summary>
            <param name="other">Byte array compared with the current instance</param>
            <returns>true if the both array and slice have the same size and contain the same sequence of bytes; otherwise, false.</returns>
        </member>
        <member name="P:FoundationDB.Client.Slice.HasValue">
            <summary>Returns true is the slice is not null</summary>
            <remarks>An empty slice is NOT considered null</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsNull">
            <summary>Returns true if the slice is null</summary>
            <remarks>An empty slice is NOT considered null</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsEmpty">
            <summary>Return true if the slice is not null but contains 0 bytes</summary>
            <remarks>A null slice is NOT empty</remarks>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsNullOrEmpty">
            <summary>Returns true if the slice is null or empty, or false if it contains at least one byte</summary>
        </member>
        <member name="P:FoundationDB.Client.Slice.IsPresent">
            <summary>Returns true if the slice contains at least one byte, or false if it is null or empty</summary>
        </member>
        <member name="P:FoundationDB.Client.Slice.Item(System.Int32)">
            <summary>Returns the value of one byte in the slice</summary>
            <param name="index">Offset of the byte (negative values means start from the end)</param>
        </member>
        <member name="P:FoundationDB.Client.Slice.Item(System.Int32,System.Int32)">
            <summary>Returns a substring of the current slice that fits withing the specified index range</summary>
            <param name="start">The starting position of the substring. Positive values means from the start, negative values means from the end</param>
            <param name="end">The end position (exlucded) of the substring. Positive values means from the start, negative values means from the end</param>
            <returns>Subslice</returns>
        </member>
        <member name="T:FoundationDB.Client.SliceReader">
            <summary>Helper class that holds the internal state used to parse tuples from slices</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.FromBuffer(System.Byte[])">
            <summary>Creates a reader on a byte array</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.FromBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>Creates a reader on a segment of a byte array</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceReader.Buffer">
            <summary>Buffer containing the tuple being parsed</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceReader.Position">
            <summary>Current position inside the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.#ctor(FoundationDB.Client.Slice)">
            <summary>Creates a new reader over a slice</summary>
            <param name="buffer">Slice that will be used as the underlying buffer</param>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.EnsureBytes(System.Int32)">
            <summary>Ensure that there are at least <paramref name="count"/> bytes remaining in the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.PeekByte">
            <summary>Return the value of the next byte in the buffer, or -1 if we reached the end</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.Skip(System.Int32)">
            <summary>Skip the next <paramref name="count"/> bytes of the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadByte">
            <summary>Read the next byte from the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadBytes(System.Int32)">
            <summary>Read the next <paramref name="count"/> bytes from the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadFixed16">
            <summary>Read the next 2 bytes as an unsigned 16-bit integer, encoded in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadFixed32">
            <summary>Read the next 4 bytes as an unsigned 32-bit integer, encoded in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadFixed64">
            <summary>Read the next 8 bytes as an unsigned 64-bit integer, encoded in little-endian</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadByteString">
            <summary>Read an encoded nul-terminated byte array from the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadVarint16">
            <summary>Reads a 7-bit encoded unsigned int (aka 'Varint16') from the buffer, and advances the cursor</summary>
            <remarks>Can Read up to 3 bytes from the input</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadVarint32">
            <summary>Reads a 7-bit encoded unsigned int (aka 'Varint32') from the buffer, and advances the cursor</summary>
            <remarks>Can Read up to 5 bytes from the input</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadVarint64">
            <summary>Reads a 7-bit encoded unsigned long (aka 'Varint32') from the buffer, and advances the cursor</summary>
            <remarks>Can Read up to 10 bytes from the input</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadVarint(System.Int32)">
            <summary>Reads a Base 128 Varint from the input</summary>
            <param name="count">Maximum number of bytes allowed (5 for 32 bits, 10 for 64 bits)</param>
        </member>
        <member name="M:FoundationDB.Client.SliceReader.ReadVarbytes">
            <summary>Reads a variable sized slice, by first reading its size (stored as a Varint32) and then the data</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceReader.HasMore">
            <summary>Returns true if there are more bytes to parse</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceReader.Remaining">
            <summary>Returns the number of bytes remaining</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceReader.Head">
            <summary>Returns a slice with all the bytes read so far in the buffer</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceReader.Tail">
            <summary>Returns a slice with all the remaining bytes in the buffer</summary>
        </member>
        <member name="T:FoundationDB.Client.SliceWriter">
            <summary>Slice buffer that emulates a pseudo-stream using a byte array that will automatically grow in size, if necessary</summary>
            <remarks>IMPORTANT: This struct does not extensively check the parameters! The caller should ensure that everything is valid (this is to get the max performance when serializing keys and values)</remarks>
        </member>
        <member name="F:FoundationDB.Client.SliceWriter.Buffer">
            <summary>Buffer holding the data</summary>
        </member>
        <member name="F:FoundationDB.Client.SliceWriter.Position">
            <summary>Position in the buffer ( == number of already written bytes)</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.#ctor(System.Int32)">
            <summary>Create a new empty binary buffer with an initial allocated size</summary>
            <param name="capacity">Initial capacity of the buffer</param>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.#ctor(System.Byte[])">
            <summary>Create a new binary writer using an existing buffer</summary>
            <param name="buffer">Initial buffer</param>
            <remarks>Since the content of the <paramref name="buffer"/> will be modified, only a temporary or scratch buffer should be used. If the writer needs to grow, a new buffer will be allocated.</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.#ctor(System.Byte[],System.Int32)">
            <summary>Create a new binary buffer using an existing buffer and with the cursor to a specific location</summary>
            <remarks>Since the content of the <paramref name="buffer"/> will be modified, only a temporary or scratch buffer should be used. If the writer needs to grow, a new buffer will be allocated.</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.#ctor(FoundationDB.Client.Slice,System.Int32)">
            <summary>Creates a new binary buffer, initialized by copying pre-existing data</summary>
            <param name="prefix">Data that will be copied at the start of the buffer</param>
            <param name="capacity">Optional initial capacity of the buffer</param>
            <remarks>The cursor will already be placed at the end of the prefix</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.GetBytes">
            <summary>Returns a byte array filled with the contents of the buffer</summary>
            <remarks>The buffer is copied in the byte array. And change to one will not impact the other</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.ToSlice">
            <summary>Returns a slice pointing to the content of the buffer</summary>
            <remarks>Any change to the slice will change the buffer !</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.ToSlice(System.Int32)">
            <summary>Returns a slice pointing to the first <paramref name="count"/> bytes of the buffer</summary>
            <param name="count">Size of the segment</param>
            <remarks>Any change to the slice will change the buffer !</remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="count"/> is less than zero, or larger than the current buffer size</exception>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Substring(System.Int32)">
            <summary>Returns a slice pointing to a segment inside the buffer</summary>
            <param name="offset">Offset of the segment from the start of the buffer</param>
            <remarks>Any change to the slice will change the buffer !</remarks>
            <exception cref="T:System.ArgumentException">If <paramref name="offset"/> is less then zero, or after the current position</exception>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Substring(System.Int32,System.Int32)">
            <summary>Returns a slice pointing to a segment inside the buffer</summary>
            <param name="offset">Offset of the segment from the start of the buffer</param>
            <param name="count">Size of the segment</param>
            <remarks>Any change to the slice will change the buffer !</remarks>
            <exception cref="T:System.ArgumentException">If either <paramref name="offset"/> or <paramref name="count"/> are less then zero, or do not fit inside the current buffer</exception>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.SetLength(System.Int32)">
            <summary>Truncate the buffer by setting the cursor to the specified position.</summary>
            <param name="position">New size of the buffer</param>
            <remarks>If the buffer was smaller, it will be resized and filled with zeroes. If it was biffer, the cursor will be set to the specified position, but previous data will not be deleted.</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Flush(System.Int32)">
            <summary>Delete the first N bytes of the buffer, and shift the remaining to the front</summary>
            <param name="bytes">Number of bytes to remove at the head of the buffer</param>
            <returns>New size of the buffer (or 0 if it is empty)</returns>
            <remarks>This should be called after every successfull write to the underlying stream, to update the buffer.</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Reset">
            <summary>Empties the current buffer after a succesfull write</summary>
            <remarks>Shrink the buffer if a lot of memory is wated</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Skip(System.Int32,System.Byte)">
            <summary>Advance the cursor of the buffer without writing anything, and return the previous position</summary>
            <param name="skip">Number of bytes to skip</param>
            <param name="pad">Pad value (0xFF by default)</param>
            <returns>Position of the cursor BEFORE moving it. Can be used as a marker to go back later and fill some value</returns>
            <remarks>Will fill the skipped bytes with <paramref name="pad"/></remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.Rewind(System.Int32@,System.Int32)">
            <summary>Rewinds the cursor to a previous position in the buffer, while saving the current position</summary>
            <param name="cursor">Will receive the current cursor position</param>
            <param name="position">Previous position in the buffer</param>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteByte(System.Byte)">
            <summary>Add a byte to the end of the buffer, and advance the cursor</summary>
            <param name="value">Byte, 8 bits</param>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteBytes(System.Byte[])">
            <summary>Append a byte array to the end of the buffer</summary>
            <param name="data"></param>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>Append a chunk of a byte array to the end of the buffer</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteBytesUnsafe(System.Byte*,System.Int32)">
            <summary>Append a chunk of memory to the end of the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteBytes(FoundationDB.Client.Slice)">
            <summary>Append a segment of bytes to the end of the buffer</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteFixed16(System.UInt32)">
            <summary>Writes a 16-bit unsigned integer, using little-endian encoding</summary>
            <remarks>Advances the cursor by 2 bytes</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteFixed32(System.UInt32)">
            <summary>Writes a 32-bit unsigned integer, using little-endian encoding</summary>
            <remarks>Advances the cursor by 4 bytes</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteFixed64(System.UInt64)">
            <summary>Writes a 64-bit unsigned integer, using little-endian encoding</summary>
            <remarks>Advances the cursor by 8 bytes</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteVarint16(System.UInt16)">
            <summary>Writes a 7-bit encoded unsigned int (aka 'Varint16') at the end, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteVarint32(System.UInt32)">
            <summary>Writes a 7-bit encoded unsigned int (aka 'Varint32') at the end, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteVarint64(System.UInt64)">
            <summary>Writes a 7-bit encoded unsigned long (aka 'Varint64') at the end, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.WriteVarbytes(FoundationDB.Client.Slice)">
            <summary>Writes a length-prefixed byte array, and advances the cursor</summary>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.EnsureBytes(System.Int32)">
            <summary>Ensures that we can fit a specific amount of data at the end of the buffer</summary>
            <param name="count">Number of bytes that will be written</param>
            <remarks>If the buffer is too small, it will be resized</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.EnsureOffsetAndSize(System.Int32,System.Int32)">
            <summary>Ensures that we can fit data at a specifc offset in the buffer</summary>
            <param name="offset">Offset into the buffer (from the start)</param>
            <param name="count">Number of bytes that will be written at this offset</param>
            <remarks>If the buffer is too small, it will be resized</remarks>
        </member>
        <member name="M:FoundationDB.Client.SliceWriter.GrowBuffer(System.Byte[]@,System.Int32)">
            <summary>Resize a buffer by doubling its capacity</summary>
            <param name="buffer">Reference to the variable holding the buffer to create/resize. If null, a new buffer will be allocated. If not, the content of the buffer will be copied into the new buffer.</param>
            <param name="minimumCapacity">Mininum guaranteed buffer size after resizing.</param>
            <remarks>The buffer will be resized to the maximum betweeb the previous size multiplied by 2, and <paramref name="minimumCapacity"/>. The capacity will always be rounded to a multiple of 16 to reduce memory fragmentation</remarks>
        </member>
        <member name="P:FoundationDB.Client.SliceWriter.Empty">
            <summary>Returns a new, empty, slice writer</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceWriter.HasData">
            <summary>Returns true if the buffer contains at least some data</summary>
        </member>
        <member name="P:FoundationDB.Client.SliceWriter.Item(System.Int32)">
            <summary>Return the byte at the specified index</summary>
            <param name="index">Index in the buffer (0-based if positive, from the end if negative)</param>
        </member>
        <member name="P:FoundationDB.Client.SliceWriter.Item(System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Returns a slice pointing to a segment inside the buffer</summary>
            <param name="beginInclusive">The starting position of the substring. Positive values means from the start, negative values means from the end</param>
            <param name="endExclusive">The end position (excluded) of the substring. Positive values means from the start, negative values means from the end</param>
            <returns>Slice that corresponds to the section selected. If the <paramref name="beginInclusive"/> if equal to or greater than <paramref name="endExclusive"/> then an empty Slice is returned</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">If either <paramref name="beginInclusive"/> or <paramref name="endExclusive"/> is outside of the currently allocated buffer.</exception>
        </member>
        <member name="M:FoundationDB.Client.Utils.Contract.Assert(System.Boolean,System.Int32,System.String)">
            <summary>Assert that a condition is verified, at debug time</summary>
            <param name="condition">Condition that must be true</param>
            <param name="_line">Line number of the calling source file</param>
            <param name="_path">Path of the calling source file</param>
            <remarks>This method is not compiled on Release builds</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.Contract.Assert(System.Boolean,System.String,System.Int32,System.String)">
            <summary>Assert that a condition is verified, at debug time</summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Error message if the condition does not pass</param>
            <param name="_line">Line number of the calling source file</param>
            <param name="_path">Path of the calling source file</param>
            <remarks>This method is not compiled on Release builds</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.Contract.Ensures(System.Boolean,System.Int32,System.String)">
            <summary>Assert that a condition is verified, at debug time</summary>
            <param name="condition">Condition that must be true</param>
            <param name="_line">Line number of the calling source file</param>
            <param name="_path">Path of the calling source file</param>
            <remarks>This method is not compiled on Release builds</remarks>
        </member>
        <member name="M:FoundationDB.Client.Utils.Contract.Ensures(System.Boolean,System.String,System.Int32,System.String)">
            <summary>Assert that a condition is verified, at debug time</summary>
            <param name="condition">Condition that must be true</param>
            <param name="message">Error message if the condition does not pass</param>
            <param name="_line">Line number of the calling source file</param>
            <param name="_path">Path of the calling source file</param>
            <remarks>This method is not compiled on Release builds</remarks>
        </member>
        <member name="T:FoundationDB.Client.Native.TransactionHandle">
            <summary>Wrapper on a FDBTransaction*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbSafeHandle">
            <summary>Base class for all wrappers on FDBxxxx* opaque pointers</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbSafeHandle.Destroy(System.IntPtr)">
            <summary>Call the appropriate fdb_T_destroy(..)</summary>
            <param name="handle">Handle on the FDBFuture</param>
        </member>
        <member name="P:FoundationDB.Client.Native.FdbSafeHandle.Handle">
            <summary>Retourne the value of the FDBFuture handle</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.FDB_C_DLL">
            <summary>Name of the C API dll used for P/Invoking</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.FdbCLib">
            <summary>Handle on the native FDB C API library</summary>
        </member>
        <member name="F:FoundationDB.Client.Native.FdbNative.LibraryLoadError">
            <summary>Exception that was thrown when we last tried to load the native FDB C library (or null if nothing wrong happened)</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.ToNativeString(System.String,System.Boolean)">
            <summary>Converts a string into an ANSI byte array</summary>
            <param name="value">String to convert (or null)</param>
            <param name="nullTerminated">If true, adds a terminating \0 at the end (C-style strings)</param>
            <returns>Byte array with the ANSI-encoded string with an optional NUL terminator, or null if <paramref name="value"/> was null</returns>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.GetError(FoundationDB.Client.FdbError)">
            <summary>fdb_get_error</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.SelectApiVersionImpl(System.Int32,System.Int32)">
            <summary>fdb_select_api_impl</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.SelectApiVersion(System.Int32)">
            <summary>fdb_select_api_impl</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.FdbNative.GetMaxApiVersion">
            <summary>fdb_get_max_api_version</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FdbNative.NativeMethods">
            <summary>Contain all the stubs to the methods exposed by the C API library</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.ClusterHandle">
            <summary>Wrapper on a FDBCluster*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.DatabaseHandle">
            <summary>Wrapper on a FDBDatabase*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.FutureHandle">
            <summary>Wrapper on a FDBFuture*</summary>
        </member>
        <member name="T:FoundationDB.Client.Native.UnmanagedLibrary">
            <summary>Native Library Loader</summary>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.Load(System.String)">
            <summary>Load a native library into the current process</summary>
            <param name="path">Path to the native dll.</param>
            <remarks>Throws exceptions on failure. Most common failure would be file-not-found, or that the file is not a  loadable image.</remarks>
            <exception cref="T:System.IO.FileNotFoundException">if fileName can't be found</exception>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.#ctor(FoundationDB.Client.Native.UnmanagedLibrary.SafeLibraryHandle,System.String)">
            <summary>Constructor to load a dll and be responible for freeing it.</summary>
            <param name="handle">Handle to the loaded library</param>
            <param name="path">Full path of library to load</param>
        </member>
        <member name="M:FoundationDB.Client.Native.UnmanagedLibrary.Dispose">
            <summary>Call FreeLibrary on the unmanaged dll. All function pointers handed out from this class become invalid after this.</summary>
            <remarks>This is very dangerous because it suddenly invalidate everything retrieved from this dll. This includes any functions handed out via GetProcAddress, and potentially any objects returned from those functions (which may have an implemention in the dll)./// </remarks>
        </member>
        <member name="P:FoundationDB.Client.Native.UnmanagedLibrary.Path">
            <summary>Path of the native library, as passed to LoadLibrary</summary>
        </member>
        <member name="P:FoundationDB.Client.Native.UnmanagedLibrary.Handle">
            <summary>Unmanaged resource. CLR will ensure SafeHandles get freed, without requiring a finalizer on this class.</summary>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters">
            <summary>Helper class to convert object from one type to another</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.#cctor">
            <summary>Static ctor that initialize the default converters</summary>
        </member>
        <member name="F:FoundationDB.Client.Converters.FdbConverters.Converters">
            <summary>Map of all known converters from T to R</summary>
            <remarks>No locking required, because all changes will replace this instance with a new Dictionary</remarks>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.RegisterDefaultConverters">
            <summary>Register all the default converters</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.FailCannotConvert(System.Type,System.Type)">
            <summary>Helper method to throw an exception when we don't know how to convert from <paramref name="source"/> to <paramref name="destination"/></summary>
            <param name="source"></param>
            <param name="destination"></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.CreateCaster(System.Type)">
            <summary>Create a new delegate that cast a boxed valued of type T (object) into a T</summary>
            <returns>Delegate that is of type Func&lt;object, <param name="type"/>&gt;</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Create``2(System.Func{``0,``1})">
            <summary>Helper method that wraps a lambda function into a converter</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
            <returns>Converters that wraps the lambda</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.RegisterUnsafe``2(System.Func{``0,``1})">
            <summary>Add a new known converter (without locking)</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Register``2(System.Func{``0,``1})">
            <summary>Registers a new type converter</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Lambda that converts a value of type <typeparamref name="T"/> into a value of type <typeparamref name="R"/></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Register``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1})">
            <summary>Registers a new type converter</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="converter">Instance that can convert values of type <typeparamref name="T"/> into a values of type <typeparamref name="R"/></param>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.GetConverter``2">
            <summary>Returns a converter that converts <typeparamref name="T"/>s into <typeparamref name="R"/>s</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <returns>Valid convertir for this types, or an exception if there are no known convertions</returns>
            <exception cref="T:System.InvalidOperationException">No valid converter for these types was found</exception>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Convert``2(``0)">
            <summary>Convert a value of type <typeparamref name="T"/> into type <typeparamref name="R"/></summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
            <param name="value">Value to convert</param>
            <returns>Converted value</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.Unbox``1(System.Object)">
            <summary>Cast a boxed value (known to be of type <typeparamref name="T"/>) into an unboxed value</summary>
            <typeparam name="T">Runtime type of the value</typeparam>
            <param name="value">Value that is known to be of type <typeparamref name="T"/>, but is boxed into an object</param>
            <returns>Original value casted into its runtime type</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertBoxed``1(System.Object)">
            <summary>Convert a boxed value into type <typeparamref name="R"/></summary>
            <typeparam name="R">Destination type</typeparam>
            <param name="value">Boxed value</param>
            <returns>Converted value, or an exception if there are no known convertions. The value null is converted into default(<typeparamref name="R"/>) by convention</returns>
            <exception cref="T:System.InvalidOperationException">No valid converter for these types was found</exception>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>Converts all the elements of a sequence</summary>
            <returns>New sequence with all the converted elements</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},System.Collections.Generic.List{``0})">
            <summary>Converts all the elements of a list</summary>
            <returns>New list with all the converted elements</returns>
        </member>
        <member name="M:FoundationDB.Client.Converters.FdbConverters.ConvertAll``2(FoundationDB.Client.Converters.IFdbConverter{``0,``1},``0[])">
            <summary>Converts all the elements of an array</summary>
            <returns>New array with all the converted elements</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters.Identity`1">
            <summary>Simple converter where the source and destination types are the same</summary>
            <typeparam name="T">Source and Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Client.Converters.IFdbConverter`2">
            <summary>Class that can convert values of type <typeparamref name="TSource"/> into values of type <typeparamref name="TDestination"/></summary>
            <typeparam name="TSource">Source type</typeparam>
            <typeparam name="TDestination">Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Client.Converters.IFdbConverter">
            <summary>Base class of all value converters</summary>
        </member>
        <member name="M:FoundationDB.Client.Converters.IFdbConverter`2.Convert(`0)">
            <summary>Converts a <typeparamref name="TSource"/> into a <typeparamref name="TDestination"/></summary>
            <param name="value">Value to convert</param>
            <returns>Converted value</returns>
        </member>
        <member name="T:FoundationDB.Client.Converters.FdbConverters.Anonymous`2">
            <summary>Simple converter that wraps a lambda function</summary>
            <typeparam name="T">Source type</typeparam>
            <typeparam name="R">Destination type</typeparam>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleFormatter`1">
            <summary>Helper class to get or create tuple formatters</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.Create(System.Func{`0,FoundationDB.Layers.Tuples.IFdbTuple},System.Func{FoundationDB.Layers.Tuples.IFdbTuple,`0})">
            <summary>Create a custom formatter using the provided lambda functions for convert to and from a tuple</summary>
            <param name="from">Lambda that is called to convert a value into a tuple. It SHOULD NOT return null.</param>
            <param name="to">Lambda that is called to convert a tuple back into a value. It CAN return null.</param>
            <returns>Custom formatter</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.CreateAppender(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Create a formatter that just add or remove a prefix to values</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.CreateDefaultFormatter">
            <summary>Creates and instance of a tuple formatter that is best suited for this type</summary>
        </member>
        <member name="P:FoundationDB.Layers.Tuples.FdbTupleFormatter`1.Default">
            <summary>Return the default tuple formatter for this type</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleTypes">
            <summary>
            Constants for the various tuple value types
            </summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Nil">
            <summary>Null/Empty/Void</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Bytes">
            <summary>ASCII String</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Utf8">
            <summary>UTF-8 String</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.TupleStart">
            <summary>Nested tuple [DRAFT]</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.TupleEnd">
            <summary>End of a nested tuple [DRAFT]</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.IntBase">
            <summary>Base value for integer types (20 +/- n)</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.Guid">
            <summary>RFC4122 UUID (128 bits) [DRAFT]</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.AliasDirectory">
            <summary>Standard prefix of the Directory Layer</summary>
            <remarks>This is not a part of the tuple encoding itself, but helps the tuple decoder pretty-print tuples that would otherwise be unparsable.</remarks>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTupleTypes.AliasSystem">
            <summary>Standard prefix of the System keys, or frequent suffix with key ranges</summary>
            <remarks>This is not a part of the tuple encoding itself, but helps the tuple decoder pretty-print End keys from ranges, that would otherwise be unparsable.</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuplePackers">
            <summary>Helper methods used during serialization of values to the tuple binary format</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.GetSerializer``1(System.Boolean)">
            <summary>Returns a lambda that will be abl to serialize values of type <typeparamref name="T"/></summary>
            <typeparam name="T">Type of values to serialize</typeparam>
            <returns>Reusable action that knows how to serialize values of type <typeparamref name="T"/> into binary buffers, or an exception if the type is not supported</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeNullableTo``1(FoundationDB.Client.SliceWriter@,System.Nullable{``0})">
            <summary>Serialize a nullable value, by checking for null at runtime</summary>
            <typeparam name="T">Underling type of the nullable type</typeparam>
            <param name="writer">Target buffer</param>
            <param name="value">Nullable value to serialize</param>
            <remarks>Uses the underlying type's serializer if the value is not null</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeObjectTo(FoundationDB.Client.SliceWriter@,System.Object)">
            <summary>Serialize an untyped object, by checking its type at runtime</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Untyped value whose type will be inspected at runtime</param>
            <remarks>May throw at runtime if the type is not supported</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,FoundationDB.Client.Slice)">
            <summary>Writes a slice as a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Byte[])">
            <summary>Writes a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.ArraySegment{System.Byte})">
            <summary>Writes an array segment as a byte[] array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Char)">
            <summary>Writes a char as Unicode string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Boolean)">
            <summary>Writes a boolean as an integer</summary>
            <remarks>Uses 0 for false, and -1 for true</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Nullable{System.Boolean})">
            <summary>Writes a boolean as an integer or null</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.SByte)">
            <summary>Writes a signed byte as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Byte)">
            <summary>Writes an unsigned byte as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Int16)">
            <summary>Writes a signed word as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.UInt16)">
            <summary>Writes an unsigned word as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Int32)">
            <summary>Writes a signed int as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.UInt32)">
            <summary>Writes an unsigned int as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Int64)">
            <summary>Writes a signed long as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.UInt64)">
            <summary>Writes an unsigned long as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Single)">
            <summary>Writes a 32-bit IEEE floating point number</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Double)">
            <summary>Writes a 64-bit IEEE floating point number</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.String)">
            <summary>Writes a string as an Unicode string</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.DateTime)">
            <summary>Writes a DateTime converted to a number of ticks encoded as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.TimeSpan)">
            <summary>Writes a TimeSpan converted to a number of ticks encoded as an integer</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Guid)">
            <summary>Writes a Guid as a 128-bit UUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,FoundationDB.Client.Uuid)">
            <summary>Writes a Uuid as a 128-bit UUID</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.SerializeTo(FoundationDB.Client.SliceWriter@,System.Net.IPAddress)">
            <summary>Writes an IPaddress as a 32-bit (IPv4) or 128-bit (IPv6) byte array</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeBoxed(FoundationDB.Client.Slice)">
            <summary>Deserialize a packed element into an object by choosing the most appropriate type at runtime</summary>
            <param name="slice">Slice that contains a single packed element</param>
            <returns>Decoded element, in the type that is the best fit.</returns>
            <remarks>You should avoid working with untyped values as much as possible! Blindly casting the returned object may be problematic because this method may need to return very large intergers as Int64 or even UInt64.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeFormattable``1(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into a type that implements ITupleFormattable</summary>
            <typeparam name="T">Type of a class that must implement ITupleFormattable and have a default constructor</typeparam>
            <param name="slice">Slice that contains a single packed element</param>
            <returns>Decoded value of type <typeparamref name="T"/></returns>
            <remarks>The type must have a default parameter-less constructor in order to be created.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeFormattable``1(FoundationDB.Client.Slice,System.Func{``0})">
            <summary>Deserialize a slice into a type that implements ITupleFormattable, using a custom factory method</summary>
            <typeparam name="T">Type of a class that must implement ITupleFormattable</typeparam>
            <param name="slice">Slice that contains a single packed element</param>
            <param name="factory">Lambda that will be called to construct a new instance of values of type <typeparamref name="T"/></param>
            <returns>Decoded value of type <typeparamref name="T"/></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeInt32(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an Int32</summary>
            <param name="slice">Slice that contains a single packed element</param>
            <returns></returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeInt64(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an Int64</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeUInt32(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an UInt32</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeUInt64(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into an UInt64</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeString(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into a Unicode string</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeGuid(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into Guid</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.DeserializeIPAddress(FoundationDB.Client.Slice)">
            <summary>Deserialize a slice into Guid</summary>
            <param name="slice">Slice that contains a single packed element</param>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.Unpack(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from a buffer</summary>
            <param name="buffer">Slice that contains the packed representation of a tuple with zero or more elements</param>
            <returns>Decoded tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.UnpackSingle(FoundationDB.Client.Slice)">
            <summary>Ensure that a slice is a packed tuple that contains a single and valid element</summary>
            <param name="buffer">Slice that should contain the packed representation of a singleton tuple</param>
            <returns>Decoded slice of the single element in the singleton tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.UnpackFirst(FoundationDB.Client.Slice)">
            <summary>Only returns the first item of a packed tuple</summary>
            <param name="buffer">Slice that contains the packed representation of a tuple with one or more elements</param>
            <returns>Raw slice corresponding to the first element of the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.UnpackLast(FoundationDB.Client.Slice)">
            <summary>Only returns the last item of a packed tuple</summary>
            <param name="buffer">Slice that contains the packed representation of a tuple with one or more elements</param>
            <returns>Raw slice corresponding to the last element of the tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePackers.ParseNext(FoundationDB.Client.SliceReader@)">
            <summary>Decode the next token from a packed tuple</summary>
            <param name="reader">Parser from wich to read the next token</param>
            <returns>Token decoded, or Slice.Nil if there was no more data in the buffer</returns>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbSlicedTuple">
            <summary>Lazily-evaluated tuple that was unpacked from a key</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_slices">
            <summary>Buffer containing the original slices. Note: can be bigger than the size of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_offset">
            <summary>Start offset of the first slice of this tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbSlicedTuple.m_count">
            <summary>Number of slices in this tuple.</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`1">
            <summary>Tuple that holds only one item</summary>
            <typeparam name="T1">Type of the item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`1.Item1">
            <summary>First and only item in the tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`2">
            <summary>Tuple that holds a pair of items</summary>
            <typeparam name="T1">Type of the first item</typeparam>
            <typeparam name="T2">Type of the second item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`2.Item1">
            <summary>First element of the pair</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`2.Item2">
            <summary>Seconde element of the pair</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuple`3">
            <summary>Tuple that can hold three items</summary>
            <typeparam name="T1">Type of the first item</typeparam>
            <typeparam name="T2">Type of the second item</typeparam>
            <typeparam name="T3">Type of the third item</typeparam>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item1">
            <summary>First element of the triplet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item2">
            <summary>Second element of the triplet</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbTuple`3.Item3">
            <summary>Third and last elemnt of the triplet</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbMemoizedTuple">
            <summary>Represents an immutable tuple where the packed bytes are cached</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbMemoizedTuple.Items">
            <summary>Items of the tuple</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbMemoizedTuple.Packed">
            <summary>Packed version of the tuple</summary>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbListTuple">
            <summary>Tuple that can hold any number of untyped items</summary>
        </member>
        <member name="F:FoundationDB.Layers.Tuples.FdbListTuple.m_items">
            <summary>List of the items in the tuple.</summary>
            <remarks>It is supposed to be immutable!</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbListTuple.#ctor(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>Create a new tuple from a sequence of items (copied)</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbListTuple.#ctor(System.Object[],System.Int32,System.Int32)">
            <summary>Wrap a List of items</summary>
            <remarks>The list should not mutate and should not be exposed to anyone else!</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTupleExtensions">
            <summary>Add extensions methods that deal with tuples on various types</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.IsNullOrEmpty(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns true if the tuple is either null or empty</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.IsSingleton(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns true if the tuple is not null, and contains only one item</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToArray(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns an array containing all the objects of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToArray``1(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns a typed array containing all the items of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.GetBytes(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns a byte array containing the packed version of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Concat(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Concatenates two tuples together</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Append``2(FoundationDB.Layers.Tuples.IFdbTuple,``0,``1)">
            <summary>Appends two values at the end of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Append``3(FoundationDB.Layers.Tuples.IFdbTuple,``0,``1,``2)">
            <summary>Appends three values at the end of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Append``4(FoundationDB.Layers.Tuples.IFdbTuple,``0,``1,``2,``3)">
            <summary>Appends four values at the end of a tuple</summary>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToRange(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Creates a key range containing all children of this tuple, from tuple.pack()+'\0' to tuple.pack()+'\xFF'</summary>
            <param name="tuple">Tuple that is the suffix of all keys</param>
            <returns>Range of all keys suffixed by the tuple. The tuple itself will not be included</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToRange(FoundationDB.Layers.Tuples.IFdbTuple,System.Boolean)">
            <summary>Creates a key range containing all children of tuple, optionally including the tuple itself.</summary>
            <param name="tuple">Tuple that is the prefix of all keys</param>
            <param name="includePrefix">If true, the tuple key itself is included, if false only the children keys are included</param>
            <returns>Range of all keys suffixed by the tuple. The tuple itself will be included if <paramref name="includePrefix"/> is true</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Memoize(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Creates pre-packed and isolated copy of this tuple</summary>
            <param name="tuple"></param>
            <returns>Create a copy of the tuple that can be reused frequently to pack values</returns>
            <remarks>If the tuple is already memoized, the current instance will be returned</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.ToTuple(FoundationDB.Client.Slice)">
            <summary>Unpack a tuple from this slice</summary>
            <param name="slice"></param>
            <returns>Unpacked tuple if the slice contains data, FdbTuple.Empty if the slice is empty, or null if the slice is Slice.Nil</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Substring(FoundationDB.Layers.Tuples.IFdbTuple,System.Int32)">
            <summary>Returns a substring of the current tuple</summary>
            <param name="tuple">Current tuple</param>
            <param name="offset">Offset from the start of the current tuple (negative value means from the end)</param>
            <returns>Tuple that contains only the items past the first <param name="offset"/> items of the current tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Substring(FoundationDB.Layers.Tuples.IFdbTuple,System.Int32,System.Int32)">
            <summary>Returns a substring of the current tuple</summary>
            <param name="tuple">Current tuple</param>
            <param name="offset">Offset from the start of the current tuple (negative value means from the end)</param>
            <param name="count">Number of items to keep</param>
            <returns>Tuple that contains only the selected items from the current tuple</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.StartsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Test if the start of current tuple is equal to another tuple</summary>
            <param name="left">Larger tuple</param>
            <param name="right">Smaller tuple</param>
            <returns>True if the beginning of <paramref name="left"/> is equal to <paramref name="right"/> or if both tuples are identical</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.EndsWith(FoundationDB.Layers.Tuples.IFdbTuple,FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Test if the end of current tuple is equal to another tuple</summary>
            <param name="left">Larger tuple</param>
            <param name="right">Smaller tuple</param>
            <returns>True if the end of <paramref name="left"/> is equal to <paramref name="right"/> or if both tuples are identical</returns>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTupleExtensions.Increment(FoundationDB.Layers.Tuples.IFdbTuple)">
            <summary>Returns a key that is immediately after the packed representation of this tuple</summary>
            <remarks>This is the equivalent of manually packing the tuple and incrementing the resulting slice</remarks>
        </member>
        <member name="T:FoundationDB.Layers.Tuples.FdbTuplePacker`1">
            <summary>Helper class that can serialize values of type <typeparamref name="T"/> to the tuple binary format</summary>
            <typeparam name="T">Type of values to be serialized</typeparam>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePacker`1.SerializeTo(FoundationDB.Client.SliceWriter@,`0)">
            <summary>Serialize a <typeparamref name="T"/> into a binary buffer</summary>
            <param name="writer">Target buffer</param>
            <param name="value">Value that will be serialized</param>
            <remarks>The buffer does not need to be preallocated.</remarks>
        </member>
        <member name="M:FoundationDB.Layers.Tuples.FdbTuplePacker`1.Serialize(`0)">
            <summary>Serialize a <typeparamref name="T"/> into a slices</summary>
            <param name="value">Value that will be serialized</param>
            <returns>Slice that contains the binary representation of <paramref name="value"/></returns>
        </member>
        <member name="T:FoundationDB.Async.TaskHelpers">
            <summary>Helper methods to work on tasks</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.CompletedTask">
            <summary>Return a task that is already completed</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.FalseTask">
            <summary>Already completed task that returns false</summary>
        </member>
        <member name="F:FoundationDB.Async.TaskHelpers.TrueTask">
            <summary>Already completed task that returns true</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromResult(System.Boolean)">
            <summary>Returns an already completed boolean task that is either true of false</summary>
            <param name="value">Value of the task</param>
            <returns>Already completed task the returns <paramref name="value"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Default``1">
            <summary>Returns a cached completed task that returns the default value of type <typeparamref name="T"/></summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <returns>Task that is already completed, and returns default(<typeparamref name="T"/>)</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Then``1(System.Threading.Tasks.Task{``0},System.Action{``0})">
            <summary>Continue processing a task, if it succeeded</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Then``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>Continue processing a task, if it succeeded</summary>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>Runs a synchronous lambda inline, exposing it as if it was task</summary>
            <typeparam name="R">Type of the result of the lambda</typeparam>
            <param name="lambda">Synchronous lambda function that returns a value, or throws exceptions</param>
            <param name="ct">Cancellation token</param>
            <returns>Task that either contains the result of the lambda, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="lambda"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``1(System.Action{``0},``0,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">Argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``2(System.Action{``0,``1},``0,``1,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``3(System.Action{``0,``1,``2},``0,``1,``2,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``4(System.Action{``0,``1,``2,``3},``0,``1,``2,``3,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <typeparam name="T4">Type of the fourth parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="arg4">Fourth argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Inline``5(System.Action{``0,``1,``2,``3,``4},``0,``1,``2,``3,``4,System.Threading.CancellationToken)">
            <summary>Runs a synchronous action inline, exposing it as if it was task</summary>
            <typeparam name="T1">Type of the first parameter of the lambda</typeparam>
            <typeparam name="T2">Type of the second parameter of the lambda</typeparam>
            <typeparam name="T3">Type of the third parameter of the lambda</typeparam>
            <typeparam name="T4">Type of the fourth parameter of the lambda</typeparam>
            <typeparam name="T5">Type of the fifth parameter of the lambda</typeparam>
            <param name="action">Synchronous action that takes a value.</param>
            <param name="arg1">First argument that will be passed to <paramref name="action"/></param>
            <param name="arg2">Second argument that will be passed to <paramref name="action"/></param>
            <param name="arg3">Third argument that will be passed to <paramref name="action"/></param>
            <param name="arg4">Fourth argument that will be passed to <paramref name="action"/></param>
            <param name="arg5">Fifth argument that will be passed to <paramref name="action"/></param>
            <param name="ct">Cancellation token</param>
            <returns>Task that is either already completed, wraps the exception that was thrown, or is in the cancelled state if the cancellation token fired or if the task throwed an OperationCanceledException</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="action"/> is null</exception>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.WithCancellation``2(System.Func{``0,``1})">
            <summary>Wraps a classic lambda into one that supports cancellation</summary>
            <param name="lambda">Lambda that does not support cancellation</param>
            <returns>New lambda that will check if the token is cancelled before calling <paramref name="lambda"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.WithCancellation``2(System.Func{``0,System.Threading.Tasks.Task{``1}})">
            <summary>Wraps a classic lambda into one that supports cancellation</summary>
            <param name="lambda">Lambda that does not support cancellation</param>
            <returns>New lambda that will check if the token is cancelled before calling <paramref name="lambda"/></returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromCancellation``1(System.Threading.CancellationToken)">
            <summary>Returns a cancelled Task that is linked with a specific token</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="cancellationToken">Cancellation token that should already be cancelled</param>
            <returns>Task in the cancelled state that is linked with this cancellation token</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.Canceled``1">
            <summary>Returns a cancelled Task that is not linked to any particular token</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <returns>Task in the cancelled state</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.FromException``1(System.Exception)">
            <summary>Returns a failed Task that wraps an exception</summary>
            <typeparam name="T">Type of the result of the task</typeparam>
            <param name="e">Exception that will be wrapped in the task</param>
            <returns>Task that is already completed, and that will rethrow the exception once observed</returns>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancel(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel a CancellationTokenSource</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelAndDispose(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel and dispose a CancellationTokenSource</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled and disposed</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelDefered(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel a CancellationTokenSource, executing the registered callbacks on the thread pool</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled</param>
        </member>
        <member name="M:FoundationDB.Async.TaskHelpers.SafeCancelAndDisposeDefered(System.Threading.CancellationTokenSource)">
            <summary>Safely cancel and dispose a CancellationTokenSource, executing the registered callbacks on the thread pool</summary>
            <param name="source">CancellationTokenSource that needs to be cancelled and disposed</param>
        </member>
        <member name="T:FoundationDB.Async.TaskHelpers.Cache`1">
            <summary>Helper type cache class</summary>
        </member>
        <member name="P:FoundationDB.Async.TaskHelpers.Cache`1.Nop">
            <summary>Returns a lambda function that returns the default value of <typeparamref name="T"/></summary>
        </member>
        <member name="P:FoundationDB.Async.TaskHelpers.Cache`1.Identity">
            <summary>Returns the identity function for <typeparamref name="T"/></summary>
        </member>
    </members>
</doc>
